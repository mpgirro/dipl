
Comparative Evaluation {#ch-evaluation}
==========

<!-- of Actors and Microservices -->


~ Epigraph { caption: "Jeannette M. Wing"}
Thinking like a computer scientist means more than being able to program a computer. It requires thinking at multiple levels of abstraction.
~

Chapter [#ch-actor-model] and [#ch-microservice-paradigm] introduced Actors and Microservices separately and focused on their individual concepts. Subsequent chapters [#ch-actor-impl] and [#ch-microservice-impl] demonstrated that different solution strategies have to be applied as a result of inherent differences. This chapter will compare and evaluate the conceptualities applied by Actors and Microservices involved such that both approaches can achieve concurrent computation within their respective architectures. 


## Encapsulation and Isolation {#sec-commonalities-isolation}


~todo
Hier die Sachen von unten als Einführung beschreiben (ohnehin nicht mehr all zu viel übrig)
~

~LitNote
* "promise behaviour via API/protocol" --> design by contract
* [@Kan12] 4 four important semantic properties of our
extension based on Actor systems: encapsulation, fairness, location transparency and mobility [16 --> Actor Frameworks for the JVM Platform: A Comparative Analysis]
* [@Bon17] "This simple fact has huge implications. It means that data can be strongly consistent only within each service but never between serv‐ ices, for which we need to rely on eventual consistency and abandon transactional semantics"
* [@Bon17] "Isolation makes it easier to scale each service, as well as allowing them to be monitored, debugged, and tested independently"
* [@Kni96] "Encapsulation is probably the only feature that is generally agreed to be an indispensable (sine qua non) characteristic of object-oriented languages. Some researchers even consider encapsulation to be the fundamental object-oriented concept and that all other object-oriented mechanisms and approaches exploit encapsulation to various ends ([9]). There also seems to be general agreement on the fact that encapsulation and sharing are incompatible: sharing tends to violate encapsulation while encapsulation tends to prevent sharing."
    * hier muss ich auch noch was zu visibility schreiben, weil ich im actor-solution kapitel schreibe das es hier schon vorgekommen ist!
* MS sind per definition, insofern sie auf shared memory konzepte verzichten, immer perfekt isoliert, durch das OS. Bei Actor müssen die verschiedenen "notions of state" beachtet werden, um eine strong state notion einzuhalten, also preserve local state and transient state, wie es in [@Kni96] beschrieben ist
* [@Kar09] Encapsulation = State Encpasulation + Safe Messaging
    * nach meiner auffassung ist das genau isolation; das sollte ich vll hier anbringen
~

Actor and Microservice semantics rely on a strict separation of component states. This arises the need to ensure that state is conceptually encapsulated within a component and practically isolated from the outside. 

The conceptual need is known from Object Oriented Programming. As Snyder points out, OOP usually offers mechanisms to restrict the access to an objects state by requiring clients to issue requests for the services an object offers in order to get access to or modify the objects state [@Sny93]. These "services" - not to be confused with the concept of a *Microservice* - are what Meyer calls "well-defined interfaces" in the form of *routines*, and considers to be a necessity for encapsulation [@Mey97]. 

Both Actors and Microservices define such well-defined interfaces in their own way. For Actors its the sum of messages it understands through its behavior. For Microservices, it's based on the sum of facilitated communication channels, e.g. the REST interfaces it exposes, or the messages it consumes from a message broker (e.g. AMQP queue). Only through these can the state be accesses or modification made.

~ todo
HIER SCHON SCHLUSS? ABSATZ UNTEN WEG?!
~

Ensuring that state is only accessible through the a components interface, i.e. that it is isolated from any illegal access from the components outside, is rather different for both styles due to their conceptual differences.

...


### Shared and Mutable State


One fundamental characteristic of both Actors and Microservices is their notion of shared state. Summarizing chapter [#ch-actor-model], the Actor model encapsulates state exclusively within an Actor. Therefore it can only be accessed and modified by the Actor itself. Additionally, Actors provide single-threaded semantic while processing messages, i.e. only one message is processed at a time. This eliminates any need for synchronization, for a message has exclusive access to the Actors current state, and thus is free of low-level data races. The Actors state is fully isolated.

On the other hand, such reasoning cannot be done for Microservices in general. The paradigm states nothing about how state has to be handled internally. Depending on the programming paradigm used to implement the service, i.e. multiple objects could have access the same memory location. Furthermore, these state accesses could be executed concurrently, e.g. as a reaction to multiple invocations of the services interface within a short timespan. Microservices do not ensure any kind of single-threaded semantic. This requires synchronization to internal service's state.

However, the Microservice paradigm dictates that shared memory *between* services is to be avoided, as are all kinds of shared resources in general. For every service runs within its own system process, avoiding shared memory implies no direct intersection between service process boundries. Typical communication channels satisfying the requirements given in § [#sec-ms-communication] also prevent any form of reference sharing to joined mutable data. Such channels tend to provide some sort of message passing designed to transfer information between the different memory spaces of distinct processes [@Les09].

Actors are generally faced with more challenges when it comes to truely ensuring state separation, because the components can exist within the same process boundries. This theoretically allows access to the same memory locations [citation needed, irgendwo bei der OS literatur wird schon was stehen]{.mind}. Depending on the programming paradigm used for implementing the Actors, exposing shared state to others might be very simple and not apparent to the programmer. Especially the imperative style leans on mutable state, thus suffering from the need of applying extra care to preserve the model semantic. The functional paradigm tends to avoid such problems inherently, for behaviour is modeled as a function, and this function is the only mutable state, which may be modified exclusively by the Actor itself. If the Actor model is integrated into the programming language itself, such problems can be avoided by designing appropriate restrictions enforced by the language directly. However, library based Actor implementations in general cannot ensure full isolation by themselves [@Kos16]. Section [#sec-ensuring-actor-isolation] will discuss in detail the specific demands such libraries can pose to the programmer for a given Actor library.


### Persistance {#sec-commonalities-persistance}


The encapsulation and isolation principle of Actors or Microservices has one more important implication for both concepts. For state is exclusive to a single component, each must also take exclusive care if given state is expected to be durable accross the components livetime. This property is usually refered to as *persistence* [kann ich da was zitieren?]{.mind}.

Persisting information can be implemented in many different strategies. Database systems are one well established approach. Sharing a database between two or more components would grant access to one component's persistent state to all others connceted to the same database used. This would not only provide a simple way to skip any isolation mechanisms and bypass the components interface, thus breaking the encapsulation principle. Additionally, it would also open up a form of implicit communication through shared mutable state [hierzu hab ich irgendwo literatur]{.mind}.

The consequence is, that any component must have its very own database, or persistance mechanism in general, if such is required. This restriction has to be taken care of by programmers, for neither an Actor System, nor any Microservice technique can enforce this. Unfortunatelly, this is a rather unintuitive requirement, for database systems have always been design to be accessed and used by multiple components concurrently in general. Database APIs tend to allow that multiple modules (concurrent or not) inside a single program might read from and write to the same database instance, thus it is easy easy in general for multiple Actors too.

Inside a Microservice, this is not a problem. Multiple internal modules may use a database exclusive to the service, as is with any other monolithic application. However, multiple Microservices must not leverage the same database that could be available for both of them. 

This restriction opens up another opportunity however. Monolithic applications tend to rely on as few database systems as possible, for a multitier architecture traditionally has the data access layer at the bottom, and consecutive layers are build relative to it. Thus, any new database system bringt the risk of fundamentally impacting a programs architecture. It is therefore unusual for program modules to have their own persistance layer exclusive to them. However, due to their respective natures, modules based on the Actor abstraction and systems composed of Microservices make it easy to add a persistance layer to accomodate their special requirements. 

This approach on introducing specialized database systems based on respective persistance needs, at the risk of introducing potential redundancies, is sometimes refered to as *polyglott persistance* [citation?]{.mind}.


## Communication and Message Routing {#sec-communication-message-routing}


According to the general concerns of concurrent computation, tasks refraining from utilizing mutuable shared memory require other kinds of communication links which facilitate message passing instead. As both the Actor model and Microservice principles strictly omit any form of shared state, they too require what will be refered to as *communication channels* for messaging. Such channels transport information from a source to a destination, i.e. a *sender* is writing data to the channel, upon which a *receiver* may read it. Independent of the concrete channel technology, this implies an implicit synchroniztion of the information, for the event of reading a message can intrinsically only occur *after* it has been sent. In contrast, shared state would must explicitely require to define an order of accessing information [@And83].

Throughout the literature we've identified various forms of information flows offered by channel concepts [@Mon14;@Gui09;@Spe90;@Roe15;@Agh99;@Tan07;@Bac03]. Generally they can be distinguished alongside two dimensions: number of recipients and response coupling. Authors declare varying taxonomies for the resulting combinations. The following table provides an overview of the terminology used in the remainder of this work:

~ center
|------------------|------------------------|-------------------------|
|                  | One-to-One             | One-to-Many             |
+------------------+------------------------+-------------------------+
| **Synchronous**  | Request/response       | -                       |
| -----------------|------------------------|-------------------------|
| **Asynchronous** | Notification           | Publish/subscribe       |
|                  | Request/async response | Publish/async responses |
|------------------|------------------------|-------------------------|
{  }
~

Asynchronous one-to-one messaging is inherent to the Actor model. The message sending primitive realizes notification style communication. An asynchronous response is possible in the same way, yet requires the address of the requestor. Therefore Akka provides the `sender()` method within Actors, which produces in each turn the `ActorRef`{language:scala} of the message's originator. Microservices achieve asynchrony via message queues. Responding depends on the channel protocol. AMQP does not transmit the senders location, thus if such is required it has to be included into messages individually. 

Synchronous one-to-one messaging can be abstracted ontop of Actor messaging primitive, as in general any synchronous communication can be modeled using asynchronous constructs, and vice versa [@Agh97]. Akka provides linguistic support for request/response styled messaging through its `ask`{language:java} method as well as the `?` alias thereof on `ActorRef`{language:scala}. Microservices can utilize network mechanism dedicated to this interaction pattern. In their context, REST is the most prominent example. 

One-to-many communication is neither inherent as a primitive to Actors nor Microservices, thus requires additional effort. Conceptually it can be modeled as sending a message to all intended recipients in a one-to-one fashion each. As this is a generic functionality involving merely a communication mechanism, messages and recipients without any domain specific functionality, it is convenient to be modeled as a separate task unit:

* Message Broker (B)
  : are commissioned with messages and forward them to potential recipients. Their functionality is domain independent and merely concerned with communication, thus broker tasks constitute a communication channel.

For example, when a Store needs to modify its state, instead of performing the update operation directly, it sends a respective message to be brokered to all Store units of the same kind, e.g pushed `C` &rarr; `B` from which it gets pulled $\{$`C`~1~$\cdots$`C`~n~$\}$  &larr; `B` by all CatalogStores, even the sender, such that each of them can perform the state update.

Actors have message broker capability in their message router constructs through the respective `BroadcastRoutingLogic`{language:scala}. In the MSA, the RabbitMQ service does not suffice, as AMQP only supports what the JMS terminology calls *Queue*-semantic (one-to-one) but not its *Topics* (one-to-many). Another messaging technology has to be applied. Kafka [@ApacheKafka] for example is a widely adopted publish/subscribe streaming system with very lightweigh message constructs, thus appropriate for the Microservice paradigm. 


## Cohesion, Coupling and Independence


Truely isolated components combined through the communication style of asynchronous message passing results in a *decoupling* in two dimensions, as Bonèr [@Bon16] defines. On the one hand, they are decoupled in *time*, which allows for their concurrent execution. On the other hand, they are decoupled in *space*, such that they may be executed remotely and even be moved between locations.

Regarding time, actors facilitate asynchronicity through the model design, but actor system still tend to offer synchronous abstractions ontop of the asynchronous style, in order to provide better abstractions for programmers, at the cost of increasing coupling. Microservices in general are free to choose the IPC style, as long as it is based on message passing rather than shared memory, with respective effects on coupling.

Regarding space, though actors are conceptually fully isolated, it is hard to ensure true isolation in practice, especially for library-based actor implementations, as has been discussed in detail. In the end, it us up to the programmer to guarantee it by complying to programming conventions and avoid exposing or introducing state by violating the model abstraction, which would otherwise increase the coupling to the sharing component, both in time and in space. 

Microservices have an inherent advantage regardless of their chosen programming model, for their only true requirement is the avoidance of shared memory sections with other processes. Then either the memory boundries enforced by the operating system, or the hardware separation comming from distribution guarantees separation and this spacial decoupling. The only other effect is based on any kind of shared code base, e.g. a common libary that is assumbed to be used by multiple services, also increasing the services coupling relative to it. Actor however suffer from this problem unequally more, for any actor within a system is instrinsically bound to it. Different interfaces to an actor system may exist, as Akka demonstrates for Java and Scala, yet actors cannot escape the coupling to the code base of their actor system [KANN ICH DA WAS ZITIEREN?]{.red}.

A metric that is often stated to correlate with coupling is cohesion [@Woo93]. If coupling is low, then cohesion tends to be high. Cohesion is reflected in the single responsibility principle, such that aspects required to fulfilling the functionality is encapsulated within a single unit, respective an actor or microservice. Again, shared libraries pose a problem. Echo's commonly used `core` library, wrapping most domain specific logic, is generally a prime example. It increases coupling and decreased cohesion of all components using it (which almost all actors and microservices are), but the affect is accepted to gain a better separation between domain logic and communication and coordination logic. Apart from that, modularity in both actor and microservice systems is high, as functionality of components can be arbitrarily used and combined.

This two notions, high cohesion and low coupling, allow to reason about the *independence* of task units. It is one of the primary concepts of the microservice paradigm, and is described as a direct concequence of high cohesion and low coupling throughout the literature [@Dra17a;@Dra17b;@Dra17c;@Sha17b]. We deem the strong form of indepence superior to the notion provided by the actor abstraction, as such are not necessarily contained within the strong boundries of dedicated processes, and intrinsically depend on the actor system for versatile aspects, down to the basic primitives. Message routing has already been discussed, and more will be evaluated in subsequent sections, for example the providance location transparency in addresses, and a guarantee of fairness.  


## Notions of Concurrency


Both Actors and Microservices are the components that are being executed concurrently within their system architectures. However, both constructs have different notions of concurrency, which is a direct result of the underlying concepts.


### Concurrency through Threads and Processes


Actors and Microservices are fundamentally differently executed. Scala's standard Actors have provided two different execution semantics with their Actor abstraction [@Hal09]. One is based on threads on which Actors are scheduled to be executed. Such Actors are executed in an Inversion of Control manner [@Hal06], similarly to the strategy of the Spring framework. The other is purely event-based and therefore without IoC. Thread-based Actors are invoked by their current thread to execute a turn and upon completion return to their calling thread. Event-based Actors on the other hand do not have (and need) a thread, thus cannot return to one. Instead, they facilitate a much cheaper concept called *continuation-passing style* known from functional programming, where a function refrains from returning a computed result by calling a subsequent function, the so-called *continutation closure*. Akka extends this approach by defining as single closure to be used by for all messages, which has shown to be much more effective [@Hal12]. `Dispatcher`{language:scala}s can be used to influence the thread assignment strategy used for concurrently running the behavior closures [@Hal12]. Threads are conceptually similar to processes, except that multiple of them can exist within a single process [@Bac03]. There the Actor thread-pools live in one or few processes, such that many Actors share the same memory boundries of the respective process. 

Although executed ontop of threads, the Isolated Turn Principle essentially define Actors as single-threaded entities. Only in combination with asynchronous message passing as dictated by the model allows for a concurrent execution of the components. As such, an Actor has no notion of any concurrency at all in general. As was demonstrated, additional concurrency abstractions may be introduced into Actors, as long as those do not break model semantic. Futures were given as one option, with the potential pitfalls discussed in chapter [#ch-actor-impl]. 

<!-- TODO delete?
Such abstract a value which will be available at some point in time eventually. Basically they introduce a notion of semi-blocking behaviour [irgendwo hab ich hierfür ein zitat!]{.mind}. Either the value is available when trying to access it, or blocking is the consequence until it is. A third way of handling Futures is possible, which directly defines consecutive computation on the value without blocking, but once it becomes available. In any case however, they pose the risk of accidentially introducing data races. As a safer alternative, Actors can use delegation to child Actors to provide concurrent processing, without jeopardising safe encapsulation as do Futures.
-->

Microservices, on the other hand, are concurrent distributed processes. Their notion of concurrency may deviate from Actor, for they internally do not have a counterpart to the Isolated Turn Principle to respect. Though a service also receives messages via its public API and reacts to them, the flexibility in the design allows them to be task units which are concurrent internally. Thus they may utilize multiple threads to perform blocking operations without blocking their entire process, as is a widespread strategy in the domain of distributed systems in general [@Tan07]. This also enables them to react to multiple messages simultaniously. 
 
The drawback of this degree of freedom is the set of issues any internal concurrency might introduce. Accessing state cannot in general be assumed a safe operation if it is accessible across threads, and thus synchronization as it has been demonstrated in the Java case study has to be applied. Thus, programming with Microservices does not free one from the many hassles of low-level concurrency concerns per se. However, the services size - based on its scope of responsibility - is limiting the complexity of the services internal concurrency considerations relative to the overall systems. As a result, linguistic approaches to SOC migth try to avoid this completely by applying an idea resembling the C processes case study. The `concurrent`{color:blue} primitive for Jolie services execution modality for example dispatch dedicated processes for concurrently executing the service behavior in response to messages [@Mon16b]. This has close resemblance to the delegation messaging pattern used by Actors.

Alternatively, the design freedom of services in general also allows them to apply Actor-based concurrency internally, such that the benefits of synchronization-free programming can be harvested by services too. 


<!-- TODO delete?
...rresource access inherently has. A basic example is locking. When an Actor processes a message, it is guaranteed to have unqiue access to its internal state, therefore must no handle any locks and can savely assume its state as up to date. When a Microservice accesses any kind of internal resource (state), this resource might currently be locked by an internal transaction mechanism, granting read access, but not guaranteeing that the state is actually up to date. [dirty read? irgendwas allgemeines zu locking und read zitieren]{.mind} 

Programming with Microservices does not, unlike Actors, free one from the many hassles of low-level concurrency concerns per se. Depending on the model used, locking and synchronization as demonstrated in the concurrency in Java case study might have to be dealt with. However, the services size - based on its scope of responsibility - is limiting the complexity of the services internal concurrency considerations relative to the overall systems [citation needed? hab ich da eine? ist ja eigentlich mein eigener beitrag]{.mind}. As a result, linguistic approaches to SOC migth try to avoid this completely by applying an idea resembling the C processes case study. The `concurrent`{color:blue} primitive for Jolie services execution modality for example dispatch dedicated processes for concurrently executing the service behavior in response to messages [@Mon16b]. This has close resemblance to the delegation messaging pattern used by Actors.
-->


### Fairness and Resource Consumption


Actors and Microservices represent concurrent building blocks of equal status in their respective architectiures. Due to our uniform view on concurrent execution, that is regardless of quasi-simultanious on a single processor, truely parallel on multiple CPUs and distributed among host machines, it is important to reason about the chances to make even progress [@Bus90]. This property is called *fairness* and is closely related to the liveness of concurrent programs and systems, i.e. to avoid starvation [@Agh85a;@Agh99].

Actors are entities inside an Actor System. As such, their scheduling is the responsibility of this system, viz. its execution strategy. As passiv components, Actors have no proactive sense, i.e. they only react to events (received messages). Actor Systems assure that each message is delivered to and process by an Actor eventually. Therefore each Actor must be scheduled regularly by the system to guarantee that it cannot permanently starve [@Kan12;@Kar09].

This has one major benefit. If an Actor's mailbox is empty, it is therefore not necessary for the system to invoke it, for there is nothing to do for it. This way, an Actor system can greatly reduce processing resource consumption [citation?]{.mind}.

For Microservices on the other hand, scheduling itself is a nonconcern. Any MSA is a composition of concurrent distributed processes, and as such their scheduling is delegated to the operating system(s) these processes are running on, respectively it's *scheduling policy* [@Bac03]. Thus we cannot make any specific assumption on execution rates, but require them to be positive. This *finite progress assumption* [@And83] is the foundation of liveness for any Microservice.

There is one drawback to the lack of scheduling influence in MSA's however. The architecture cannot influence the resource consumption based on a services actual demand. An operating system will always allocate resources towards a process, and thus any task unit will always stress its hosts processing power on a regular basis, at least to a small amount. This is true even when the service is neither requested nor has active behavior of its own to execute. Such process activations are then simply a waste of energy [hab ich da was zu energy consumption?]{.mind}.


## Distribution


~LitNote
* Actors und MS ist es an sich egal ob sie lokal oder verteilt ausgeführt werden, beide können dies gut abstrahieren
* [@Reh13] defines requirements on distributed Actors:
    * R1: Distributability: Non-distributed applications must be easy to be migrated to clustered set-ups.
    * R2: API-uniformity: The distribution API must be similar for intra-node as well as inter-node applications
    * R3: Compatibility: An application that works locally on one node should also work distributed in a cluster.
    * R4: Flexibility: Beside Actors that have access to specific hardware, the developer should freely decide which Actor runs on which node of the cluster.
    * R5: Configurability: Simple configuration of the clustering subsystem and the distribution layout.
* [@Kan15] (über distributed/cloud Actors)
    * "There (Actor) distinctive features make it suitable to support distributed memory parallelism, and it has been widely used in many industrial languages such as Erlang[2], Scala [3], Akka [4]"
    * "However, most related works focus on multi-core environment. Neither inter-parallelism or task parallelism can be easy applied in dynamic distributed environment, because Actors distributing over cluster may be- have indeterminable interrelationship, such as uncertain com- munication, dependency and failure"
* [@Kan12] (über distributed Actors)
    * Computers connect by network, which makes the environment distributed, disparate, mutable and unreliable
    * According to classifications of parallel programming models in process interaction, mechanisms of which make the parallel processes able to communication with each other, the most common forms of interaction are shared memory, message passing, and implicit [4]
    * In Actor model, location transparency means the actual location of an Actor does not affect its name. That is to say, if one Actor knows another, they can communicate only by names instead of specific address --> kommunikating via ActorRef instead of pointer; bei MS muss das zB für REST extra ein Service Discovery übernehmen, der dies abstrahiert; 
    * Obviously, State encapsulation is a desirable consequence of location transparency. Location transparency facilitates runtime migration of our computing elements to different nodes, which brings good mobility. Moreover, migration enables runtime optimizations for load-balance and fault-tolerance
* [@Fel90] "Language and System Support for Concurrent Programming"
    * beschreibt das Message passing ganz prinzipiell nicht davon abhängig ist, wo die beteiligten componenten sind (im gegensatz zu shared variables/memory)
~

Distribution is decoupled execution in space [citation - Bonèr]{.mind}. As has been motivated, any space-decoupled concurrent execution is inherently parallel. In the same context it was stated that relatively local parallelism is called intra-node parallelism, while actually distributed parallelism is called inter-node.

---

Communication via message passing has one fundamental property: no memory is shared between the communicating components. Though we will see later, that this semantic can actually be violated due to implementational hazards used for passing messages, conceptionally it does not require that the components are within the same memory space. Thus, it does not matter weither they run on the same processor, different cores or even the same host machine [@Fel90]. In short, message passing allows for distribution. 

The Actor model intrinsically builds upon message passing to share state information between Actors. Additionally, Actors are well isolted from each other. Based on these properties, Agha recast the initial notion of Actors in the light of distributed computation [citation? die diss? oder dieses 43 year paper auch noch]{.mind}. 

~Todo
Microservices können auch message passing, aber auch synchrone. Die location transparency kommt entweder von der MOM, oder eben von einem lookup service für die REST endpoints.
~  


### Location Transparency (and Mobility)


...

Microservices allow for arbitrary communication channels, as long as those conform to the paradigm. Pipes have been stated a a viable example. However, as we've pointed out, such are limited to the memory boundries of a single OS [soll ich da was zitieren? hab ich eh schon 1000 erklärt]{.mind}. Channels operating on network level intrinsically distributed communication mechanisms, which facilitate message passing [@Bar97] and provide a uniform interface for remote as well as local communication [@Spe90].

...

---

Mobility:

~LitNote
* Laut jones Bonér folgt mobility aus location transparency
* [@Kan12] (über distributed erlang Actors)
    * Mobility is defined as the ability of processes moving from one node to another. It is classified into two types. Strong Mobility means supporting movement of both code and execution state, while weak mobility only allows movement of code
    * At the system level, mobility is important for load balancing, fault-tolerance and reconfiguration. 
    * [25] = [@Pan94] has shown that mobility is essential for achieving scalable performance.
* [@Fug98] "Understanding Code Mobility"
* [@Agh14] "Actors Programming for the Mobile Cloud"
* [@Car97] "Designing Distributed Applications with Mobile Code Paradigms"
* [@Kar09] beschreibt mobility bei actors
* [@Sal16] "The Evolution of Distributed Systems Towards Microservices Architecture"
    * Keywords: Distributed Systems; Microservices; Mobile Agents; Service Oriented Architecture
    * ad *Mobile Agent*: "An agent is composed of three parts which also take place in travelling: Data, State and Code."
* MS service discovery:
    * see [@Mon16a] for example solutions/implementations/technologies 
* MS: "Location of MS may not be statically known at design time" [@Mon16a]
* [@Agh99] "Actors: A unifying model for parallel and distributed computing"
    * "the encapsulation and thread of control withion an actor facilitates both the management of concurrency and location transparent distribution"
~

Mobility:

~LitNote
* [@Gui09] "Reasoning About a Service-oriented Programming Paradigm
    * Slave service mobility andMaster service mobility
~


### Distinction to Distributed Objects {#sec-distributed-objects}


~LitNote
* Lokation transparency ist super und alles, wenn es richtig gemacht wird. die Verteilten Objekte machen das auch, und führen zu massiven Probleme --> hier hab ich diesen einen Artikel "A Note on Distributed Computing" oder so. An dieser stelle sollte ich diskutieren wieso Actors und MS diese Probleme nicht haben, bzw was zu beachten ist um es zu vermeiden
* [@Siv99] "The specification of distributed objects: liveness and locality"
* [@Wal96] "A Note on Distributed Computing"
* chapter 2.8 in [@Bac03]
~

In object-oriented programming, the overall programs state is partitioned into disjoint sets, each chunk belonging to a distinct object. As Werner pointed out, from a logical point of view, the state is as such distributed [@Weg90]. However, distributed programming has different emphasis of concerns than OOP does. And yet, both architecture styles can be integrated such that objects support pyhsical distribution. The result is called *Distributed Objects* (DO). 

The concept that has been popularized in the 1990s [citation needed]{.mind}. Objects do not have to exists within the same program boundary, but can be distributed across multiple programs and therefore host machines. As such, DO's can be viewed from a process-oriented perspective. We refere to Barrio and Fuente [@Bar97] for a formal definition on modelling objects as processes.  

In terms of programming interface, for every DO a proxy object is created on the client side, which wrappes the method calls to the actual distributed object, which then does not necessarily has to be located within the same program boundry [quelle für den absatz, wiederholung von "program boundry"]{.mind}. This allows for location transparent method calls. Examples of such DOs are Java RMI or CORBA [quelle, richtig?]{.mind}. They seem to share many conceptual similarities that we are discussing here. On the one hand, the design goals of Microservices seem to aim towards the single-purpose, minimal and slim skeleton that distributed objects have compared to full-fletched monolithic applications. On the other hand, their distributed nature inherently leads toward the possibilities of transparent concurrent/parallel execution, like Actors or active objects do. 

However, the abstraction the distributed object concept provides was found to be be "leaky" due to conceptual problem [citation needed - note on distributed computing]{.mind}. The transparent method call they offer is hiding to much context do be able to handle the many faults that come with any distributed programming setup. A simple example: 

~LitNote
* [@Ber14]
    * "In a traditional RPC model (such as Java RMI, CORBA, or WCF) the programmer needs to explicitly bind the virtual reference to the service, usually via an external registry or location service."
~

~Todo
hier das beispiel mit dem 1000 methoden aufrufe für die simme von .getSize()
~

We already discussed the analogies of Actors and microservices to the notion of objects. Now, with these similarities and the fact that Actors (or active objects) and microservices each provide mechanisms for location transparent messaging too, we should discuss weither they qualify as distributed objects themselves. This would mean they face the same problems as DO too. 


#### Actors as Distributed Objects


As with Distributed Object, the Actor model has the potential to address distributed components transparently. Actors use the concept of addresses, which substitute for local interfaces, just like DO proxies. As such, they might allow for different interfaces however. The Erlang programming language famously introduced the style `address ! message` to send a message of arbitrary form to an Actor itentified by a known address [vll was zitieren]{.mind}. Of course, Erlang does not implement object-orientation, and thus accessing state and message passing are strictly separate constructs by design.

However, other Actor systems have adopted this style, e.g. as was done in Scala. There the type system opens up the opportunity to use a punctuation-free syntax to invoke methodson object which take only a single argument, offering an infix notation style[^fn-punctuation-free-call]. Despite an object-oriented context, this allows to use different syntactic constructs for referencing ordinary objects, and addressing Actors, if merely by convention. 

[^fn-punctuation-free-call]: The expression `address ! message`{language:scala} is therefore merely syntactic sugar for `address.!(message)`{language:scala}.

The truely fundamental difference now between addressing an Actor and a Distributed Object is within the dispatch semantic. Actors rely on asynchronous message passing as defined by the basic model primitives. Any asynchronous messaging is decoupled in time [cite Bonèr]{.mind}. It does not introduce the expectation of an immediate response as could be with a synchronous-styled dispatch, which is essentially what method calls with a return value abstract. Thus, message passing is more loosely coupled than request/reply methods.

Therefore, especially in object-oriented contexts where Actors are implemented as ordinary objects, special care has to be taken in order to avoid any chance to accidentially introduce such tighter coupled public methods. Additionally, Actor systems may intentionally provide higher-level constructs to abstract synchronous communication ontop of asynchronous messaging.

In there principles however, we deem that Actors avoid the problematic abstraction of Distributed Objects. 


#### Microservices as Distributed Objects


The method call on a DO proxy object makes it transparent for clients weither a locally available or remote server object is addressed. Within the Microservice paradigm, there is no such abstraction in general. Service-internal interaction within its modules use the standard paradigms of the technology used to implement the service, e.g. calling an object's method, or referencing a function. To issue any external request (despite expecting a reply or not) a respective communication interface has to be issued. Such is dedicated to the communication channel, e.g. a HTTP library or message queue API. Thus, any external interaction should be recognisable to the programmer in general. 

Of course, due to the freedom of the Microservice paradigm, it is possible for any service to utilize a technology that is again abstracting the difference between internal and external interactions transparently. It is in the responsibility of the programmer to select [???-adjektiv]{.mind} frameworks and issue appropriate design desicions. 

An additional argument is the granularity of service interfaces. While objects may provide very fine grained interfaces in general, e.g. to access each of its state variables separately, service tend to have more course grained interfaces. In a Microservices context it is more likely that messages between services do not issue very fine grained operations on the receiving service in general, but instead aggregate more course grained operations relative to the interface granularity. Thus, [???]{.mind}

Therefore, we deem it unlikely for Microservices to suffer from the leaking Distributed Object abstraction.


#### Active Objects as Distributed Objects


We have discussed now weither Actors or Microservices qualify as abstractions of the Distributed Object concept, and came to the conclusion that the risk of being misused as DO's is moderate for both. However, § [#sec-active-objects] introduced another variant of the Actor model that is worth discussing here, for it explicitely capitalises an object-oriented abstraction, just like DO's do: Active Objects.

Section [#sec-active-objects] gave an example of the concurrent semantic the API of Active Objects provide. The method call is separated from the message execution. We demonstrated the behaviour in case of method interfaces with and without return values. Building on the previous example, we define this program:

``` {language:scala}
val fs: List[Fnord] = ... // list of 100 references
var sum = 0
for (f <- fs) {
    sum += f.get()
}
print(sum)
```

The code snippet iterates over all elements and makes a blocking call to retrieve the value. This has two fundamental issues:

1. The programs will block sequentially 100 times, once for each element.
2. If some, or in the worst case all, of the elements are not within the same local boundries but transparently distributed, this will cause up to 100 separate remote procedure calls with as many opportunities of any fault a synchronous network call can result in.

The first issue is a result of bad coding practice. The second issue is based on the same leaky abstraction distributed objects suffer from. The `get()` method could be called without the programmer being aware that it actually offers a result value and therefore will block (though with this particular method name and usage it hopefully is unlikely). Additionally it is not clear weither the dispatched method will execute locally or remotely. The abstraction simply hides too much.

Both issues could be fixed by using the *future type* of message passing for Active Objects that has been introduced. This is done by changing the declaration of `get()` to return a `Future[Int]`{language:scala} instead. In functional languages, handling Futures can be done elegantly if they offer monadic behaviour that fits natural with functional programming styles, e.g. in Scala:

``` {language:scala}
1  Future.sequence(fs.map(_.get))
2    .map(_.sum) 
3    .onComplete {
4       case Success(res) => print(res)
5       case Failure(_)   => print("error")
6    }
```

This is an example where it is efficient to combine other abstractions of concurrent computation that integrate well with the Actor semantic. Line 1 transforms `fs:List[Fnord]`{language:scala} first into a `List[Future[Int]]`{language:scala} and then into a `Future[List[Int]]`{language:scala}. The Actor system's dispatcher can now wait until this `Future`{language:scala} completes without having to block the underlying thread. The call stack starting in line 2 is only applied upon completion, finalizing the intended result. 

However, this argumentation only holds under certain assumptions. As we already mentioned, different Actor Systems have different capabilities. In § [#sec-active-objects] we've stated that class `Fnord`{language:scala} extends some arbitrary `ActiveObject`{language:scala} class, but did not discuss the implications the used implementation would have on the correct behaviour. Assuming `Fnord`{language:scala} is changed to use the concrete Active Object abstraction Akka provides (called `TypedActor`{language:java} for it offers type safty for message passing), the desired non-blocking behaviour actually depends on the `Future`{language:java} used for wrapping the `Int`{language:java} result. Akka supports asynchronous dispatch only for the `scala.concurrent.Future`{language:java} trait. If class `Fnord`{language:java} uses its Java friendly `akka.dispatch.Futures`{language:java} interface, the intended behaviour is guaranteed. However, the standard `java.util.concurrent.Future`{language:java} interface would result in undesired blocking behaviour [@AkkaFuture].

We see, in general Active Objects have the potential to be used in the same problematic way Distributed Objects are. The methods interface defines the method dispatch semantics. If not used with utmost care, method calls can easily become simple remote procedure calls in a transparent way. This can cause bottlenecks, deadlocks, timeouts due to stacked network latencies, [...]{.mind} and having negative impacts on scalability, [...]{.mind} 

However, the one major benefit of Active as well as Distributed Objects compared to classic Actors and Microservices is their type safety. It is statically known weither a server will be able to understand a request, and respectivly a client may only dispatch messages which are guaranteed to be acceptable [kann ich da was zitieren?]{.mind}. 


### Components per Execution Environment


~LitNote
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * Beschreibt ch4.4 "Actors Per Execution Environment"
    * Classic Actors and Processes (Erlang) sind auf dem "level of abstraction" wie objekte in OO, oder abstract data types in FP
    * Active Objects und Communicating Event-Loops sind auf dem level of abstraction von "components" in OO, oder modulen in FP  
~


~ todo
Hier wird diskutiert wie viele Instanzen der jeweiligen Components existieren können, was wiederum ausdrückt wie viel Nebenläufigkeit innerhalb eines Hosts ausgedrückt werden kann. JVM Actors: im Bereich von maximal einigen 10k (im Gegensatz zu Millionen in Erlang - da sehr viel schlankere Konstrukte); Microservices: theoretisch so viele wie das OS an Prozessen verträgt (habe ich hier Literatur bezüglich begrenzender Faktoren?), praktisch aber nicht all zu viele im Fall von Echo, da deren Stack doch relativ unschlanke Service forciert. 
~


## Governance, Deployment and Autonomy

~ todo
vielleicht diese Section etwas weiter nach unten verschieben? Direkt vor die Process Calculi? Oder verweise ich auf Wissen hieraus bei der dyn. reconf.?
~


"*Actors come in systems*". Such is the famous quote by Carl Hewitt on his conceptions. These system provide many [???]{.red} for their actors. They deliver messages, ensure fairness, [and supervise...]{.red}. In a way, actor systems *govern* their actors in a homogenous way [KANN ICH DA WAS ZITIEREN?]{.red} ...

The microservice paradigm has no conception of an equal governance notion. This has some fundamental implications:

* message passing is not done in a uniform or bound way, such that channels have to be employed, their interfaces supported, and [delivery respectively monitored...]{.red}. Message distribution styles [müssen jeweils separat gemacht werden]{.red}
* fairness is a non-concern, thus scheduling delegated to the operating system(s)
* discovery requires custom silution

...

...orchestration and choreography (erst später beschrieben?)

...cloud management framework

...

This lack of governance also has some advantages:

* autonomy of services
* independent deployment

...

Not yet has been discussed the consequence on deployment:

* Actors müssen als ganzes System deployed werden
* MS können einzeln deployed werden, brauchen aber eventuell eine sequence

---

~Todo
(Partially) Centralized with Actor systems, decentralized with MS (aber was ist mit cloud management frameworks)
~

~Todo
Independent deployment
~

Autonomy:

~LitNote
* [@Bon17] 
    * "Isolation is a prerequisite for autonomy. Only when services are iso‐ lated can they be fully autonomous and make decisions independ‐ ently, act independently, and cooperate and coordinate with others to solve problems"
    * "Working with autonomous services opens up flexibility around ser‐ vice orchestration, workflow management, and collaborative behav‐ ior, as well as scalability, availability, and runtime management, at the cost of putting more thought into well-defined and composable APIs"
* MS: "components can be deployed separately" [@Mon16a]
~


## Scalability and Dynamic Reconfiguration


Their ability to scale is arguably one the most relevant reasons given in the literature to utilize actor- or microservice-based architectures [@Tas13;@Hal09;@Mon16a;@Dra17c;@Sal16;@Che17;@Sal16;@Dra17b]. Based on the definition given by Bondi [@Bon00], *scalability* is an attribute influencing the performance of networks, systems, or processes in general. From the cognition of industrial Erlang applications it has been suggested that scalability is more important than raw system performance [@Hal12]. It is influenced by many different aspects. From a concurrent point of view, any influence hindering parallelism has a negative impact, for example synchronization (cf. Java case study) and (temporal) deadlocks. The strong isolation and message passing principles of actors and microservices (isolated turn principle, avoidance of shared state) reduce corrdination and contention cost and therefore have a positive influence on their respective scalability capabilities by limiting safety and liveness issues [@Bon16].

There are many different forms and classification approaches. Two merit attention here. *Load scalability* referes to a steady performance if the load, that is the demand or work, increases. *Structural scalability* referes to the ability of the topology to change the amount of components, in this case concurrent task units [@Bon00].

Two notions of scaling a system are relevant. Scalability with respect to the system's size, or simply *scaling up*, referes to an increase of resource utilization, especially multiple cores on a single host. Avoiding blocking and synchronization, as well as asynchronous messaging are the influencing factors. Actors conceptually support this well, as long as they refrain from blocking inside their turns. Microservices do too, when backing asynchronous communication mechanism and refraining from RPC. In general, their internal concurrency capability introduces the risk of facilitating the potential hindrances on scaling up. Besides this, the scheduling efforts of actor systems and operating systems aim of an optimal utilization of available resources [PASSENDES ZITAT OS BÜCHERN?]{.red}. *Scaling out*, also *distance scalability* or *geographical scalability*, referes to the utilization of additional hardware resources (hosts). Distribution capability is the prerequisite. The uniform abstraction of concurrent and distributed execution of actor as well as the process nature of microservices combined with network IPCs provide the foundation to scale out [@Bon00;@Dra17c;@Dra17b;@AkkaMDR;@Agh99;@Tan07].

One approach to achieve scaling out is the concept of load balancing. It has already been discussed in detail regarding Echo's microservices in § [#sec-ms-load-balancing]. Akka actors build upon the same conceptual ideas using the router constructs. They allow to distribute work in various strategies, e.g. broadcast or round-robin, where the later is one example of a load distribution strategy. Server- and client-side load balancing is merely the destinction of such `Router`{language:scala} being utilized by the sending actor itself, or from an intermediate that is receiving the message initially from the sender and then applying the routing logic to decide the concrete receiving Actor. In the later case, a dedicated message routing task unit `R` has be introduced. When such use a load balancing routing logic, they are conceptually equal to the load balancing components `L` in microservice architectures.  
In one way or another, load balancing is a valueable concept for both Actors and Microservices, e.g. to avoid overflowing mailboxes and timely responses to requests. Some task units are naturally well suited to be equipped with load balancing capabilities [@Mon16a;@Car17], e.g. the Echo's API Gateway. 

A conceptual disadvantage is that by default load balancer do not know about the progress of potential recipients, such that work will be distributed only to receivers with corresponding capacity available. Such metric can be taken into account of course, e.g. with the `SmallestMailboxRoutingLogic`{language:scala} of Akka, which aggregates the mailbox capacities of all routees *before* a message will be actually dispatched, increasing overall processing duration [irgendwo hab ich da ne quelle]{.red}. 

Message queue channels are also a form of load balancing. As the receiving components actively pull messages from the queue when they have computation capacity, e.g. `W` &larr; `Q`, they thus distribute load among themselves based on their demand [@Dra17c]. 

*Dynamic reconfiguration* relates to a change of system topology at runtime, such that task units may be added, removed or relocated divergent from the static initialization configuration [@Agh85b]. Actor support this inherently through the primitive allowing Actors to spawn new Actors. It was demonstrated with the dynamically created response handlers `H` spawned by Searchers. The loose coupling of Microservices too provide support for changing topologies in principle, e.g. by utilizing service registries and asynchronouse messages through intermediate message queues. Reconfiguration greatly effects scalability, for it is the basis allowing the optimal utilization of hardware resources [HIER HAB ICH IRGENDWO EINE PASSENDE REF - GANZ SICHER!]{.red}.

A general prerequisite is localtion transparency. Both Actors as well as Microservices have sophisticated solutions for it. Two additional properties, *mobility* and *elasticity*, become possible as a result. Mobility referes to the relocation of components between nodes [@Agh99;@Kan12;@Tan07]. Elasticity is a form of scalability summarizing the ability of a system to scale the amount of components dynamically depending on the current demand, thus improving its load scalability. Due to their component properties, actors and microservices can be scaled in a non-uniform way, such that individual component types can be instantiated many times without having to duplicate the residual as well [@Dra17b;@Dra17c].

The requirements in chapter [#ch-scenario] explicitely state that neither mobility nor elasticity are concerns for Echo. However, the general approach is conceptually identical, therefore we present a short outline. Stateless task units can be easily created and terminated on demand (elasticity), which also doubles as mobility, for they do not have state that requires relocation. Strong mobility that requires the migration of state is not provided by Akka, but could be in general as does for example Orleans [@Ber14]. Thus, the stateful Stores are a concern. In general, when such units are (re-)created, it is not safe to assume that their persistent state (database, reverse index) is up to date, and therefore has to be updated with regard to all outstanding modifications to it. *Event sourcing* is a convenient concept which would persist all modifying commands to Stores in a so-called *event logs*, such that a new or reactivated Store can request a history of modifications prior to its existance. Message brokers have the potential to double as event logs. The Akka's *Persistence* module is convenient to
introduce persistence of routed messages into the broker units, and Kafka offers optional persistence support for messages. In both cases, Stores would have to persist a counter or reference to their last received event separately in order to request the required partial history.

In general, we deem the concerns related to dynamic reconfiguration more easily met with Actors, for it is a core concept through one of the basic model primitives. Microservices themselves have no general notion of other services beyond interaction, thus it requires an additional layer to manage changeing topologies. Such tools are subsumed in the category of *could management frameworks*. This fundamental difference in the inherent notion of static versus dynamic changes in topology are a major concern when it comes to integrating Actors and Microservice task units, which will be briefly discussed in &#167; [#sec-actor-ms-integration].


## Extensibility and Technology Diversity {#sec-technological-heterogeneity}


~ todo
Das hier muss ich ganz generell auf etwas Literatur fundieren. Habe ich hier etwas das zusammen passt?
~

A result of the dynamic reconfiguration property is that Actor or Microservice Architectures are also open for extension. This characteristic of extensibility is especially often discussed for Microservices [REF1,REF2,REF3]{.red}. In contrast to dynamic reconfiguration, where instances of existing task units are added or removed, we use *extensibility* in order to refere to the introduction of either new versions of existing task units (update) or new units completely (addition). For updates of previous version, special care has to be taken into account, which will be the concern of § [#sec-design-by-contract]. 

There are two different kinds of extensibility [@Agh85a;@Bac03]:

* static, such that the architecture's code is adapted, recompiled and then (at least partially) redeployed
* dynamic, whereat a new component is added to the architecture at runtime

Independent deployment capability of each single service engine allows to simply add new components at runtime. This does not impact existing services, as these do not yet have a notion of the new component. New services can simply consume existing services. Gradual updating old services then allows to integrate any new component deeper into the architecture, such that it will also be consumed [@Mon16a].

Actors are faced with more challenges. An Actor requires an Actor System to exist within. Erlang and its runtime system were tailored to support Actors, thus the *BEAM* virtual machine supports code loading and replacement for live upgrades [@Vin07]. The JVM does not support similar features, and therefore Akka requires the restart of the system to introduce a new Actor, as all Actors are defined in the same program structure and subsequently compiled to a monolithic executable, limiting Actors to static extensibility. However, in a clustered Akka setup it is not required to introduce a new component into all Actor System nodes at once. Therefore, the cluster may retain its uptime, while its nodes get individual upgraded and redeployed.    

Another interresting concern is the technology limitations regarding the conception of new components. Any Actor is bound to its Actor System. Such may provide interface bindings for multiple programming languages, e.g. as Akka does for Java and Scala. Though the Java binding can be used from other JVM languages as well, as is demonstrated by [@Sub11] for Groovy and JRuby, it does not overcome the JVM as the target platform. Interoperability with Akka.NET would broaden the possibilites, but such has to our knowledge never been available yet.

The strong memory boundries and open communication interfaces of Microservice provide a whole different level flexibility. Any service may be conceived using any programming language and technology desired, as long as such are able to interact with the communication channels.

Echo facilitates Java and the Spring Framework for all task units, but each service could also have been written using distinct technology stacks. Even now, existing services could be replaces by new version using new technologies.   

~ todo
hier noch etwas mehr blabla
~

---

Extensibility:

~LitNote
* [@Mon16a]: "New versions of components can be gradually intro- duced in a system, by deploying them side to side with previous versions. This advantage can be incorporated in Continuous Integration"
* Actors, siehe: [@Agh85b]
* gradual/separate replacement of MS
* substitution and subtyping für Actors
* MS: "new versions can be gradually introduced into a system" [@Mon16a]
* [@Lis88] "Promises: linguistic support for efficient asynchronous procedure calls in distributed systems"
    * describe the concept of Promise for "heterogeneous computing in which programs written in different programming languages, and running under different operating systems on different hardware, can use one another as components over a network"
~

Technology Heterogeneity:

~LitNote
* [@New15] Newmann calls it "Technology Heterogeneity"
~


## Fault Tolerance and Resilience

~ todo
__WAS IST DER UNTERSCHIED ZWISCHEN FAULT TOLERANCE UND RESILIENCE?!__
~

Fault tolerance:

~LitNote
* "failure isolation"
* [@Myt17] "Handling partial failures in distributed reactive programming"
* [@Tan07] "Distributed Systems: Principles and Paradigms, 2/E"
    * 8.1 INTRODUCTION TO FAULT TOLERANCE
    * 8.2 PROCESS RESILIENCE
~

...

The message passing communication style facilitated by both Actors and Microservices brings common 

...

Resilience:

~LitNote
* "ability to heal from failure" - break free from strong coupling of synchron comm.; circuit breakers
* Location transparency, elasticity = "move around in isolation"
* independent failure of components
~

Availability:

~LitNote
* Actors, siehe: [@Agh85b]
~


## Separation of Concerns and Single Responsibility


~ todo
Hier soll ich ganz allgemein zusammenfassen, dass verschieden concerns behandelt werden, und bewerten wie gut __getrennt__ dies voneinander geschieht!
~

*Separation of Concerns* (SoC) is ...


The actor model as well as the microservice paradigm facilitate isolated and decoupled components.  

...

Hürsch and Lopes [@Hur95] define two levels regarding SoC: the *conceptual level* is concerned with the identification and differentiation of concerns, while the *implementational level* ensures their isolation.


~ lit
* routing concern is outsourced to router actors, MQ, broker
* actors geben viele concerns an das actor system ab (scheduling, discovery), MS müssen sich im discovery selber kümmer (auch in eigenen single-responsible services) und scheduling an das OS
* linguistically conceived Microservices can emphasise a good SoC between behavior and deployment, as the Jolie syntax structure demonstrates.
~


---

Separation of Concerns:

~LitNote
* [@Weg90] "Concepts and Paradigms of Object-Oriented Programming"
    * "Splitting a large task into components is a time-honored method of managing complexity, variously referred to as "divide and conquer" and "separation of concerns"."
* SoP between behavior and deployment part of Jolie programs, siehe [@Mon14;@Gui17]
* Supervision and fault isolation --> good SoC [@Roe15], for "normal" messaging and supervision orthogonal and can evolve separately
    * failed children can be re-created from its `Props`{language:scala}, such that supervisor don't need special knowledge about their instantiation (argument, etc)
* IoC generally facilitates SoC 
    * actor systems ähneln IoC container
    * Spring MS sind intern via IoC, dh intern gutes SoC 
* [@Hur95] gibt als concerns an (all diese sind hier - unter anderem namen auch besprochen!):
    * synchronization &rarr; avoided in Actors; maybe required internally in MS, Echo uses STM
    * location control 
    * real-time constraints &rarr; easy RPC with MS by using adequat comm. channel, more challenging with Actors, though ask-pattern, e.g. new components like response handler can be required, which then separate the concern nicely
    * failure recovery &rarr; there are ways, but how compare them?
* Good SoC in Jolie of behavior and deployment [@Gui17 ]
~

The strict encapsulation of state offers the opportunity to introduce multiple persistance strategies, without having an impact on the architectural layout. There is a more general concept to describe this form of modularization, called *Separation of Concerns* (SoC).

Having state strictly encapsulated, up to  

...

... both Actors and Microservices provide a good basis to facilitate a clear separation of concerns due to their strict notions of high cohesion and loose coupling. However, as with many abstractions, SoC is merely [a best practice / a goal ... and cannot be enforced or demanded in any way]{.red}. Services can be enassigned as many concerns as wished, and Actors can also receive any kind of message, making them potential targets to all sorts of requests and jobs [FURCHTBAR FORMULIERT, aber richtige botschaft]{.red} 

---

Though both faciliate a good separation of concern, we've found that the scope of (single) responsibility is divergent. More precisely, the notion of scope variates. Actor systems free there constructs of minding many concerns. Examples are the discovery mechanism resulting from transparent addresses, or the supervision concept. The rather loosel principles of Microservices on the other hand burden them with minding many cross cutting concerns. Dedicated services solely concerned with providing discovery, and clients ensuring to facilitate these mechanism are required. Also, neither have they an intrinsic behavior nor an appropriate communication protocol of supervision in place. If such is desired, every service has to explicitely concern itself with supporting it with regard to its respective technology stack.


...

Single Responsibility:

~LitNote
* Unix philosophy
* [@Bon16]
* [@Bon17] "This idea was later brought into the Object-Oriented Programming community by Robert C. Martin and named the Single Responsibil‐ ity Principle2 (SRP), which states that a class or component should “have only one reason to change"
* "functional separation" [@Sal16]
* single responsibility ist ein gutes beispiel, wieso man exlusive datenbanken gut gebrauchen kann
* [@All13] actor "single responsibility principle"
~

Thus, in general we've found Actors to provide an easier abstraction to facilitate single responsibility, for the model primitive allowing to spawn new Actors on demand encourages the outsourcing of responsibility into dedicated Actors. A good example are the dynamically created response handler Actors for each search request that wait on an asynchronous response substituting for a `Searcher`.

Microservices on the other hand offer less incentive to encapsulate each distinct responsibility inside a dedicated task unit. Each conceived service is by design a dedicated program, thus entails all resulting challenges ranging from the obligation of maintaining an its own separate codebase up to the additional deployment considerations.


## Eventual Consistency and Availability


Due to the asynchronity and distribution of Actors and Microservices, both approaches are bound to a weak notion of data consistency which is refered to as *eventual consistency*, as has been pointed out frequently in the literature [@Agh14;@All13;@Dra17c;@Bon16;@Fow14;@Bon17]. It describes an informal (!) guarantee that in the absence of mutating data operations, all access to a dataset will produce the same result at some point in time eventually. Concequently, until this point in time, the data state across tasks is in flux and may therefore produce varying results. 

Echo suffers from this regarding its data store units. Indizes inevitably hold states which are behind of the Catalogs, as these receive feed data from Parsers and only distribute it to the Indizes after they've update their state (broadcast). This is of course only true for the original recipient of the Parser data, as any update to one Catalog subsequently also has to be broadcast to the residual instances. Thus, eventual consistency reduces the guarantee for consistent data to a guarantee that all data updates will be propagated to all data replicas [@Tan07]. 

In contrast, requiring consistency would be extremly difficult. Consistency essentially constraints the order of read and write operations on data [@Mah11], in this case from a global point of view. Software transactional memory would be a prominent mechanism to achieve this. However, as we've pointed out, Akka did drop its transaction support for the performance impact in a local context alone, as it never did achieve to extend transactions to remote Actors. Microservices are faced with even more challenges, as there is no inherent base system available to provide such mechanism, and the complience to such therefore would have to be integrated on an individual per service basis.

The constraints required for maintaining strong consistency relate to safety [@Mah11]. A weakening of these constraints thus reduce safety. In return, eventual consistency within a system has a positive effect on a specific liveness property, that is *availability*. Basically it relates to a systems responsiveness when requesting functionality. A consistency mechanism potentially restrains this responsiveness, as it would have to await the accomplishment of the consistent state, that is all data has been successfully written across all involved tasks. Informally, availability demands that all read and write operations complete. The sooner they do, the more available the system is.


## Testability


~ todo
Beide Konzepte behandeln von einander gut entkoppelte Komponenten. Allerdings lassen sie sich dennoch sehr unterschiedlich "gut" testen. Ein MS wird einfach selbstständig gestarte, und sein public interface zum Testen verwendet. Schwierig wird es, sobald ein MS weitere Services in anspruch nimmt, bzw ganz allgemeint die Existenz von anderen Komponenten annimmt (MQ, Discovery, etc). 
Actors sind hier generell schwieriger, weil sie immer in einem Actor System "leben" müssen. Akka bietet hierfür Ansätze und Lösungen, diese sind aber verglichen mit anderen "normalen" Test Frameworks schon kompliziert und eher konfus. 
~

~lit
* MS können ein und die selbe Funktion über mehrere arten von interfaces anbieten (consume from AMQP, as well as REST), were REST makes testing easy, and AMQP better for production.
~

[TODO]{.red}


## Actor Model and Process Calculi


Among the theories of formulating concurrent computation is found a family called *process calculi* or *process algebra*. Such define formal models composed of so-called *processes* which are communicating within the laws and conditions layed out by their theory. Baeten [@Bae05] defines *process* as any kind of *behavior* of a *discrete event system*, such that it is observable through discrete actions. These actions can include interaction with other discrete event systems. Those then have to react to these interactions, and therefore he terms all interacting systems as *reactive systems*, which is the base for parallel and distributed computing. Thus, an approach towards concurrency theory is the path of a process algebra.

Some of these calculi gained considerable prominence, for example Milner's CCS (__C__alculus of __C__ommunicating __S__ystems) [@Mil80] for having been the initial work in this domain, while Hoare's CSP (__C__ommunicating __S__equential __P__rocesses) [@Hoa78] were the first to introduce message passing instead of global variables for process communication. For our considerations, the &pi;-calculus [@Mil92], also by Milner, merits special attention, for it has a notion of process networks, including mobility and dynamic reconfiguration [@Bae05;@Mon97]. 

Much work has been done on this field, as they allow to express theoretical basis for arbitrary domains and requirements. In fact, some more practical approaches to expressing interacting processes, which were also found to be well suited for expressing Microservices, have their theoretic foundation in a process calculus. The Jolie language for example is based on a calculus dedicated to service-orientated computing called *SOCK* [@Gui06], which is in turn inspired by CCS and the &pi;-calculus. This is especially interresting, for the Actor model and process calculi share a long history. Hewitt and Milner published their initial works on the Actor model and CCS in the same year, respectivly 1973. Since then, these two approaches have mutually influenced and inspired the scientific development of each other. A fitting example is ASP (__A__synchronous __S__equential __P__rocesses) brearing close resemblance to Active Objects, yet with a more coarse granularity [@Kos16] (cf. AO/DO vs. MS).  

As a result, scholars have long tried to formulate a theoretical link between Actors and various calculi, with mixed and limited success. To our knowledge, to most promising approaches in the literature so far have merely succeeded at describing interoperability between Actor and calculi that have been known to show string similarity. For example, Montanari and Talcott [@Mon97] demonstrate the coorporation of Actors and agents of the π-calculus. 

As Agha et al. [@Agh97] discuss in an extensive work, a true equivalence theory among a formal *actor calculus* and some process calculus requires the formulation of a simulation relation among the primitives. This has been done among different process calculi, but is yet unfound regarding Actors. They state as the foundational challenges:

> "Three points of contrast between the basic actor model and process calculi are: the choice of communication model, the choice of communicable values, and the issue of fairness."

Note that all these issues have been discussed as concerns in varying degrees throughout this thesis. For example, it has been pointed out that Actor assume fairness, while it is a non-concern for Microservices which simply delegate it to the OS scheduler. 

Eventually, Agha et al. argue that instead of trying to find an analogy between an actor- and a &pi;-calculus it is expedient to engage in the definition of high-level semantics for programming languages, and reason about program equivalence to Actors and &pi;-programs. 

<!--

...

A most basic argument towards the linkage is the definition of a process in the calculi context given above. It explicitly referes to a notion of behavior, respectively discrete actions. 

... Actor have the intrinsic own notion of behavior together with the models Isolated Turn Principle suffices

...For Microservices we explicitely distinquished between the *engine* and the *behavior*, where the later referes to the "service" an engine offers. Each offered is from a global viewpoint a discrete operation whenever consumed [komisch formuliert, und ka was ich dazu zitieren soll]{.mind}.

...

It is important to realize that there is only one theoretical Actor model with many different implementations (Actor Systems) varying in terms of concrete features and capabilities, through all of which are still founding on one common theoretical model. On the other hand however, there is not one process calculus as a single foundational theory, but a large variaty of calculi instead. All are distinct in some way or another in terms of process traits and communication semantic. Thus, only a specific calculus can be compared to the Actor model at a time in general. Such has been done throughout the literature many times [hier gleich einen haufen zitate?]{.important}. 

... For example...We've found that especially ASP (__A__synchronous __S__equential __P__rocesses) have been discussed in the light of Active Objects [@Kos16].

... Especially the ASP (__A__synchronous __S__equential __P__rocesses) have many similarities with Active Objects as well as another special variant of Actors of the so-called *Communicating Event-Loop* model [@Kos16;@Car04, Car04 könnte ich mir sonst als REF generll ersparen!].

...

...Some calculi have been known to show such similarity to Actors that interoperability has been described in the literature. For example, Montanari and Talcott [@Mon97] demonstrate the coorporation of Actors and agents of the &pi;-calculus.

...

In a classification of concurrency model, Swalens et al. summarize all abstractions avoiding shared memory and using structured message-passing instead as *communicating threads* [@Swa14]. [ja und jetzt...?]{.important}

...

...We refere to [XYZ]{.important} for a detailed introduction on process calculi in general.

...

~LitNote
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi>
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
* Wenn ich es im MS kapitel schaffe mir was zu Process Calculi zu überlegen, gibt es genügend 
* [@Kos16] vergleich Asynchronous Sequential Processes (ASP) mit Active Objects, nur mit gröberer Granularität
* [@Kos16] beschreibt das die sog. "Communicating Event-Loop Actor Model" ähnlichkeiten zu Asynchronous Sequential Processes (ASP) hat
* [@Car04] "Asynchronous and Deterministic Objects"
    * describes implementing ASP as Active Objects
    * "Relying on the active object concept, the ASP model is rather closed to, and was somehow inspired by, the notion of actors [2, 3]."
* [@Agh97] "A foundation for actor computation"
    * beschreibt ebenfalls den zusammenhang von Actors und Process Algebras (pi-calc., ect.), auch in einem historischen context.
* Punt: "Type Specications with Processes" <http://www.complang.tuwien.ac.at/franz/papers/Punt95a>
    * Hier beschreibt er wie er Process Types (was Typen von Processen eines Process Calculus sind) verwendet um das Actor model abzubilden. Dürfte sich sehr eignen!
* Punt. forschte daran wie man mit Prozess Typen (und somit in Process Calculi?) modellieren kann, das zu gewissen Zeiten nur gewissen Nachrichten akzeptiert werden. Das "become" Primitive von Actors kann ebenfalls dazu verwendet werden, um die Menge der Messages die ein Actor gerade verarbeiten kann zu verändern (also die Typen für die eben ein Verhalten definiert ist). Dh das ist im Prinzip das selbe
    * beste quelle? Punt: "State information in statically checked interfaces"    
    * Punt: "Types that reflect changes of object usability"                                             
~

-->


## Design by Contract {#sec-design-by-contract}


~LitNote
* [@Siv99] "The specification of distributed objects: liveness and locality"
    * "The design-by-contract philosophy of software design partitions responsibility for correctness between the caller of a method and the callee. It is the obligation of the caller to establish the proconditions before the method is invoked and it is the obligation of the callee, given these preconditions, to ensure the postconditions when the method terminates"
    * ad pre/postconditions: "Certain subtleties, however, arise tin teir use in dtstributed systems. For example, sunce there may be many concurrent threads of execution, the caller of a method cannot unilaterally guarantee that the required preconditions hold when the method begins executing. Thus phenomenon, termed the precondition paradox, has been neglected by many specification methodologies."
~

So far, concerns both Actors and Microservices in one way or another provide profound practical support for have been covered. From here on, we briefly endeavor into subjects both concepts offer rather basic capabilities at best as of yet, although there is theoretical potential for sophisticated solutions. Two such concerns that will merit attention here are static contract between task units in general, and behavioral types in particular.

Capabilities and notions regarding concerns like isolation, decoupling, location transparency, mobility and independent deployment in the respective contexts of Actors and Microservices have been given. All of these facilitate dynamic change in system topology, that is *dynamic reconfiguration* [@Agh90;@Dra17a]. One the one hand, new components can simply be added and announced via respective contextual mechanisms. On the other hand, existing components can be replaced, that is *substituted*, by others (subtypes). Fowler and Lewis even give independent replacement and upgradeability as key properties of Microservices [@Fow14]. However, any evoltion within such systems must not break the interface compatibility between components, or otherwise the system will inevitably break. This raises the question for interface compatibility, and particularly an automated checking of it.

An interface can be generally seens as a contract between a caller (client) and a callee (server) which regulates their interaction regardless of their implementation [@Sin09]. Besides respecting data type restrictions, the caller must comply to the *preconditions* of the callee when issuing its services, and in terms the called-upon guarantees to fulfill its *postconditions* when returning a result. This prinicple is usually refered to as *Design by Contract*. It is a desired concept, for it increases the possibilities of components to protect themselves, generally refered to as *defensive programming*. A pioneer and prominent example is the *Eiffel* programming language, which was conceived to aim for a correctness-by-construction notion of objects, and thus built upon the concept of design-by-contract to achieve it [@Mey97;@Maz16].

Any new component version or subtype is therefore not completely free regarding any changes. It must meet the *Liskov Substitution Principle* [@Hut16, ODER ORIG SRC?] stating that `S` is a subtype of `T` if an incarnation of `T` can be safely replace by any incarnation of `S`, i.e. `S` respects the contract promised by `T`. Thus a component, that is an Actor or Microservice, can be substituted by another if the new component abides the contract of the old, such that the system retains its behavior [@Hut16]. 


### Contract Verification


Component substitution in Actor systems can take the most basic form of behavior replacement. This primitive does not affect an Actor's address, therefore the instance defined by the new behavior transparently replaces the old. As a result, a new Actor might receive the same kinds of messages as did its predecessor, but fail to provide an appropriate reaction to such through the new behavior. Thus, reasoning about Actor systems is hard in general, due to the intrinsic property of Actors to interprete any message at runtime through its behavior, i.e. acceptance and rejection, as well as the resulting effects are dynamic [sollte ich was zitieren - stimmt das überhaupt so wie ich das hier behaupte?!]{.mind}. 

Microservices too are free to implement dynamic changes if they choose to. Replacing the engine of any service component however still requires that the service behavior must comply to the substitution principle. When it comes to verifing this, the freedom of the  paradigm allowing heterogenous technologies among services becomes a hindrance. Different technologies (programming languages and framework) and communication mechanisms (e.g. REST or AMQP) have different means of support for expressing contracts. There is no guarantee that any kind of compatibility checking tool is even available, yet compatible with a verification toolchain [@Dra17a]. 

An attempt towards a solution can be the utilization of a neutral tool with regard to language and technologies. For example, *Apache Thrift* [@Sle07] provides an independent format to formulize data types and interface specifications, and then generate static code in various supported languages to be used for implementing communication ports. Such can subsequently serve for applying static type checking regarding well-defined interfaces, however without incorporating channel protocols [@Dra17a].

Of course, this is not possible for dynamically typed languages. For MSAs are often implemented with a mixture of static and dynamic programming languages, the common denominator fallback is often basic informal documentaion in natural language [@Dra17a]. A solution would be to revert to general neutral specification formats.  In SOA, web services publish(ed) their interface description in a standardized format and discoverable way. Most prominent among these is WSDL (__W__eb __S__ervices __D__escription __L__anguage) [@Anc16].

*Invariants* are another concern. In contrast to pre- and postconditions, these must always hold within a component, that is in each of its computation steps [@Mey97]. However, in the intrinsic context of distributed systems, concepts for verification so far build on post facto analysis approaches, e.g. via randomization testing or error log analysis. The later turned out to be promising for asserting liveness of services. For safety properties, Panda et al. [@Pan17] for example proposed a Microservice-specific invariance model called `ucheck` that is capable of detecting violations at runtime, but at the cost of limiting the communication channels within the service architecture to request/reply-styled remote procedure calls.

Dedicated programming languages for service-oriented programming like Jolie open up the possibility to check contracts through stricter restriction regarding the definition format of service interfaces. Thus static type checking, at least among the components written in Jolie, is applicable without breaking the requirement of open and well-defined interfaces [@Min17]. If languages are based on a process calculus, being already formal definitions, a foundation for even stronger reasoning is present, which minds the sequence of component activation. 


### Behavioral Types


Guidi and Montesi [@Gui09] define three kinds of interfaces: functional (distinguished by a name, input and output types), work-flow (requireing a valid sequence of interactions) and semantic (offering semantic information about functionality through some onthology). The previous section discussed contracts of the functional kinds, which are rather simple for the only information used to check them is weither the input and output types are compatible. This can be done in general with respect to the substitution principle [citation?]{.mind}.

Actor and Microservice systems require its components to be interoperable in order to ensure reliability and correctness. The mere compatibility of formally defined interfaces in not incorporating sufficient information in general to be able to ensure this for communication-centered concurrent and distributed system components, as these do not incorporate interaction protocol information [@Sin09]. Message exchange has an influence on internal task unit states, thus a precise message order can be required [@Anc16;@Dra17a]. This is not considered in functional types. However, the mentioned work-flow kind incorporates this into a notion of typization. Such are generally subsumized as *behavioral types* [@Anc16] and of high interrest regarding concurrent execution, for they have the potential to prevent safety and liveness issues [@Hut16].

Within the context of Actors, scientific exploration of static constraints on Actor behaviors replacements regarding method availability (message acceptability) has already been done [@Hut16]. The type-bounded behaviors of Akka Typed are an experimental implementation regarding this concern. It demonstrates how a certain degree of static type safety can be introduced through the Actor addresses. However, it takes a rather rigid approach, by simply defining a most basic supertype of all messages through a type parameter, and forbidding the behavior to change such that messages of this type could not be understood anymore.

Active Objects primarily address the problem of contracts for Actors. Their object abstraction provides static inferfaces, such that a compiler can ensure message compatibility [@Ber14]. The changing of behavior is reflected as a change of the objects internal state. However, Actors may in general alter their behavior such that they do not always accept the same kinds of messages, i.e. a only a certain sequence of messages is then valid. Intuitively this is somewhat contrary to the static notion of objects the AO abstraction facilitates, for it would mean that their offered methods are not a static set, but may change dynamically depending on their internal state. In theory, it is however possible to alter the type annotation, that is the proxy object, on the client side of an Active Object dynamically, such that method restrictions may occur while method compatibility can still be ensured through a compiler [@Pun01b]. In object-orientation, this characteristic in usually refered to as *nonuniform method availability* [@Hut16].  

There is a generalization of describing valid method invocation order for objects. Two kinds of notions have been established in the literature. One focusing on introducing very formally defined theoretical models, e.g. based on process calculi, into typization, as do for example *process types* [@Pun95a;@Hut16], and another based on less formally defined ideas summarized as *typestate*. The nonuniform method availability that has been just described is a special variant of typestate refered to as *session types* [@Anc16]. Modern AO variants as Orleans however do not endeavor into any such capabilities.

<!-- TODO delete?
... 


Due to the nature of Actors and Microservices, these concepts intrinsically allow to define nonuniform interfaces.

...




~LitNote
* distributed objects as processes, define a behaviour 
    * see [@Bar97]
~

...

However, all these approaches towards component contracts still take rather basic information into account. 

... only pre- and postconditions, and to a certain degree invariants.
-->

Regarding Microservices, WSDL was mentioned as an interface description format. However, it merely expresses static information, and does not incorporate work-flow details [@Mon16b]. More sophisticated standards provide the expression towards behavior contracts, e.g. WS-BPEL (__W__eb __S__ervice - __B__usiness __P__rocess __E__xecution __L__anguage) [@Anc16]. They build upon the ideas of formal concepts like process calculi, especially CCS and the &pi;-calculus [@Dra17a]. As with WSDL, such have been utilized in the SOA context, but seem to be yet rather neglected in the Microservice domain. We presume this is due to the same reasons regarding too much complexity that is hindering easy service development. Once again, we thus argue for programming language based solutions to overcome this. In fact, a primary design goal of Jolie was to build upon and extend WSDL interface descriptions and WS-BPEL orchestration, while fixing some of their formal semantics ambiguities [@Anc16;@Mon14].

An alternative approach towards verifying composition is to migrate from the single component focus regarding behavior (orchestration) to a global viewpoint. High-level definitions called *choreographies* are used to coordinate otherwise autonomous components [@Anc16]. The choreography itself is a syntactic specification of the communication among parties within a system. Based on these specifications, component implementations are then generated such that they are correct-by-construction. This facilitates a paradigm called *Choreographic Programming*. It is still in its early stages, but we've found promising work towards an integration into the Microservice context [@Dra17a;@Mon13].

In general, behavioral type theoretical concepts do not seem to be widely applied in practice yet. Dragoni et al. [@Dra17a] argue that this is because they restrain the applicability of services, which is undesired by programmers. For a more detailed overview of behavioral contracts we refere the interrested reader to Hüttel et al. [@Hut16] and Ancona et al. [@Anc16].
