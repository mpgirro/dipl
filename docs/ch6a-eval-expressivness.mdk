
Evaluation {#ch-evaluation}
==========

<!-- of Actors and Microservices -->


~ Epigraph { caption: "Jeannette M. Wing" }
Thinking like a computer scientist means more than being able to program a computer. It requires thinking at multiple levels of abstraction.
~


In Chapters [#ch-actor-model] and [#ch-microservice-paradigm] we introduced the concepts of actors and microservices. Chapter [#sec-scenario] described the strategies of each model to implement concurrent systems like the Echo scenario. We discussed each model separately and focused on their individual concepts. In this chapter we compare and evaluate both models relative to each other. As we've demonstrated, both actors and microservices qualify for expressing concurrent computation. Their mechanisms and abstractions also support parallel computation on multicore processor as well as distributed execution on multiple hosts. Several authors [@Kan12;@Kar09;@Agh99] suggest that programing models regarding parallel and distributed contexts should be evaluated based on two objectives: *expressiveness* for programmers and *efficiency* of execution. 

Section [#sec-eval-expressiveness] compares the key properties that are the foundation of the concurrent execution of both models and the resulting capabilitues. The model capabilities allow us to evaluate the expressiveness of each programming model. Section [#sec-eval-efficiency] provides a benchmark for the actor- and microservice-based implementations of the Echo scenario. These benchmarks evaluate the efficiency of the programming models.


<!--
This chapter will compare and evaluate the capabilities resulting from their conceptualities


Subsequent Chapters [#ch-actor-impl] and [#ch-microservice-impl] demonstrated that different solution strategies have to be applied as a result of inherent differences. This chapter will compare and evaluate the conceptualities applied by actors and microservices to achieve concurrent computation within their respective architectures. 

---

As we've illustrated, both the actor and microservice model qualify for expressing concurrent computation. Furthermore, both models support parallel execution on multicore processor as well as distributed computation on multiple hosts. 

Chapters [#ch-actor-model] and [#ch-microservice-paradigm] introduced actors and microservices separately and focused on their individual concepts. Subsequent Chapters [#ch-actor-impl] and [#ch-microservice-impl] demonstrated their specific solution strategies we applied to implement the Echo scenario system. Now we want to evaluate both models. 

Kang & Cao [@Kan12] and Karmani *et al.*\ [@Kar09] suggest that programing models regarding parallel and distributed contexts should be evaluated based on two objectives: *expressiveness* for programmers and *efficiency* of execution. Since we concern two concurrent programming models, we will furthermore compare the key properties both models are sharing as well as the resulting capabilities.

[Agha & Kim extend the concerns on universal programming models by *portability* and *performance predictability* [@Agh99]. We will merit all four concerns attention in this concluding discussion.]{.red}
-->


## Capabilities and Expressiveness {#sec-eval-expressiveness}


<!--
~ red
DELETE: Chapters [#ch-actor-model] and [#ch-microservice-paradigm] introduced actors and microservices separately and focused on their individual concepts. Subsequent Chapters [#ch-actor-impl] and [#ch-microservice-impl] demonstrated the solution strategies of each model and their expression through programming interfaces. This section will focus on comparing the capabilities that result from model properties and expressed [techniques/capabilities/???]{.red}. Furthermore, we will evaluate the expressiveness by analysing metrics of the software artifacts resulting from expressing computation through the actor and microservice programming model.  
~

This section conducts a conceptual evaluation. We compare the capabilities and expressiveness of the actor and microservice programming models.

...
-->

In this section we compare and evaluate the key properties of the actor and microservice programming models, as well as the capabilities we can express with these models. 


~ todo
Der Teil unten braucht dringend irgendeine Literatur Grundlage. Sonst bin ich auf zu dünnem Eis.
~

Expressiveness in the literature is often discussed in the light of formal methods to reduce syntax while preserving the expressed semantics. [CITATION NEEDED!!]{.red}

We employ a slightly different view of expressivness. Since we regard two programming models, we will assess the capabilities that can be expressed using the actor and microservice programming models.




### Encapsulation and Isolation


Actor and microservice semantics rely on the strict separation of component states. We must ensure that state is conceptually well encapsulated within a component, and practically isolated from the outside. Encapsulation is a concept we know from object-oriented programming. As Snyder points out, OOP usually offers mechanisms to restrict the access to an object's state. A client gets access to an object's state by issuing requests for the *services* an object offers [@Sny93]. These "services" -- not to be confused with the concept of a *microservice* -- are what Meyer calls "well-defined interfaces" in the form of *routines*. Meyer considers these services to be a necessity for encapsulation [@Mey97]. 

Both actors and microservices offer well-defined interfaces in their own way. For an actor the interface is the sum of the messages the actor understands through its behavior. For microservices, the interface is based on the sum of the facilitated communication channels, e.g.\ the REST interfaces the service exposes and the messages it consumes from a message queue. Only through the interfaces can we access or modify the service's state.

Table [#tab-comparison-encapsulation] at the end of this section summarizes the encapsulation-related matters as they are facilitated by Akka actors and Spring-based microservices.  


#### Shared and Mutable State


One fundamental characteristic of both actors and microservices is their notion of shared state. Summarizing Chapter [#ch-actor-model], the actor model encapsulates state exclusively within an actor. Therefore, the state is only accessible to and modifiable by the actor itself. Additionally, actors provide single-threaded semantics while processing messages. An actor processes only one message at a time. The isolated turn principle eliminates the need for synchronization, since message are free of low-level data races, and a turn has exclusive access to the current state. The actor's state is fully isolated.

On the other hand, we cannot apply the same reasoning for microservices in general. The paradigm states nothing about how state has to be handled internally. Depending on the programming paradigm we use to implement the service, state is not necessarily exclusive. In OOP for example, several objects can have access the same memory location. Furthermore, concurrent access to the state is also possible, e.g.\ as a reaction to several invocations of the service's interface within a short time span. Microservices do not ensure single-threaded semantics. In general, we can therefore assume that we must synchronize the access to the service's internal state. Additionally, the microservice paradigm dictates that we must avoid shared memory *between* services, as well as all kinds of shared resources in general. Since every service runs within a dedicated system process, avoiding shared memory implies no direct intersection between service process boundaries. Typical communication channels satisfying the requirements given in Section [#sec-independence-and-interaction] also prevent reference sharing to joined mutable data. All viable channel technologies provide some sort of message passing designed to transfer information between the different memory spaces of distinct processes [@Les09].

Actors generally face more challenges when it comes to truly ensuring state separation. The components can exist within the same process boundaries and access the same memory locations. Depending on the programming paradigm used to implement the actors, exposing shared state to others can be rather easy. At the same time, exposing state is not necessarily apparent to the programmer. Think of the example we discussed for Akka. We can use every arbitrary object as a message. If an object is not constructed in an immutable fashion, the message transfer shares the object's state. Concurrent access to this shared state causes unpredictable runtime issues. Especially the imperative programming style leans on mutable state. Actors in imperative languages therefore require extra care to preserve the model semantics. The functional paradigm tends to avoid these problems inherently. Behavior is modeled as a function and only this function is modifiable exclusively by the actor. If the actor model is integrated into the programming language directly, the language is able to enforce restrictions preventing shared mutability problems by design. Erlang is the prime example [REF irgendwas]{.red}. However, library-based actor implementations cannot ensure full isolation by themselves in general [@Kos16].


#### Concurrent Persistence and IO


The encapsulation and isolation principle of actors and microservices has one more important implication. State is exclusive to a single component. Each component must also take exclusive care if we expect the state to be durable across the components lifetime. In our scenario, every CatalogStore must have its exclusive database and every IndexStore its exclusive reverse index datastructure. However, neither an actor runtime nor a microservice technique can enforce this persistence restriction. The obligation of correct configuration lies solely with the programmer. 

We also desire concurrent interaction to persistence mechanisms to increase throughput. Microservices can easily leverage the concurrent interaction capabilities of a database management system due to the service's internal concurrent structure. The thread-pool strategy of Spring as well as the software transaction mechanism transparently extend to database interactions. 

Actors face more problems, since they are not concurrent internal. As with all actions in the actor model, database interactions must be executed in a turn-based fashion in general, and are thus sequential. We've outlined that we can apply the same strategies as for synchronous communication to improving persistence efficiency for actors. Either we employ additional concurrency constructs (futures) or we delegate interactions to child actors. Futures always have the potential to violate the isolated turn principle. Delegation forces us to share the database between several actors, violating the exclusive ownership of (shared) state. 





<!--

Unfortunately, database systems have always been design to provide read and write access to several components concurrently. The requirement is therefore rather unintuitive.

We have outlined a scenario in Section [#sec-actor-persistence] where the author of this work has experienced that loosening up the database sharing restriction can have a possitive influence on an actor's throughput. The isolated turn principle implies that an actor can only perform one database interaction at a time. Database access is a form of IO and therefore a performance limiting factor. Breaking up the conceptual CatalogStore actor into several physical actors (the CatalogStore master and the database interaction slaves) enables us to perform database IO operations in a concurrent fashion. This disintegration violates the persistence ownership requirement by extending the access to a single database instance to a limited group of highly coupled actors.

~ todo
SubActors des CatalogStores: master-slave? Hier muss ich mich auf eine Benennung festlegen und diese auch im Actor Kapitel übernehmen!
~

Concurrent database interaction is conceptually easier for microservices. Several internal modules of a service are able to access an exclusive database in the same way a monolithic application's modules do. Concurrent interaction is also possible, since a microservice is allowed internal concurrency. The service's IoC container's utilize thread-pools. The database interaction concerns are scheduled on a pool and executed concurrently. Spring's transaction mechanism handles synchronization and extends to database transactions for concurrent access. However, no two microservices must leverage the same database instance. 
-->

<!--
The exclusive database ownership restriction also opens up opportunities. Monolithic applications tend to rely on as few database systems as possible. A multitier architecture traditionally has the data access layer at the bottom, and consecutive layers are build relative to the bottom layer. A new database system brings the risk of fundamentally impacting a program's architecture. It is therefore unusual for program modules to have their own persistence layer exclusive to them. Due to their respective natures, modules based on the actor and microservice concepts make it easy to add additional persistence layers to accommodate architecture requirements. The approach of introducing specialized database systems based on respective persistence needs, at the risk of introducing potential redundancies, is referred to as *polyglot persistence* [@Bon16;@Fow14].
-->


#### Cohesion, Coupling and Independence


Message passing interfaces and strong encapsulation makes actors and microservices *cohesive*. Bonér [@Bon16] also defines truly isolated components combined through message passing communication as *decoupled* in two dimensions. On the one hand, the components are decoupled in *time*, which is the requisite for concurrent execution. On the other hand, the components are decoupled in *space*, and therefore we can execute them remotely and even move them between locations.

Regarding time, actors facilitate asynchrony intrinsically through the model design. Nevertheless, actor systems tend to offer synchronous primitives on top of the asynchronous style. Programmers receive better abstractions, at the cost of increased coupling. Microservices are free to choose the IPC style, as long as the IPC mechanism is based on message passing rather than shared memory, further reducing the coupling.

Regarding space, actors are conceptually fully isolated. In practice, ensuring true isolation is difficult, especially for library-based actor implementations. We've discussed the conceptional problems for Akka in detail in Section [#sec-actor-isolation]. In the end, the programmer has to guarantee the isolation by complying to programming conventions. Infringing these conventions introduces or exposes shared mutable state, which is a violation of the actor model. Also, shared mutability increases the coupling to the sharing component, both in time and in space. 

Microservices have an inherent advantage regardless of the chosen programming model. The only true paradigm requirement is the avoidance of shared memory sections with other processes. Either the memory boundaries enforced by the operating system, or the hardware separation resulting from distribution guarantees spacial decoupling. Besides, microservices are further decoupled by a their distinct codebases. Only a shared library increases their coupling. For example, we facilitate a custom Core library in Echo. Core increases the service's coupling relative to the library. We've implemented all domain-specific functionality, as well as *data transfer objects* (DTO) within the Core. The DTOs are the domain objects we use as messages. Therefore, all microservices are coupled among each other by the DTO classes. Actors suffer from the coupling problem unequally more. Every actor is intrinsically bound to its runtime system. Different interfaces to an actor system can exist. Akka demonstrates interface diversity for Java and Scala. Yet, the actors cannot escape the coupling to Akka's codebase. Additionally, Echo's actors are also coupled by the DTOs in Core, just like the microservices. 

<!--
~ green
The literature often points out a correlation between the metrics of coupling and cohesion [@Woo93]. If coupling is low, then cohesion tends to be high. Cohesion is reflected in the single responsibility principle. Aspects required to fulfilling the functionality is encapsulated within a single unit, respective an actor or microservice. Again, shared libraries pose a problem. 

Echo's commonly used `core` library, wrapping most domain specific logic, is generally a prime example. It increases coupling and decreased cohesion of all components using it (which almost all actors and microservices are), but the affect is accepted to gain a better separation between domain logic and communication and coordination logic. Apart from that, modularity in both actor and microservice systems is high, as functionality of components can be arbitrarily used and combined.
~
-->

These two notions, high cohesion and low coupling, allow us to reason about the *independence* of task units. Independence is one of the primary concepts of the microservice paradigm, and is described as a direct consequence of high cohesion and low coupling throughout the literature [@Dra17a;@Dra17b;@Dra17c;@Sha17b]. We deem the strong process-based form of independence superior to the notion provided by the actor construct. Actors are passiv tasks which react to messages. An actor can only perform actions when the runtime executes the actor. Microservices can show active behavior on their own.

~ Begin TableFigure { #tab-comparison-encapsulation; caption: "Comparison of encapsulation-related matters in Akka and a Spring-based MSA"; page-align:here}

|----------------|------------------------------------|------------------------------|
| Characteristic | Akka                               | Spring MSA                   |
+----------------+------------------------------------+------------------------------+
| Shared state   | Not enforced, obligation of the    | Ensured through processes    |
|                | programmer                         | memory boundaries            |
| ---------------|------------------------------------|------------------------------|
|                | Single-threaded semantics, free of | Concurrent access inside the |
| State mutation | synchronization, threatened by     | service is possible, but     |
|                | language features                  | requires synchronization     |
| ---------------|------------------------------------|------------------------------|
|                | Single-threaded semantics          | Concurrent interaction with  |
| Persistence/IO | dampens throughput, improved       | outside freely possible      |
|                | with futures or delegation         |                              |
| ---------------|------------------------------------|------------------------------|
| Cohesion       | High cohesion through strong encapsulation and message passing   ||
| ---------------|------------------------------------|------------------------------|
| Coupling       | Coupled to common codebase         | Low coupling through         |
|                | and the runtime                    | independent codebases        |
| ---------------|------------------------------------|------------------------------|
| Independence   | Passive units, subject to runtime  | Active units, subject to OS  |
| ---------------|------------------------------------|------------------------------|

~ End TableFigure

<!--
~ Findings
[Main findings]{.findings-title}

+ Actors and microservices both encapsulate state exclusively. The resulting isolation provides the foundation for concurrent, parallel and distributed execution without synchronization between the task units.
+ Actor libraries require programmers to merit special attention to ensure isolation. Microservices are inherently isolated through their separate OS process boundaries.
+ Actors are coupled relative to their runtime ecosystem. Coupling between microservices is so low that we can utilize heterogenous technologies for each service. 
{.findings-list}
~
-->


### Communication and Message Routing


According to the general concerns of concurrent computation, tasks without mutable shared memory require other kinds of communication links which facilitate message passing instead. Since both the actor- and microservice model strictly omit shared state, they too require what we call *communication channels* for messaging. These channels transport information from a source to a destination. A *sender* is writing data to the channel, upon which a *receiver* can read the data. Independent of the concrete channel technology, message passing is a form of implicit synchronization of the information, since the event of reading a message can intrinsically only occur *after* the message was sent. In contrast, shared state explicitly requires a defined order of accessing the information [@And83].

Throughout the literature we've identified various forms of information flows offered by channel concepts [@Cou05;@Mon14;@Gui09;@Spe90;@Roe15;@Agh99;@Tan07;@Bac03]. Generally, the flows can be distinguished alongside two dimensions: number of recipients and response coupling. Authors declare varying taxonomies for the resulting combinations. Table [#tab-communication-styles-overview] provides an overview of the terminology used in the remainder of this work. Subsequently, Table [#tab-communication-styles-comparison] summarizes the communication capabilities of Akka actors and Spring-based microservices regarding these communication styles at the end of this section.

~ Begin Center
~ Begin TableFigure { #tab-communication-styles-overview; caption: "Communication Styles";}
|------------------|------------------------|-------------------------|
|                  | One-to-One             | One-to-Many             |
+------------------+------------------------+-------------------------+
| **Synchronous**  | Request/response       | &mdash;                 |
| -----------------|------------------------|-------------------------|
| **Asynchronous** | Notification           | Publish/subscribe       |
|                  | Request/async response | Publish/async responses |
|------------------|------------------------|-------------------------|
{  }
~ End TableFigure
~ End Center

Asynchronous one-to-one messaging is inherent to the actor model. The message-sending primitive realizes notification style communication. Responses are realized asynchronously too. Akka provides the `sender()` method within actors. The method produces the `ActorRef`{language:scala} of the originator of the current turn's message. Microservices achieve asynchrony via message queues. Responding depends on the channel protocol. AMQP does not transmit the sender's location. If we must send a response, we need to include the location information into messages individually. 

Synchronous one-to-one messaging can be modeled on top of the actor messaging primitive, since every synchronous communication can be expressed using asynchronous constructs in general, and vice versa [@Agh97]. Akka provides linguistic support for request/response messaging through the `ask [?]` method of `ActorRef`{language:scala}. Microservices can utilize network mechanism dedicated to the synchronous interaction pattern. In the service context, REST is the most prominent example. 

One-to-many communication is neither inherent as a primitive to actors nor microservices, thus requires additional effort. Conceptually, we can model the communicatiom style by sending a message to each intended recipient in a notification fashion (message broker). 


<!--
The functionality is generic as it involves merely a communication mechanism, messages and recipients. No domain-specific functionality is required. Therefore, it is convenient to implement the approach within a separate task unit:

* Message Broker (B)
  : are commissioned with messages and forward them to potential recipients. The functionality is merely concerned with communication and therefore domain independent. Broker tasks constitute communication channels.

[Example]{.example-title}: When a single Store needs to modify its state, we must ensure that all other Store units also perform the same update operation. Therefore, the unit does not performing the update operation directly.

~ Figure { #fig-message-broker; caption: "Message broker"; width:50%; float:left; margin-right: 1ex; }
![img-message-broker]
~

[img-message-broker]: graphics/message-broker.[svg,png] "Image about message broker" { height:3.5cm; vertical-align:middle; padding-bottom:1em; }

Instead, the component sends a respective update-message the message broker (`C` &rarr; `B`). All Stores, even the original sender, can then pull the message from the broker ($\{$`C`~1~$\cdots$`C`~n~$\}$  &larr; `B`). Figure [#fig-message-broker] shows this flow. Upon message reception, each Store is then able to perform the state modification. 
-->

Akka has message broker capability in their message router constructs through the respective `BroadcastRoutingLogic`{language:scala}. Echo implements the routing logic inside a separat actor. In Echo's MSA, the RabbitMQ service does not suffice for one-to-many message distribution. AMQP only supports what the JMS terminology calls *queue* semantic (one-to-one), but not the JMS *topics* (one-to-many). We must employ another messaging technology. *Kafka* [@ApacheKafka] is a widely adopted publish/subscribe streaming system with very lightweight message constructs, and therefore appropriate for the microservice paradigm. 

One important realization is the difference in messaging interfaces. While Akka provides few but homogenous interfaces (`tell [!]`, `ask [?]`, and routes for `RoutingLogic`{language:scala}s) across all language bindings, the microservice model does not enforce any kind of interface. REST, AMQP and Kafka all have different interfaces. Since all Echo services are based on Spring, at least we express the interaction with each comminication mechanism in the same way within each service. But the microservice paradigm is also open for arbitrary technologie stacks, and every stack provides its own interface for each mechanism.   

~ Begin Center
~ Begin TableFigure { #tab-communication-styles-comparison; caption: "Comparison of communication capabilities in Akka and a Spring-based MSA"; page-align:here; width:100%}
|-------------------------|---------------------------------------------|---------------------------|
| Communication Style     | Akka                                        | Spring MSA                |
+-------------------------+---------------------------------------------+---------------------------+
| Request/response        | `ask` method of `ActorRef`{language:scala}, | Remote procedure call     |
|                         | cameo pattern                               | with REST                 |
| ------------------------|---------------------------------------------|---------------------------|
| Notification            | `tell` method of `ActorRef`{language:scala} | Message queue service     |
|                         |                                             | like RabbitMQ             |
| ------------------------|---------------------------------------------|---------------------------|
| Request/async response  | Request and response with                   | Request and response      |
|                         | `tell` method of `ActorRef`{language:scala} | through message queue     |
| ------------------------|---------------------------------------------|---------------------------|
| Publish/subscribe       | Message broker actor with                   | Message broker service    |
|                         | `BroadcastRoutingLogic`{language:scala}     | like Kafka                |
| ------------------------|---------------------------------------------|---------------------------|
|                         | Message broker actor with                   | Request through message   |
| Publish/async responses | `BroadcastRoutingLogic`{language:scala}     | broker, responses through |
|                         | for request, responses with                 | message queue             |
|                         | `tell` method of `ActorRef`{language:scala} |                           |
| ------------------------|---------------------------------------------|---------------------------|
{ width:100%  }
~ End TableFigure
~ End Center


### Conception of Concurrent Execution


~ todo
Dieses Einleitungsabsatz geht mehr oder minder genau gleich los wie das Unterkapitel gleich danach
~


Actors and microservices are both concurrently executed components within their system architectures. However, their execution-modalities are fundamentally different. Hence, both constructs have different *notions* of concurrency. Each notion is a direct result of the underlying concepts.


#### Continuations, Threads and Processes


Scala's standard actors provided two different execution semantics [@Hal09]. One of the semantics schedules the actors on threads. These actors are executed in an inversion of control manner [@Hal06], similarly to the strategy pursued by the Spring framework. The other of the two semantics is purely event-based and therefore without IoC. Thread-based actors are invoked by their current thread to execute a turn. Upon completion, the actor returns to the calling thread. On the other hand, event-based actors do not have (and need) a dedicated thread and therefore cannot return to one. Instead, they facilitate a much cheaper concept called *continuation-passing style* known from functional programming. A function refrains from returning a computed result by calling a subsequent function, the so-called *continuation closure*. Akka extends this approach and defines as single closure for all messages until the behavior is replaced, which has shown to be much more effective [@Hal12]. We already gave an example of a continuation with `Actor.same`{language:scala} for Akka's type-restricted behaviors. `Dispatcher`{language:scala}s influence the thread assignment strategy for concurrently running the behavior closures [@Hal12]. Although using threads, the continuation closure approach is still considered event-based, since a thread can be seen as merely a trajectory in continuation space [@Shi97]. Nevertheless, threads are conceptually similar to processes, except that several threads can exist within a single process [@Bac03]. There, the actor thread-pools live in one or few processes and many actors share the same memory boundaries of their respective process. 

Although executed on top of threads, the isolated turn principle essentially defines actors as single-threaded entities. The combination with asynchronous message passing allows the runtime to concurrently execute these logical single-threaded components. In general, an actor has no notion of concurrency at all itself. However, we've demonstrated how we can introduce additional concurrency constructs into the scope of actors, as long as these additional constructs do not break the actor model semantics. Section [#ch-actor-impl] demonstrated futures with their pitfalls as one option. In combination with the continuation abstraction, Akka actors are powerful and still extremely light-weight constructs.  

<!-- TODO delete?
Such abstract a value which will be available at some point in time eventually. Basically they introduce a notion of semi-blocking behavior [irgendwo hab ich hierfür ein zitat!]{.mind}. Either the value is available when trying to access it, or blocking is the consequence until it is. A third way of handling Futures is possible, which directly defines consecutive computation on the value without blocking, but once it becomes available. In any case however, they pose the risk of accidentially introducing data races. As a safer alternative, Actors can use delegation to child Actors to provide concurrent processing, without jeopardising safe encapsulation as do Futures.
-->

On the other hand, microservices are concurrent distributed processes. The model paradigm tolerates a more widespread notion of concurrency than actors do. Internally, services do not have to respect a counterpart to the isolated turn principle. Though a service also receives messages via a public API and reacts to them, the MSA style permits design flexibility regarding internal task unit concurrency. For example, a widespread strategy in the domain of distributed systems is to utilize several threads to perform blocking operations [@Tan07]. A microservice is free to apply this strategy to perform blocking operations without blocking the service's entire process, and react to numerous messages simultaneously.
 

The drawback of this degree of freedom is the set of issues internal concurrency introduces. In general, accessing state is not a safe operation anymore, if the respective state is read- and writable across threads. We must then use synchronization, e.g.\ in the form we've demonstrated in the Java case study. When we program with microservices, we are therefore not free from the many hassles of low-level concurrency per se. We've seen this in Echo's MSA variant, where we use transactional memory for synchronization. However, a service's size is limited by the service's scope of responsibility. Consequently, the size also limits the internal concurrency considerations of a service relative to the overall system. As a result, linguistic approaches to SOC tend to avoid internal concurrency considerations completely by applying an idea resembling the C processes case study. For example, Jolie offers the `concurrent`{color:blue} primitive as one option for the execution modality of services. The primitive dispatches dedicated processes to concurrently execute the service behavior in response to messages [@Mon16b]. This idea has close resemblance to the cameo delegation pattern used by actors. Of course, the design freedom of the MSA style also allows actor-based concurrency internally. The benefits of synchronization-free programming can be harvested by microservices too. 


<!-- TODO delete?
...rresource access inherently has. A basic example is locking. When an Actor processes a message, it is guaranteed to have unqiue access to its internal state, therefore must no handle any locks and can savely assume its state as up to date. When a Microservice accesses any kind of internal resource (state), this resource might currently be locked by an internal transaction mechanism, granting read access, but not guaranteeing that the state is actually up to date. [dirty read? irgendwas allgemeines zu locking und read zitieren]{.mind} 

Programming with Microservices does not, unlike Actors, free one from the many hassles of low-level concurrency concerns per se. Depending on the model used, locking and synchronization as demonstrated in the concurrency in Java case study might have to be dealt with. However, the services size -- based on its scope of responsibility -- is limiting the complexity of the services internal concurrency considerations relative to the overall systems [citation needed? hab ich da eine? ist ja eigentlich mein eigener beitrag]{.mind}. As a result, linguistic approaches to SOC migth try to avoid this completely by applying an idea resembling the C processes case study. The `concurrent`{color:blue} primitive for Jolie services execution modality for example dispatch dedicated processes for concurrently executing the service behavior in response to messages [@Mon16b]. This has close resemblance to the delegation messaging pattern used by Actors.
-->


#### Distribution and Location Transparency


~LitNote
* Actors und MS ist es an sich egal ob sie lokal oder verteilt ausgeführt werden, beide können dies gut abstrahieren
* [@Reh13] defines requirements on distributed Actors:
    * R1: Distributability: Non-distributed applications must be easy to be migrated to clustered set-ups.
    * R2: API-uniformity: The distribution API must be similar for intra-node as well as inter-node applications
    * R3: Compatibility: An application that works locally on one node should also work distributed in a cluster.
    * R4: Flexibility: Beside Actors that have access to specific hardware, the developer should freely decide which Actor runs on which node of the cluster.
    * R5: Configurability: Simple configuration of the clustering subsystem and the distribution layout.
* [@Kan15] (über distributed/cloud Actors)
    * "There (Actor) distinctive features make it suitable to support distributed memory parallelism, and it has been widely used in many industrial languages such as Erlang[2], Scala [3], Akka [4]"
    * "However, most related works focus on multi-core environment. Neither inter-parallelism or task parallelism can be easy applied in dynamic distributed environment, because Actors distributing over cluster may be- have indeterminable interrelationship, such as uncertain com- munication, dependency and failure"
~


Communication via message passing has one fundamental property: no mutable memory is shared between the communicating components. Conceptionally, message passing does not require the components within the same memory space. As a result, it does not matter whether the components run on the same processor, different cores or even the same host machine [@Fel90]. In short, message passing allows for distribution. 

The actor model intrinsically builds upon message passing to share state information between actors. Additionally, actors are well isolated from each other. Based on these properties, Agha recasted the initial notion of actors in the light of distributed computation [@Agh85a]. All actor addresses, and therefore also Akka's `ActorRef`{language:scala}s, make the location of the underlying actor transparent. The runtime system handles the actual message delivery within an Akka cluster on the same local node and on remote nodes. Addresses provide a uniform interface free of location considerations.

Microservices intrinsically fall into the domain of distributed system as well, if the services choose to leverage a network-based communication mechanism. There is no guarantee of a unified channel interface for all services and mechanisms. We've given Unix pipes as an illustrative mechanism. Pipes facilitate a file descriptor interface, as is promoted by Unix in general. This interface is intrinsically limited to local node interaction, that is the memory boundaries of a single host OS. Channels operating on the network level are distributed communication mechanisms. Network channels facilitate message passing and provide a uniform interface for remote as well as local communication [@Spe90]. Sockets are the most basic example. The socket interface is homogenous regarding whether a socket is on the same local or a remote node. However, sockets still require the *concrete* address [@Bac03]. In order to have the recipients' location transparent, the microservice paradigm requires additional effort in the form of discovery mechanisms. We've demonstrated how Echo integrates discovery based on Feign and Eureka directly into the client-side communication interface using the declarative programming style.


#### Fairness and Resource Consumption


Actors and microservices represent concurrent building blocks of equal status in their respective architectures. It is important to reason about the chances to make even progress, since we have a uniform view on concurrent execution [@Bus90]. Our view does not distringuish quasi-simultaneous execution on a single processor, truly parallel execution on multiple CPUs, and distributed execution among several host machines. The property of uniform progress is called *fairness* and is closely related to the liveness of concurrent programs and systems, i.e.\ to avoid starvation [@Agh85a;@Agh99].

Actors are entities inside an actor runtime. Their scheduling is the responsibility of this runtime system, viz.\ the system's execution strategy. As passive components, actors have no proactive sense and therefore they only react to events (received messages). Actor systems assure that each message is delivered to and processed by an actor eventually. Therefore, each actor must be scheduled regularly by the runtime to prevent starvation [@Kan12;@Kar09]. The major benefit is that actor systems can greatly reduce processing resource consumption. Given an actor's mailbox is empty, the runtime does not have to invoke the actor, since their is no work to do [@Agh14].  

On the other hand, scheduling is a nonconcern for microservices. Every MSA is a composition of concurrent distributed processes, and therefore scheduling is delegated to the operating system(s) -- respectively their *scheduling policies* -- on which these processes are running on [@Bac03]. We cannot make specific assumption on execution rates in general, but require these rates to be positive. This *finite progress assumption* [@And83] is the foundation of liveness for every microservice.

However, there is one drawback to the lack of scheduling concern in MSAs. The architecture cannot influence the resource consumption based on a service's actual demand. An operating system will always allocate resources towards a process. Therefore, every task unit of an MSA also stresses its hosts processing power on a regular basis, at least to a small amount. This drain on resources is true even when the services are neither requested nor perform active behaviors of their own. In these cases, every process activation is simply a waste of energy [@Tan07].


Table [#tab-fundamental-concurrency-issues] gives an overview of how actors and microservices meet fundamental issues of concurrent programming.

~ Begin Center
~ Begin TableFigure { #tab-fundamental-concurrency-issues; caption: "Comparison of Akka actors and Spring-based microservices meeting fundamental issues of concurrent execution"; width:100%}
|-----------------|--------------------------------|---------------------------------|
| Issue           | Actors                         | Microservices                   |
+-----------------+--------------------------------+---------------------------------+
| Expression      | Actor object, concurrent       | Service program execution,      |
|                 | execution by runtime           | concurrent scheduling by OS     |
| ----------------|--------------------------------|---------------------------------|
|                 | Message passing primitives     | Message passing IPC mechanisms, |
| Communication   | (e.g.\ `tell`, `ask`), uniform | no shared memory, no uniform    |
|                 | interface across all actors    | interface across all services   |
| ----------------|--------------------------------|---------------------------------|
|                 | Implicit among actors due to   | Implicit among services due to  |
| Synchronization | message passing, single-       | message passing, potentially    |
|                 | threaded semantics internally  | required internally             |
| ----------------|--------------------------------|---------------------------------|
| Progress        | Guaranteed by runtime          | Expected from operating system  |
| ----------------|--------------------------------|---------------------------------|
{ width:100%  }                               
~ End TableFigure
~ End Center


<!-- TODO Section ist fertig, aber am 22.8.2018 testweise deaktiviert

#### Distinction to Distributed Objects {#sec-distributed-objects}


In object-oriented programming, the overall program state is partitioned into disjoint sets, each chunk belonging to a distinct object. As Werner pointed out, the state is distributed from a logical point of view [@Weg90]. However, distributed programming has different emphasis of concerns than OOP does. Yet, both architecture styles can be integrated to support physical distribution of objects. The notion is called *distributed objects* (DO). There, objects do not have to exists within the same program boundary, but can be distributed across numerous programs and therefore host machines. We can therefore view DOs from a process-oriented perspective. Barrio & Fuente [@Bar97] give a formal definition of modelling objects as processes.  

In terms of programming interfaces, every DO requires a proxy object on the client side, which wraps the method calls to the actual distributed object. Due to this separation of interface and implementation, the calling object and the called DO do not have to exist within the same address space [@Wal96]. Therefore, local and distributed method calls look alike (location transparency). However, often the object reference still has to be bound explicitly to a registry by the programmer, e.g.\ in *Java RMI* and *CORBA* [@Ber14;@Fal99]. Then, distributed object instantiation is not uniform to local object creation.  

The distributed object approach has many similarities to concepts we've already discussed. On the one hand, the design goals of microservices aim towards an object-like single-purpose computational unit skeleton. This skeleton resembles distributed objects within an object-oriented application. On the other hand, the distributed nature inherently leads toward transparent concurrent/parallel execution, as actors and active objects do. Therefore, it is worth to evaluate whether these abstractions qualify for distributed objects, as it would imply known conceptual problems.

Table [#tab-dispatch-semantics-capabilities] gives an overview of the available dispatch semantics capabilities that we will evaluate in more detail for every concept. The semantics are based on Akka's `UntypedActor`{language:java} for actors and `TypedActor`{language:java} (it offers type safety for message passing) for active objects, Java RMI [@OracleJavaRMI] for distributed objects and Java/Spring-based mechanisms for microservices.

~ Begin Center
~ Begin TableFigure { #tab-dispatch-semantics-capabilities; caption: "Dispatch semantics capability matrix for Akka (actors/active objects), Java RMI (distributed objects) and Spring (microservices)"; page-align:here; width:100%}
|------------------|-------------------------------------|-------------------------------------|--------------------------------------|
| Construct        | Past Type                           | Now Type                            | Future Type                          |
+------------------+-------------------------------------+-------------------------------------+--------------------------------------+
| Actor            | `tell` method                       | Not available                       | `ask` method                         |
| -----------------|-------------------------------------|-------------------------------------|--------------------------------------|
| Active Object    | Method with no                      | Method with any                     | Method with                          |
|                  | return type (`void`{language:java}) | `Object`{language:java} return type | `Future`{language:java}  return type |
|------------------|-------------------------------------|-------------------------------------|--------------------------------------|
|                  |                                     | Every method,                       | Several proposals,                   |
| Distributed Obj. | Not available                       | regardless of                       | e.g.\ [@Fal99], but no               |
|                  |                                     | return type                         | official support                     |
| -----------------|-------------------------------------|-------------------------------------|--------------------------------------|
|                  | Asynchronous                        | Synchronous                         | IPC with semi-sync.                  |
| Microservice     | IPC, e.g.\ AMQP                     | IPC, e.g.\ REST                     | API, e.g.\ Apache                    |
|                  |                                     |                                     | HTTP Components                      |
|------------------|-------------------------------------|-------------------------------------|--------------------------------------|
{ width:100%  }
~ End TableFigure
~ End Center


##### Actors as Distributed Objects


The actor model deals with distribution transparently. Just like distributed object proxies, actor addresses pose as local interfaces. However, these addresses do not check message compatibility (method name and argument types). Erlang famously introduced the syntax `address ! message` to send a message of arbitrary form to an actor identified by a known address [@Arm93]. Since Erlang does not facilitate object-orientation, accessing state and message passing are strictly separate constructs by design. Other actor variants adopted this style, e.g.\ Scala's original actors and Akka. Scala's type system provides a punctuation-free syntax to invoke methods on objects which take only a single argument, offering an infix notation style[^fn-punctuation-free-call]. Despite an object-oriented context, we can apply different syntactic constructs to reference ordinary objects and actors. The distinction is merely by convention only. 

[^fn-punctuation-free-call]: The expression `address ! message`{language:scala} is therefore merely syntactic sugar for `address.!(message)`{language:scala}.

The truly fundamental difference between addressing an actor and a distributed object is within the dispatch semantics. Actors rely on asynchronous message passing as defined by the basic model primitives. Asynchronous messages are decoupled in time and do not introduce the expectation of an immediate response (blocking call). In general, method calls with a (non-future) return value are synchronously dispatched and create the expectation of an immediate response. Message passing (past type) is therefore more loosely coupled than the request/reply calls (now type). In general, we expect distributed objects to facilitate many now-typed methods, as this result type variant is natural within OOP. 

Even worse, distributed objects with Java RMI only facilitate blocking method invocations [@OracleJavaRMI]. RMI is not even regarding the return type of a method. Therefore, it does not matter if a method returns `Object`{language:java} or a subtype thereof, or nothing, as is indicated by the `void`{language:java} keyword. Every method call on a DO proxy (interface) blocks until the method has been executed by the DO instance (implementation). Future-typed methods are no exception. RMI does not provide semi-synchronous method dispatch, although numerous implementations have been proposed [@Fal99]. On the other hand, Akka does not even offer now-typed communication. The default messaging style is based on the past-typed `tell`, and the `ask` method provides future-typed messaging ontop of `tell` [CITATION?]{.red}. Due to this discrepancy in the dispatch semantics, we do not deem it likely that actors will be mistaken for distributed objects. 


##### Microservices as Distributed Objects


The method call on a DO proxy object makes it transparent for clients whether a locally available or remote server object is addressed. Though there is also location transparency in the microservice idiom, we generally can assume a distinction in the programming interface of local (within a service) and remote (between services) interaction. For service-internal interaction, we use the standard mechanisms of the service's technology paradigm, e.g.\ calling an object's method, or referencing a function. To issue an external request, we must issue a respective interface, regardless whether we expect a result or not. This interface is dedicated to the communication channel, e.g.\ a HTTP library or message queue API. Therefore, an external interaction should be recognizable to the programmer in general. For Echo's services, we use Spring and its IoC container. We demonstrated the definition of the `IndexClient`{language:java} interface for consuming a REST resource with Feign. Spring generates an implementation at runtime, but we must decorated the interface in a declarative programming style accordingly.

Although we utilize the resulting implementation in a purely Java-like, object-oriented manner, method calls on `IndexClient`{language:java} do not result in JVM-internal communication. It took us additional effort to declare the desired external effect with annotations. These decorations make it apparent (to a certain degree) that `IndexClient`{language:java} is not an ordinary interface, but an API for external communication. To cope with distribution related matters, we even added additional precautions like circuit breakers in linguistic form (annotations) that is natural with the chosen declarative approach. It is therefore the responsibility of the programmer to incorporate auxiliary frameworks and issue appropriate design decisions when handling service-external communication. In contrast, distributed objects in general aim towards abstracting distribution and the resulting issues as transparently as possible [@Wal96]. 

Another argument is the granularity of service interfaces. Objects are prone to provide very fine-grained interfaces in general, e.g.\ to access each state variables separately. Microservices tend to have more course grained interfaces. In the SOP context, it is more likely that messages between services do not issue too fine-grained operations. Every message is at risk of the external communication mechanism's issues [@Sha17a], e.g.\ most Fallacies of distributed systems (Section [#sec-concurrency-network-level]). The microservice paradigm takes the problems of remote messages and procedure calls explicitely into account. Therefore, we do not deem microservices likely to be subject to the same conceptual issues as are distributed objects.


##### Active Objects as Distributed Objects


Although we already discussed the similarity to actors, Section [#sec-active-objects] introduced another variant of the actor model. Active objects explicitly capitalize an object-oriented abstraction and therefore they are especially relevant here. We gave an example of the concurrency semantics of active object interfaces. The method call is separated from the message execution. We demonstrated the behavior in case of method interfaces with and without return values. Building on this previous example, we formulate:

``` {language:scala}
val fs: List[Fnord] = ... // list of 100 references
var sum = 0
for (f <- fs) {
    sum += f.get()
}
print(sum)
```

The code snippet iterates over all elements and makes a blocking call to retrieve the value. This has two fundamental issues:

1. The programs will block sequentially 100 times, once for each element.
2. If some, or in the worst case all, of the elements are not within the same local boundaries but transparently distributed, each `get()` call will cause up to 100 separate remote procedure calls with as many opportunities of a synchronous network call fault.

The first issue is a result of bad coding practice. The seconds issue is related to a problem that the abstraction distributed objects provide also suffers from. Programming non-distribution is fundamentally not the same as programming distribution, and a uniform communication approach cannot surmount the conceptual differences [@Wal96]. It is not clear whether the dispatched `get()` method will execute locally or remotely, as the object abstraction is hiding too much context.

Additionally, the programmer can call `get()` without being aware that it actually offers a result value and therefore will block[^fn-get-method]. Now-typed methods can be used the same way past-typed methods are, due to the syntax definition. Thus, now-typed method dispatches have the potential to introduce unintentional and unexpected additional remote procedure calls. 

[^fn-get-method]: Though with this particular method name and usage it is hopefully unlikely.

We can fix both issues by using the future type of message passing for active objects. This is done in Akka by changing the declaration of `get()` to return a `Future[Int]`{language:scala} instead. In functional languages, handling futures can be done elegantly if they offer monadic behavior that fits natural with functional programming styles, e.g.\ in Scala:

``` {language:scala}
1  Future.sequence(fs.map(_.get))
2    .map(_.sum) 
3    .onComplete {
4       case Success(res) => print(res)
5       case Failure(_)   => print("error")
6    }
```

This is an example where is is efficient to integrate other compatible concurrency abstractions into the actor construct. Line 1 transforms `fs:List[Fnord]`{language:scala} first into a `List[Future[Int]]`{language:scala} and then into a `Future[List[Int]]`{language:scala}. The runtime's dispatcher can now wait until this `Future`{language:scala} completes without blocking the underlying thread. The call stack starting in line 2 is only applied upon completion, finalizing the intended result. 

However, this argumentation only holds under certain assumptions. As we've already mentioned, different actor systems have different capabilities. In Section [#sec-active-objects] we've stated that class `Fnord`{language:scala} extends some arbitrary `ActiveObject`{language:scala} class, but did not discuss the implications the used implementation has on the correct behavior. Assuming we change `Fnord`{language:scala} to use Akka's `TypedActor`{language:java} class, the desired non-blocking behavior actually depends on the `Future`{language:java} class we use to wrap the `Int`{language:java} result. Akka supports asynchronous dispatch only for the `scala.concurrent.Future`{language:java} trait. If class `Fnord`{language:java} uses its Java-friendly `akka.dispatch.Futures`{language:java} interface, the intended behavior is guaranteed. However, the standard `java.util.concurrent.Future`{language:java} interface results in undesired blocking behavior [@AkkaFuture].

We see, in general active objects and distributed objects share the same potential to abstract distributed programming in a problematic way. Method interfaces define the method dispatch semantics. If not used with utmost care, method calls can easily become simple remote procedure calls in a transparent way. RPCs cause e.g.\ bottlenecks, deadlocks and timeouts due to stacked network latencies, thus endanger the safety and liveness of a system. 

However, the one major benefit of active as well as distributed objects compared to classic actors and microservices is their type safety when passing messages. It is statically known whether a server is able to understand a request. Respectively, a client can only dispatch messages which are guaranteed to be accepted. 

~ todo
Hier ein paar Worte zu Orleans. Warum nimmt dieses AOs her und hat es die API abstractionsprobleme irgendwie gelöst? Immerhin ist es für Cloud Computing gemacht... Darauf muss ich auf jeden Fall kurz eingehen, um dem ganzen hier etwas Sinnhaftigket zu verleihen
~

~ todo
Noch ein paar genauere Argumente aus [@Wal96]?
~

~ Findings
[Main findings]{.findings-title}

+ Actors and microservices qualify for distributed communication in a transparent way. Their messaging interfaces do not differe for local and remote interaction.
+ Active and distributed objects provide type-safety for messages, but increase the risk to introduce unintended synchronization constraints with their abstraction of transparent distribution. 
+ Messaging interfaces in actor- and microservice-based programming mitigate the problematic abstraction of transparent distribution.
{.findings-list}
~

-->


<!--
#### Components per Execution Environment


~LitNote
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * Beschreibt ch4.4 "Actors Per Execution Environment"
    * Classic Actors and Processes (Erlang) sind auf dem "level of abstraction" wie objekte in OO, oder abstract data types in FP
    * Active Objects und Communicating Event-Loops sind auf dem level of abstraction von "components" in OO, oder modulen in FP  
~


~ todo
Hier wird diskutiert wie viele Instanzen der jeweiligen Components existieren können, was wiederum ausdrückt wie viel Nebenläufigkeit innerhalb eines Hosts ausgedrückt werden kann. JVM Actors: im Bereich von maximal einigen 10k (im Gegensatz zu Millionen in Erlang -- da sehr viel schlankere Konstrukte); Microservices: theoretisch so viele wie das OS an Prozessen verträgt (habe ich hier Literatur bezüglich begrenzender Faktoren?), praktisch aber nicht all zu viele im Fall von Echo, da deren Stack doch relativ unschlanke Service forciert. 
~
-->

<!--
## Governance, Deployment and Autonomy

~ todo
Hier soll evaluiert werden, wie Actors/Microservices verwaltet werden (Actor.Sys. vs. Selbstverwaltung, bzw. Notwendigkeit eines extra Management Layers -- cloud management framework). Dies hat Implikationen auf das Deployment, da durch die mangelnde Oberverwaltung von MS diese viel unabhängiger sind, und daher auch separat gestartet/gestoppt werden können (-> Auswirkungen). Actors haben durch die starke Bindung an ihr System weniger Freiraum. Alles in Allem ist dadurch die Autonomie der beiden Komponenten-Abstraktionen starkt unterschiedlich.   
~

~ todo
Grafik zum Unterschied von Akka deployment (also JAR direct, mit allen Actors), vs den Spring MS innerhalb von Docker
~


Akka can ensure that a given Actor class is instantiated uniquely within a cluster. This requirement can be necessary, e.g.\ as is with Echo's Updater, such that no two instances can issue contrary commands to the feed processing workflow [EVENTUAL CONSISTENCY erst unten]{.red}.

~ todo
Hier sollte ich noch die Doku genauer lesen, ob ich hier noch mehr dazu sagen muss/soll/kann.
~

Microservices do not have such guarantee mechanisms inherently. In general, any service engine can be deployed independently and thus unrestricted in the number of instances.

Controlling instantiation is left to the programmer or operator [DevOps HINWEIS?!]{.red} of the MSA system manually upon deployment. To ease the deploment modality, so-called *cloud management frameworks* (CMF) [CITATION REQUIRED --  auch für noch mehr text]{.red} can be employed ...


~ begin green

~ lit
* [@New15] "Building Microservices"
* [@Dra17b] "Microservices: How To Make Your Application Scale"
    * "Portability. Microservices are typically packaged in containers, as provided, e.g., by Docker [10] or similar technologies. A container includes the microser- vice and all its environment (libraries, databases, . . . ) in a unique entity which can be easily deployed on any platform supporting the chosen container tech- nology, ensuring uniform behavior over heterogeneous platforms (hosts, data- centers and cloud providers) and isolation w.r.t. other containers (e.g., different microservices can use different versions of the same library without conflicts)"
~


"*Actors come in systems*". Such is the famous quote by Carl Hewitt on his conceptions. These system provide many [???]{.red} for their actors. They deliver messages, ensure fairness, [and supervise...]{.red}. In a way, actor systems *govern* their actors in a homogenous way [KANN ICH DA WAS ZITIEREN?]{.red} ...

The microservice paradigm has no conception of an equal governance notion. This has some fundamental implications:

* message passing is not done in a uniform or bound way, such that channels have to be employed, their interfaces supported, and [delivery respectively monitored...]{.red}. Message distribution styles [müssen jeweils separat gemacht werden]{.red}
* fairness is a non-concern, thus scheduling delegated to the operating system(s)
* discovery requires custom silution

...

...orchestration and choreography (erst später beschrieben?)

...cloud management framework

...

This lack of governance also has some advantages:

* autonomy of services
* independent deployment

...

Not yet has been discussed the consequence on deployment:

* Actors müssen als ganzes System deployed werden
* MS können einzeln deployed werden, brauchen aber eventuell eine sequence

---

~Todo
(Partially) Centralized with Actor systems, decentralized with MS (aber was ist mit cloud management frameworks)
~

~Todo
Independent deployment
~

Autonomy:

~LitNote
* [@Bon17] 
    * "Isolation is a prerequisite for autonomy. Only when services are iso‐ lated can they be fully autonomous and make decisions independ‐ ently, act independently, and cooperate and coordinate with others to solve problems"
    * "Working with autonomous services opens up flexibility around ser‐ vice orchestration, workflow management, and collaborative behav‐ ior, as well as scalability, availability, and runtime management, at the cost of putting more thought into well-defined and composable APIs"
* MS: "components can be deployed separately" [@Mon16a]
~

~ end green
-->


### Scalability and Modularity


Their ability to *scale* is arguably one of the most relevant reasons given in the literature to utilize actor- or microservice-based architectures [@Tas13;@Hal09;@Mon16a;@Dra17c;@Sal16;@Che17;@Sal16;@Dra17b]. Based on the definition given by Bondi [@Bon00], *scalability* is an attribute influencing the performance of networks, systems and processes in general. From the cognition of industrial Erlang applications it has been suggested that scalability is more important than raw system performance [@Hal12]. Many different aspects influence scalability. From a concurrent point of view, any influence hindering parallelism has a negative impact. Examples are synchronization (cf.\ Java case study) and (temporal) deadlocks. The strong isolation and message passing principles of actors and microservices (isolated turn principle, avoidance of shared memory) reduce coordination and contention cost. Therefore, message passing and isolation have a positive influence on scalability capabilities by limiting safety and liveness issues [@Bon16].


#### Forms of Scalability


There are many different forms and classification approaches for scalability. Two merit attention here. *Load scalability* refers to a steady performance if the demand or work increases. *Structural scalability* refers to the ability of the topology to change the amount of components, in this case concurrent task units [@Bon00].

Two notions of scaling a system are relevant. *Vertical scalability*, or simply *scaling up*, refers to an increase of resource utilization, especially multiple cores and memory on a single host. Avoiding blocking and synchronization, as well as asynchronous messaging are the influencing factors. Actors conceptually support these requirements well, as long as the units refrain from blocking inside their turns. The microservice approach can meet the requirements also well, when services back asynchronous communication mechanisms and refrain from RPCs. In general though, the internal concurrency capability introduces the risk of facilitating potential hindrances of scaling up. Besides, the scheduling efforts of actor runtimes and operating systems aim for an optimal utilization of available resources [@Bac03]. *Horizontal scalability*, also *scaling out*,  *distance scalability* or *geographical scalability*, refers to the utilization of additional hardware resources (hosts). Distribution capability is the prerequisite. The uniform abstraction of concurrent and distributed execution of actors as well as the process nature of microservices combined with network IPCs provide the foundation to scale out [@Bon00;@Dra17c;@Dra17b;@AkkaMDR;@Agh99;@Tan07].

One approach to achieve scaling out is the concept of load balancing we have already discussed. Akka actors build upon the same conceptual ideas using the router constructs. They allow us to distribute work in various strategies, e.g.\ round-robin or broadcast. Round-robin is one example of a load distribution strategy. Server- and client-side load balancing is merely the distinction of a `Router`{language:scala} being utilized by the sending actor itself, or from an intermediate actor that is receiving the message initially from the sender and then applies the routing logic to select the actual recipient. The case of a dedicated routing task introduces an additional component `R`. When an `R` uses a load balancing routing logic, the component is conceptually equal to the load balancer `L` in the microservice architecture. In one way or another, load balancing is a valuable concept for both actors and microservices, e.g.\ to avoid overflowing mailboxes and timely responses to requests. Some task units are naturally well suited to be equipped with load balancing capabilities [@Mon16a;@Car17], e.g.\ Echo's API Gateway. The major difference lies in the trade-off that comes with load balancing in each model. As we've mentioned, a `Router`{language:scala} is a supervision-managed set of routees and therefore brings all obligations of actor supervision. Microservices are more loosely coupled and do not know the concept of supervison in general. Hence, load balancing for microservices does not come with additional obligations either.

A conceptual disadvantage is that by default load balancer do not know about the progress of potential recipients. Work is distributed regardless of the available capacity of the receivers. Load balancers can take work load metrics into account of course, as does for example the `SmallestMailboxRoutingLogic`{language:scala} of Akka. This routing logic aggregates the mailbox capacities of all routees first. With this information, the logic then forwards the message to the actor with the smallest mailbox. However, the information aggregation *before* a message is dispatched increases the overall processing duration [@Roe15;@All13]. 

Message queue channels (`Q`) are also a form of load balancing. As the receiving components actively pull messages from the queue when they have computation capacity, e.g.\ `W` &larr; `Q`, they distribute load among themselves based on their demand [@Cou05;@Dra17c]. Every Web Crawler, Parser, DirectoryStore and IndexStore in the MSA has therefore an inherent scalability advantage. Since the services are multi-threaded applications due to the thread-pools the IoC container of Spring uses, each microservice can serve several work requests simultaniously. All these services pull the work packages from the message queue when there is a free thread. The message queue buffers all messages until they are consumed. In contrast, actors get work in the form of messages pushed directly into their mailbox. Message router units (`R`) do not buffer message, but distribute them immediately.  Mailboxes are limited in size [CITATION?]{.red}, therefore every mailbox runs into the risk of mailbox overflow, if over a period of time its actor takes longer to processes messages than it receives in the same amount of time.   


#### Dynamic Reconfiguration


*Dynamic reconfiguration* relates to a change in a system's topology at runtime. Task units can be added, removed or relocated divergent from the static initialization configuration [@Agh85b]. Actors support dynamic reconfiguration inherently through the primitive allowing actors to spawn new actors. We already demonstrated this ad hoc instantiation with the dynamically created response handlers `H` spawned by Searchers. The loose coupling of microservices also provide support for changing topologies in principle. Service registries and asynchronous messages through intermediate message queues provide the foundation. Reconfiguration greatly effects scalability, because it increases the optimal utilization of hardware resources [HIER HAB ICH IRGENDWO EINE PASSENDE REF -- GANZ SICHER!]{.red}.

A general prerequisite for dynamic reconfiguration is location transparency. Both actors as well as microservices have sophisticated solutions. Two additional properties, *mobility* and *elasticity*, become possible as a result. Mobility refers to the relocation of components between nodes [@Agh99;@Kan12;@Tan07]. Elasticity is a form of scalability summarizing the ability of a system to scale the number of components dynamically depending on the current demand, thus improving its load scalability. We can scale actors and microservices in a non-uniform way due to their component properties. Each individual component type allows us to instantiate it many times without having to duplicate the residual as well [@Dra17b;@Dra17c].

The requirements in Section [#sec-scenario] explicitly state that neither mobility nor elasticity are concerns for Echo [TODO das muss ich noch wirklich dort hinschreiben]{.red}. However, the general approach is conceptually identical, therefore we present a short outline. We are able to created and terminated stateless task units easily on demand (elasticity). Since these units have no state that requires relocation, this reconfiguration also doubles as mobility. Strong mobility that requires the migration of state is not provided by Akka, but other runtimes like Orleans do provide state migration [@Ber14]. Stateful Stores are a bigger concern. In general, when we (re-)created a stateful unit, it is not safe to assume that its persistent state (database, reverse index) is up to date. Therefore, the state has to be updated with regard to all outstanding modifications. *Event sourcing* is a convenient concept which persist all modifying commands to Stores in a so-called *event logs*. A new or reactivated Store can request a history of modifications prior to the units existence. Message brokers have the potential to double as event logs. Kafka offers optional persistence support for messages. Akka's *Persistence* module is also convenient to introduce persistence of routed messages into the broker units. In both cases, it is within the obligation of the Store units to persist a counter or reference to the last received event separately. This reference is required to determine the required partial history.

In general, we deem the concerns related to dynamic reconfiguration more easily met with actors. Spawning new units is a core concept of the basic model primitives. Microservices themselves have no general notion of other services beyond interaction. We need an additional layer to manage changing topologies. *Cloud management frameworks* are a category of tools that seem convenient. Therefore [???]{.red} is a fundamental difference in the inherent notion of static versus dynamic changes in topology. This difference is a major concern when it comes to integrating actor and microservice task units. We will briefly outline an approach for integration in Section [#sec-actor-ms-integration].


#### Extensibility and Technology Diversity {#sec-technological-heterogeneity}


Another result of the dynamic reconfiguration property is that actor and microservice architectures are also open for extension. In contrast to dynamic reconfiguration, where instances of existing task units are added or removed, we use *extensibility* to refer to the introduction of either new versions of existing components (update) or new components entirely (addition). There are two different kinds of extensibility [@Agh85a;@Bac03]:

* static, where the architecture's code is adapted, recompiled and then redeployed
* dynamic, where a new component is added to the architecture at runtime

The independent deployment capability of each single service engine allows us to simply add new components at runtime. The reconfiguration does not impact existing services, as they are not yet aware of the new component. New services can simply consume existing services. We can then gradually update old services and have them consume a new component, therefore integrate the addition deeper into the architecture [@Mon16a].

Actors are faced with more challenges. Every actor requires an actor system to exist within. Erlang and its runtime system were tailored to support actors. As a result, the *BEAM* virtual machine supports code loading and replacement for live upgrades [@Vin07;@New15]. The JVM does not support similar features. Therefore, Akka requires the restart of the system to introduce new kinds of actors. All actors are defined in the same program structure. Subsequently, the actors are compiled to a single monolithic executable, which limits Akka actors to static extensibility. In a clustered setup however, it is not required to introduce a new component into all cluster nodes at once. Therefore, the cluster is able to retain its uptime, while we upgrade and redeploy the individual nodes. Besides differences in the VM optimization, Erlang's upgrade strategy is conceptually similar. The BEAM does not support the replacement of a single actor, but merely of entire code modules [@New15]. 

Another interesting concern is the technology limitations regarding the conception of new components. An actor is bound to its runtime, which is free to provide interface bindings for numerous programming languages, e.g.\ as Akka does for Java and Scala. We are able to use the Java binding from other JVM languages as well, as [@Sub11] demonstrated for Groovy and JRuby. However, we cannot overcome the JVM as the target platform. Interoperability with Akka.NET would broaden our possibilities, but to our knowledge interoperability has never been available yet.

The strong memory boundaries and open communication interfaces of microservices provide a whole different level of flexibility. We can conceive a service using every programming language and technology we desire, as long as the tools are able to interact with the communication channels.

Echo facilitates Java and the Spring framework for all task units, but each service could also have been written using distinct technology stacks. Even now, existing services can be replaced by new versions using new technologies.   


#### Eventual Consistency and Availability

~ lit

Für Safety & Liveness Argumente:

* [@Bai13] "Eventual consistency today- limitations, extensions, and beyond"

Aus der Wikipedia:

* "eventual consistency is purely a liveness guarantee (reads eventually return the same value) and does not make safety guarantees: an eventually consistent system can return any value before it converges"
* "Whereas eventual consistency is only a liveness guarantee (updates will be observed eventually), strong eventual consistency (SEC) adds the safety guarantee that any two nodes that have received the same (unordered) set of updates will be in the same state"
* "Clusters which provide "lazy" redundancy by updating copies in an asynchronous fashion are called 'eventually consistent'"
~


The literature frequently points out that, due to their asynchrony and distribution, both actors and microservices are bound to a weak notion of data consistency generally referred to as *eventual consistency* [@Agh14;@All13;@Dra17c;@Bon16;@Fow14;@Bon17]. Eventual consistency describes an informal (!)\ guarantee that in the absence of mutating data operations, all access to a dataset will produce the same result at some point in time eventually. Consequently, until this point in time, the data state across tasks is in flux and can therefore produce varying results. 

~ todo
Hier möglichst bald der Hinweis das Eventual Consistency notwendig/positiv für Scalability ist. Um zu begründen wieso das hier ein Unterkapitel ist
~

[Example]{.example-title}: Echo suffers from inconsistency regarding the data store units. The state of all Indices is inevitably behind of the Catalogs, since Parsers send data to Catalogs. After performing updates and registering new episodes, the Catalogs forwards the new information to the IndexStores (broadcast). This is of course only true for the original recipient of the Parser data. An update to one Catalog must subsequently be also broadcast to the residual Catalog instances. Eventual consistency reduces the guarantee for consistent data to a guarantee that all data updates will be propagated to all data replicas [@Tan07]. Informally, we can observe that every form of exclusive state ownership combined with an asynchronous communication model without a transaction abstraction on top will introduce some form of eventual consistency into a system [@Bon17]. Eventual consistency is therefore inherent to all actor architectures. Due to the *at-least-once* delivery guarantee given by RabbitMQ, this weak form of consistency is also part of Echo's microservice variant.

~ todo
Hier würde eine Grafik helfen.
~

In contrast, requiring strong consistency is extremely difficult. Consistency essentially constraints the order of read and write operations on data [@Mah11], in this case from a global point of view. Software transactional memory is a prominent mechanism to achieve global orders. As we've pointed out, Akka did drop its transaction support for the performance impact in a local context alone. Additionally, Akka never achieved to extend transactions to remote actors. Microservices are faced with even more challenges. There is no inherent base system available to provide transactions. We must integrate the complience to an appropriate mechanism on an individual per service basis.

The constraints required for maintaining strong consistency relate to safety [@Mah11]. A weakening of these constraints therefore reduces safety. In return, eventual consistency within a system has a positive effect on a specific liveness property, that is *availability*. Basically, availability relates to a system's responsiveness when requesting functionality. A consistency mechanism in general restrains this responsiveness. Informally, availability demands that all read and write operations complete. The sooner they complete, the more available the system is.

~ todo
KANN ICH AVAILABILITY IRGENDWIE MESSEN? DAS WÄRE EINE GUTE PRAKTISCHE TABELLE HIER, DIE DAS KAPITEL RECHTFERTIGEN WÜRDE...
~

Table [#tab-scalability-compatibility-matrix] summarizes the capabilities for each scalability variant provided through Akka and Spring.

~ Begin Center
~ Begin TableFigure { #tab-scalability-compatibility-matrix; caption: "Capability matrix of scalability variants of Akka actors and Spring-based microservices"; page-align:here; width:100%}
|------------------------|-----------------------------------|---------------------------------|
| Scalability Form       | Akka                              | Spring MSA                      |
+------------------------+-----------------------------------+---------------------------------+
|                        | Very efficient resource           | Limited by the synchron-        |
| Vertical scalability   | utilization if no blocking        | ization of the internal service |
|                        | inside actor                      | concurrency (STM)               |
| -----------------------|-----------------------------------|---------------------------------|
| Horizontal scalability | Akka cluster                      | Requires network IPC            |
| -----------------------|-----------------------------------|---------------------------------|
| Load scalability       | Server-side load balancing        | Client-side load balancing      |
|                        | with routing logic                | with Ribbon, message queues     |
| -----------------------|-----------------------------------|---------------------------------|
| Structural scalability | Location transparency             | Requires discovery mechanism    |
|                        | inherent in actor addresses       | for location transparency       |
| -----------------------|-----------------------------------|---------------------------------|
| Dynamic                | Inherent through basic            | Requires service registry for   |
| reconfiguration        | model primitive                   | integration                     |
| -----------------------|-----------------------------------|---------------------------------|
| Mobility               | Weak mobility (no relocation of persistent state of Stores)        ||
| -----------------------|-----------------------------------|---------------------------------|
|                        | Requires resource control         | Requires appropriate cloud      |
| Elasticity             | of cluster (see [ref]{.red}), not | management framework,           |
|                        | supported by Echo                 | not supported by Echo           |
| -----------------------|-----------------------------------|---------------------------------|
{ width:100% }                               
~ End TableFigure
~ End Center


<!--
### Fault Tolerance and Resilience

~ todo
Hier werden die unterschiedlichen Asnätze und Möglichkeiten für Fault tolerance (zB durch Supervision) und der Resilienz einzelner Komponente (Circuit Breaker, etc.) evaluiert.
~

~ begin green

~ todo
__WAS IST DER UNTERSCHIED ZWISCHEN FAULT TOLERANCE UND RESILIENCE?!__
~

Fault tolerance:

~LitNote
* "failure isolation"
* [@Myt17] "Handling partial failures in distributed reactive programming"
* [@Tan07] "Distributed Systems: Principles and Paradigms, 2/E"
    * 8.1 INTRODUCTION TO FAULT TOLERANCE
    * 8.2 PROCESS RESILIENCE
* Actor Supervision kann A. leicht neu starten wenn Fault, MS i.A. nicht. Andere MS müssen gegen einen Ausfall eines benötigten Services __resilient__ sein. Aber keine automatische tolerance das der MS ersetzt wird. Benötigt wenn dann cloud management framework support dafür
* [@Cou05] "Distributed Systems: Concepts and Design"
~

...

The message passing communication style facilitated by both Actors and Microservices brings common 

...

Resilience:

~LitNote
* "ability to heal from failure" -- break free from strong coupling of synchron comm.; circuit breakers
* Location transparency, elasticity = "move around in isolation"
* independent failure of components
~

Availability:

~LitNote
* Actors, siehe: [@Agh85b]
~

~ end green
-->

<!--
## Separation of Concerns and Single Responsibility

~ todo
Hier soll evaluiert werden, wie weit Actors und Microservices wirklich Concerns separieren und entsprechend nur eine Responsibility habe (MS müssen sich zB um deutlich mehr Nebensächlichkeiten selber kümmern; bei Akka sind Dinge wie Supervision inherent gefordert aber relativ gut abgetrennt von der Message-Verarbeitung)
~


~ begin green

*Separation of Concerns* (SoC) is ...


The actor model as well as the microservice paradigm facilitate isolated and decoupled components.  

...

Hürsch & Lopes [@Hur95] define two levels regarding SoC: the *conceptual level* is concerned with the identification and differentiation of concerns, while the *implementational level* ensures their isolation.


~ lit
* routing concern is outsourced to router actors, MQ, broker
* actors geben viele concerns an das actor system ab (scheduling, discovery), MS müssen sich im discovery selber kümmer (auch in eigenen single-responsible services) und scheduling an das OS
* linguistically conceived Microservices can emphasise a good SoC between behavior and deployment, as the Jolie syntax structure demonstrates.
~


---

Separation of Concerns:

~LitNote
* [@Weg90] "Concepts and Paradigms of Object-Oriented Programming"
    * "Splitting a large task into components is a time-honored method of managing complexity, variously referred to as "divide and conquer" and "separation of concerns"."
* SoP between behavior and deployment part of Jolie programs, siehe [@Mon14;@Gui17]
* Supervision and fault isolation -> good SoC [@Roe15], for "normal" messaging and supervision orthogonal and can evolve separately
    * failed children can be re-created from its `Props`{language:scala}, such that supervisor don't need special knowledge about their instantiation (argument, etc)
* IoC generally facilitates SoC 
    * actor systems ähneln IoC container
    * Spring MS sind intern via IoC, dh intern gutes SoC 
* [@Hur95] gibt als concerns an (all diese sind hier -- unter anderem namen auch besprochen!):
    * synchronization &rarr; avoided in Actors; maybe required internally in MS, Echo uses STM
    * location control 
    * real-time constraints &rarr; easy RPC with MS by using adequat comm. channel, more challenging with Actors, though ask-pattern, e.g.\ new components like response handler can be required, which then separate the concern nicely
    * failure recovery &rarr; there are ways, but how compare them?
* Good SoC in Jolie of behavior and deployment [@Gui17 ]
~

The strict encapsulation of state offers the opportunity to introduce multiple persistence strategies, without having an impact on the architectural layout. There is a more general concept to describe this form of modularization, called *Separation of Concerns* (SoC).

Having state strictly encapsulated, up to  

...

... both Actors and Microservices provide a good basis to facilitate a clear separation of concerns due to their strict notions of high cohesion and loose coupling. However, as with many abstractions, SoC is merely [a best practice / a goal ... and cannot be enforced or demanded in any way]{.red}. Services can be assigned as many concerns as wished, and Actors can also receive any kind of message, making them potential targets to all sorts of requests and jobs [FURCHTBAR FORMULIERT, aber richtige botschaft]{.red} 

---

Though both facilitate a good separation of concern, we've found that the scope of (single) responsibility is divergent. More precisely, the notion of scope variates. Actor systems free their constructs of minding many concerns. Examples are the discovery mechanism resulting from transparent addresses, or the supervision concept. The rather loosely principles of Microservices on the other hand burden them with minding many cross-cutting concerns. Dedicated services solely concerned with providing discovery, and clients ensuring to facilitate these mechanisms are required. Also, neither have they an intrinsic behavior nor an appropriate communication protocol of supervision in place. If such is desired, every service has to explicitly concern itself with supporting it with regard to its respective technology stack.


...

Single Responsibility:

~LitNote
* Unix philosophy
* [@Bon16]
* [@Bon17] "This idea was later brought into the Object-Oriented Programming community by Robert C. Martin and named the Single Responsibil‐ ity Principle2 (SRP), which states that a class or component should “have only one reason to change"
* "functional separation" [@Sal16]
* single responsibility ist ein gutes beispiel, wieso man exlusive datenbanken gut gebrauchen kann
* [@All13] actor "single responsibility principle"
~

Thus, in general we've found Actors to provide an easier abstraction to facilitate single responsibility, for the model primitive allowing to spawn new Actors on demand encourages the outsourcing of responsibility into dedicated Actors. A good example are the dynamically created response handler Actors for each search request that wait on an asynchronous response substituting for a Searcher.

Microservices on the other hand offer less incentive to encapsulate each distinct responsibility inside a dedicated task unit. Each conceived service is by design a dedicated program, thus entails all resulting challenges ranging from the obligation of maintaining an its own separate codebase up to the additional deployment considerations.

~ end green
-->


### Integrating Actors and Microservices {#sec-actor-ms-integration}


So far, our evaluation has shown that we can express the same capabilities with both actors and microservices. State is isolated, communication is open for a wide range of interaction styles, and the execution modality enables parallelization and distribution in a transparent way. The major benefit of all these capabilities is a high degree of modularity as well as great flexibility for scalability. Each models brings its own set of trade-offs, and we as programmers must accept one of these sets in order to leverage the capabilities.

As a final capability evaluation, we want to reason whether all these properties enable actors and microservices to be flexible enough so we can integrate both kinds of concurrent tasks. We've already seen that the combination of concurrency models is a common and important practice. Actors often incorporate futures, and microservices use and mix arbitrary concurrency constructs internally. We will entertain this integration thought first with some theoretical considerations and then discuss the practical approach regarding Akka and Spring.

As we've discussed, there are two kinds of correctness properties: safety properties and liveness properties. Safety and liveness must not be weakened by combining two concurrency models. There are also two approaches to assess the correctness of a computation: testing and verification [REF?]{.red}. From a theoretical point of view, we can violate every safety property by a finite execution. Hence we can test for safety at runtime. On the other hand, liveness properties cannot be violated by some finite execution in general, and even if an arbitrary finite execution causes a violation, there is some continuation of the same execution for which the property will still hold eventually [@Siv99]. Thus, we cannot test for liveness at runtime. This theoretical limitation raises the need for other concepts to either guarantee or at least inspect the liveness of tasks. We require strict theoretical frameworks to apply formal verification techniques. For actors, the theoretical actor model provides this framework. However, we've seen that the microservice model is defined by rather pragmatic rules in comparison. We yet lack a formal framework.

<!--
~ todo
Ein paar einführende Worte
~

We've discussed the programming models of actors and microservices, and compared the capabilities that can be expressed by each model. One the one hand, actors are based on a theoretical model. Runtime systems implement various aspects differently and can even choose to weaken certain aspects intentionally. We've pointed out differences of Erlang and Orleons compared to Akka. Nevertheless, all actor systems still need to comply to the basic theoretical model. 

Microservices, on the other hand, are not bound by a theoretical framework. Their construction is lead by a set of paradigm rules. 


...

However, we would like more theoretical boundaries for our programming models. Since we are regarding the programming of concurrency, we are also interrested in the correctness. As we've discussed, there are two kinds of correctness properties: safety properties and liveness properties. 

In general, there are also two approaches to assess the correctness of a computationn: testing and verification [REF?! - irgendwo muss da schon ein satz wo stehen]{.red}.

From a theoretical point of view, any safety property can be violated by a finite execution, hence they can be tested for at runtime. On the other hand, liveness properties cannot be violated by some finite execution in general, and even if an arbitrary finite execution causes a violation, there is some continuation of the same execution for which the property will still hold eventually [@Siv99]. Thus, liveness cannot be tested for at runtime, which raises the need for other concepts to either guarantee or at least inspect the liveness of tasks.
-->

~ lit
* [@Eyt07] "Towards a framework and a benchmark for testing tools for multi-threaded programs"
    * Model checking is a family of techniques, based on systematic and exhaustive state-space exploration, for verifying the properties of concurrent systems. Properties are typically expressed as invariants (predicates) or formulas in a temporal logic. 
    * For concurrent programs, escape analysis,suchas [14], is used to determinewhich variables are thread-local and which can be shared. This information can be used to optimize the model or to guide the placement of instrumentation used by dynamic testing techniques.
    * Race and deadlock detection: A deadlock is defined as a state where, in a collection of threads, each thread tries to acquire a lock already held by one of the other threads in the collection. Hence, the threads block each other in a cyclic manner. Tools exist that can examine traces for evidence of deadlock potentials [42,43]. Specifically, they look for cycles in lock graphs.

~

#### Actor Model and Process Calculi


Among the theories of formulating concurrent computation we find a family called *process calculi* or *process algebras*. These calculi define formal models composed of so-called *processes*[^fn-process-concurrency-theory] which are communicating within the laws and conditions laid out by their theory. Baeten [@Bae05] defines *process* as any kind of *behavior* of a *discrete event system*, such that it is observable through discrete actions. These actions can include interactions with other discrete event systems. The other systems then have to react to the interactions. Therefore, Baeten terms all interacting systems as *reactive systems*, which is the base for parallel and distributed computing. As a result, one approach towards concurrency theory is the path of a process algebras.

[^fn-process-concurrency-theory]: These are the processes of concurrency theory we've mentioned before. They must not be confused with operating system processes.

Some process calculi gained considerable prominence. Examples are Milner's *Calculus of Communicating Systems* (CCS) [@Mil80] for having been the initial work in this domain, while Hoare's *Communicating Sequential Processes* (CSP) [@Hoa78] were the first to introduce message passing instead of global variables for process communication. For our considerations, the *&pi;-calculus* [@Mil92], also by Milner, merits special attention. The &pi;-calculus has a notion of process networks, including mobility and dynamic reconfiguration [@Bae05;@Mon97]. 

Much work has been done on the field of process algebras, since they allow us to express a theoretical basis for arbitrary domains and requirements. In fact, more practical approaches to express interacting processes frequently have their foundation in a process calculus. Some were also found to be well suited to express microservices. The Jolie language for example is based on a calculus dedicated to service-orientated computing called *SOCK* (__S__ervice __O__riented __C__omputing __K__ernel) [@Gui06]. In turn, SOCK is inspired by CCS and the &pi;-calculus. This relation of process algebra and microservices is especially interesting, since the actor model and process calculi share a long history. Hewitt & Milner published their initial works on the actor model and CCS in the same year, respectively 1973. Since then, these two approaches have mutually influenced and inspired the scientific development of each other. A fitting example are the *Asynchronous Sequential Processes* (ASP), which bear close resemblance to active objects, yet with a more coarse granularity [@Kos16]. 

Scholars have long tried to formulate a theoretical link between actors and various calculi, with mixed and mostly limited success. To our knowledge, to most promising approaches in the literature so far have merely succeeded at describing interoperability between actors and calculi showing strong similarity. For example, Montanari & Talcott [@Mon97] demonstrate the cooperation of actors and agents of the &pi;-calculus. 

As Agha *et al.*\ [@Agh97] discuss in an extensive work, a true equivalence theory among a formal *actor calculus* and some process calculus requires the formulation of a *simulation relation* among the primitives. This has been done among different process calculi but is yet unfound regarding actors. They state as the foundational challenges:

> "Three points of contrast between the basic actor model and process calculi are: the choice of communication model, the choice of communicable values, and the issue of fairness."

Note that we have discussed these issues as concerns in varying degrees throughout this thesis. For example, we've pointed out that actors assume fairness, while microservices pay fairness no concern and simply delegate it it to the operating system scheduler. 

Eventually, Agha *et al.*\ argue that instead of trying to find an analogy between an actor- and a &pi;-calculus, it is expedient to engage in the definition of high-level semantics for programming languages. Then, we are able to reason about program equivalence of actors- and &pi;-programs. 

<!--

...

A most basic argument towards the linkage is the definition of a process in the calculi context given above. It explicitly referes to a notion of behavior, respectively discrete actions. 

... Actor have the intrinsic own notion of behavior together with the models Isolated Turn Principle suffices

...For Microservices we explicitely distinquished between the *engine* and the *behavior*, where the later referes to the "service" an engine offers. Each offered is from a global viewpoint a discrete operation whenever consumed [komisch formuliert, und ka was ich dazu zitieren soll]{.mind}.

...

It is important to realize that there is only one theoretical Actor model with many different implementations (Actor Systems) varying in terms of concrete features and capabilities, through all of which are still founding on one common theoretical model. On the other hand however, there is not one process calculus as a single foundational theory, but a large variaty of calculi instead. All are distinct in some way or another in terms of process traits and communication semantic. Thus, only a specific calculus can be compared to the Actor model at a time in general. Such has been done throughout the literature many times [hier gleich einen haufen zitate?]{.important}. 

... For example...We've found that especially ASP (__A__synchronous __S__equential __P__rocesses) have been discussed in the light of Active Objects [@Kos16].

... Especially the ASP (__A__synchronous __S__equential __P__rocesses) have many similarities with Active Objects as well as another special variant of Actors of the so-called *Communicating Event-Loop* model [@Kos16;@Car04, Car04 könnte ich mir sonst als REF generll ersparen!].

...

...Some calculi have been known to show such similarity to Actors that interoperability has been described in the literature. For example, Montanari and Talcott [@Mon97] demonstrate the coorporation of Actors and agents of the &pi;-calculus.

...

In a classification of concurrency model, Swalens et al. summarize all abstractions avoiding shared memory and using structured message-passing instead as *communicating threads* [@Swa14]. [ja und jetzt...?]{.important}

...

...We refere to [XYZ]{.important} for a detailed introduction on process calculi in general.

...

~LitNote
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi>
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
* Wenn ich es im MS kapitel schaffe mir was zu Process Calculi zu überlegen, gibt es genügend 
* [@Kos16] vergleich Asynchronous Sequential Processes (ASP) mit Active Objects, nur mit gröberer Granularität
* [@Kos16] beschreibt das die sog. "Communicating Event-Loop Actor Model" ähnlichkeiten zu Asynchronous Sequential Processes (ASP) hat
* [@Car04] "Asynchronous and Deterministic Objects"
    * describes implementing ASP as Active Objects
    * "Relying on the active object concept, the ASP model is rather closed to, and was somehow inspired by, the notion of actors [2, 3]."
* [@Agh97] "A foundation for actor computation"
    * beschreibt ebenfalls den zusammenhang von Actors und Process Algebras (pi-calc., ect.), auch in einem historischen context.
* Punt: "Type Specications with Processes" <http://www.complang.tuwien.ac.at/franz/papers/Punt95a>
    * Hier beschreibt er wie er Process Types (was Typen von Processen eines Process Calculus sind) verwendet um das Actor model abzubilden. Dürfte sich sehr eignen!
* Punt. forschte daran wie man mit Prozess Typen (und somit in Process Calculi?) modellieren kann, das zu gewissen Zeiten nur gewissen Nachrichten akzeptiert werden. Das "become" Primitive von Actors kann ebenfalls dazu verwendet werden, um die Menge der Messages die ein Actor gerade verarbeiten kann zu verändern (also die Typen für die eben ein Verhalten definiert ist). Dh das ist im Prinzip das selbe
    * beste quelle? Punt: "State information in statically checked interfaces"    
    * Punt: "Types that reflect changes of object usability"                                             
~

-->

#### Combining Akka Actors and Spring Microservices {#sec-combining-akka-spring}


Our Echo microservices are not founded on a process calculus since we have not implemented them in a SOP language like Jolie. Since there is no known theoretical link between the actor model and a SOC calculus, we are not able to reason about the correctness properties after integration anyway. Nevertheless, we've seen that scholars are motivated to describe interoperability between actors and calculi processes. Therefore, we can still think about the approach to integrate the our Akka actors and Spring-based microservices. From a theoretical point of view, two concurrent units are required to share a communication channel in order to interact [@Agh97]. 

The microservice principles allow the services a rather high degree of freedom regarding their communication. REST-based state transfer via HTTP is a popular choice. We've demonstrated that other channels like AMQP queues are also viable. Actors, on the other hand, are more restricted, since the model semantics requires them to receive the *message* constructs in a uniform way. By implication, this restriction means that different communication channels can be utilized as long as they comply to a homogenous message receiving abstraction.

*Akka HTTP* [@AkkaHTTP] is part of the Akka library collection. It provides a full client- and server-side HTTP stack on top of the basic actor construct. Thus, HTTP requests can be received as messages, just if they were sent by another actor: 

```{language:scala}
override def receive = {
  case SomeMessage(_)                           => // handle message
  case HttpResponse(status, headers, entity, _) => // process response
}
```

Actors are identified by their unique address. This address is specific to a concrete actor system and not conform to a URI (__U__niform __R__esource __I__dentifier) as is required by HTTP in general. We must utilize an integration layer between a HTTP-addressable unit and the actual actor [@AkkaHTTP]. 

Though this style of receiving messages is in principle conform to the actor abstraction, there are certain limits. By implication, HTTP endpoints also do not comply to actor addresses in general. The standard *send* mechanism through `tell` and `ask` is therefore not applicable to dispatch HTTP requests. We require an alternative interface:

```{language:scala}
Http().singleRequest(HttpRequest(URI(s"http://example.com")
  .withQuery(s"name", s"value"))
  .pipeTo(self)
```

The example uses `pipeTo` to have the integration layer reroute the response as an `HttpResponse`{language:scala} message to the sending actor (delegation).

We see, not all the basic actor primitives are suitable to be used outside the actor construct. However, well introduced abstractions like Akka HTTP allow actors to provide their *actor behavior* to the outside in a microservice-like *service behavior* fashion. Communication between actors and microservices is possible in principle. Hence, we can construct systems where tasks are distributed between actors and microservices.  

The general integrationn idea is not novel. We've mentioned the theoretical foundation from [@Mon97] for incorporating actors and agents of the &pi;-calculus. There too, so-called *actor-&pi; coordinators* are used to translate between communication channels, similar to the integration layer of Akka HTTP. However, interoperability is merely a concern of static configuration, because processes have only a static notion of interconnection topology in general. This static notion violates the dynamic reconfiguration inherent to actors [@Akm90;@Agh85b]. In order to overcome this limitation, bridge technologies like service discovery are utilized in microservice architectures. Hence, we require actors to integrate into this discovery mechanism, effectively rendering each actor into a mere microservices. This unified approach isn't quite common yet, but technologies are starting to emerge building on this idea. An example is the *Lagom* [@LightbendLagom] framework, a reactive microservice system framework built on top of Akka.


~ Findings
[Main findings]{.findings-title}

+ Process calculi provide the theoretical frameworks for formal microservice specifications and service-oriented computing languages.
+ The theoretical link between actors and process calculi is yet an open scientific question.
+ Actors and microservices can still be integrated without a formal basis. However, the correctness properties of the models are then not ensured anymore.
{.findings-list}
~


<!-- TODO Section ist fertig, aber am 22.8.2018 testweise deaktiviert

#### Design by Contract {#sec-design-by-contract}


Integration of actors and microservices does not only require a communication channel, but also messages that are understood by sender as well as receiver. This requirements is also true among actors and among microservices. We've mentioned that received actor messages are inherently dynamically typed, and thus sending messages is often weakly typed. We can strengthen this typization by type-restricting the send operation. Akka achieves this restriction by introducing a type parameter into the actor address. However, there is no guarantee that an actor has an appropriate behavior for a message sent to it at the moment the recipient processes this message. Also, there is no general guarantee of message compatibility between microservices. REST- and AMQP-based communication merely enforces well-formated XML or JSON documents. Serializers and deserializers on the sending and receiving ends guarantee correct marshalling. Yet nothing restricts that only messages are sent that will be understood by the receiver. Just as with actors, message compatibility is checked dynamically at runtime upon reception. Hence, ensuring compatibility in actor- and microservices-based programming is an obligation of the programmer. 

---

Yet from a theoretical point of view, there is the potential for more sophisticated solutions. From here on, we briefly endeavor into subjects for which actors and microservices offer rather basic capabilities at best. Two concerns that we will merit attention here are static contracts between task units in general, and behavioral types in particular.

We've evaluated the capabilities and notions regarding concerns like isolation, decoupling, location transparency, mobility and [independent deployment (-> weggefallen?)]{.red}. All of these concerns facilitate dynamic change in the system topology (dynamic reconfiguration) [@Agh90;@Dra17a]. On the one hand, we can simply add new components and announce them via respective contextual mechanisms. On the other hand, we can *substitute* existing components by others (subtypes). Fowler & Lewis even give independent replacement and upgradeability as key properties of microservice architectures [@Fow14]. However, evolution within a system must not break the interface compatibility between the components. Otherwise the system inevitably breaks. This constraint raises the question of interface compatibility, and particularly the validation of it.

We can generally regard an interface as a contract between a client (caller) and a server (callee). The contract regulates the client-server interaction regardless of their implementation [@Sin09]. Besides respecting data type restrictions, the caller must comply to the *preconditions* of the callee when issuing its services. In terms, the server guarantees to fulfill its *postconditions* when returning a result. Meyer named this principle *design by contract* (DbC) [@Siv99]. It is a foundation of *defensive programming*, since it increases the possibilities of components to protect themselves. A pioneer and prominent example is the *Eiffel* programming language. Eiffel was built aroumd the idea of design by contract to aim for a correctness-by-construction notion of objects [@Mey97;@Maz16].

However, design by contract is generally more difficult in concurrent and distributed contexts. Clients cannot know when a server will actually start the execution upon receiving a message. Therefore, clients cannot unilaterally guarantee that the preconditions are holding in this particular moment. This issue is called the *concurrent precondition paradox* [@Siv99;@Mey97]. For postconditions exists an equal phenomenon. Postconditions merely hold in the moment a result is returned from an interface, but the respective recipient can receive the result at a later point in time in general.

Nevertheless, interface compatibility -- regardless of how strict the notion is perceived -- is required for new components and versions thereof. New subtypes are not completely free regarding changes. Subtypes must meet the *substitution principle* by Liskov & Wing [@Lis94;@Hut16]. The principle states that `S` is a subtype of `T` if an incarnation of `T` can be safely replace by any incarnation of `S`, i.e.\ `S` respects the contract promised by `T`. An actor or microservice can consequently be substituted by another if the new component abides the contract of the old, such that the system retains its behavior [@Hut16]. 


#### Contract Verification Mechanisms


Component substitution in actor systems can take the most basic form of behavior replacement. This primitive does not affect an actor's address. The instance defined by the new behavior transparently replaces the old. As a result, the new actor can receive the same kinds of messages as did its predecessor but fail to provide an appropriate reaction because of the new behavior. Thus, reasoning about actor systems is hard in general. The characteristic of actors to interpret every message at runtime through its behavior makes message acceptance and rejection an intrinsically dynamic effect. [sollte ich was zitieren -- stimmt das überhaupt so wie ich das hier behaupte?!]{.mind}

Microservices too are free to implement dynamic changes if they choose to. We also require the service behavior to comply to the substitution principle when we replace the service engine. When it comes to verify compatibility, we are hindered by the freedom in technology heterogenity offered by the microservice paradigm. Different technologies (programming languages and framework) and communication mechanisms (e.g.\ REST and AMQP) have different means of support for expressing contracts. There is beither a guarantee that any kind of compatibility checking tool is available nor compatible with a verification toolchain [@Dra17a]. 

An attempt towards a solution can be the utilization of a neutral tool with regard to languages and technologies. For example, *Apache Thrift* [@Sle07] provides an independent format to formulize data types and interface specifications. Thrift then generates static code in various supported languages. We can use the generated code to implement communication ports. Subsequently, the ports can serve for applying static type checking regarding the well-defined interfaces. Channel protocols are however not incorporated [@Dra17a].

Static compatibility checking is of course not possible for dynamically typed languages. MSAs are often implemented with a mixture of static and dynamic programming languages. The common denominator fallback is then is informal documentation in natural language [@Dra17a]. A solution is to revert to general neutral specification formats. In SOA, web services publish their interface descriptions in a standardized format and in a discoverable way. Most prominent among the standards is WSDL (__W__eb __S__ervices __D__escription __L__anguage) [@Anc16].

*Invariants* are another concern. In contrast to pre- and postconditions, invariants must hold in each computational step [@Mey97]. In the intrinsic context of distributed systems, concepts for verification so far build on post facto analysis approaches, e.g.\ via error log analysis and randomization testing. Error log analysis turned out to be promising for asserting liveness of services. For safety properties, Panda *et al.*\ [@Pan17] proposed a microservice-specific invariance model called `ucheck`. This model is capable of detecting violations at runtime, but at the cost of limiting the communication channels within the architecture to request/reply-styled remote procedure calls.

Dedicated programming languages for service-oriented programming like Jolie open up the possibility to check contracts through stricter restrictions regarding the definition format of service interfaces. Static type checking, at least among the components written in Jolie, is applicable without breaking the requirement of open and well-defined interfaces [@Min17]. Process calculi are already formal definitions. They are in general more restrictive than the rules of the microservice paradigm. This restrictiveness is the foundation for even stronger reasoning. If a language is based on a calculus (recall that Jolie builds upon SOCK), we are able to verify more than interface signature compatibility. One example is the sequence of component activation. 


#### Behavioral Types


Guidi & Montesi [@Gui09] define three kinds of interfaces: functional (distinguished by a name, input and output), work-flow (requiring a valid sequence of interactions) and semantic (offering semantic information about functionality through some ontology). The previous section discussed contracts of the functional kinds, which address safety properties with pre- and postconditions [@Lis94]. This notion of design by contract is fundamentally limited in its capabilities regarding liveness properties. Compatibility specifications regarding liveness must also concern the behavior, that is the sequence of actions. *Temporal logic* is the theoretical foundation for incorporating liveness [ @Siv99].  

Actor and microservice systems require their components to be interoperable in order to ensure reliability and correctness. The mere compatibility of formally defined functional interfaces is not incorporating sufficient information in general. We need to regard interaction protocol information to be able to ensure compatibility for communication-centered concurrent and distributed system components [@Sin09]. Message exchange has an influence on internal task unit states. A precise message order can therefore be required [@Anc16;@Dra17a]. The mentioned work-flow interface kind incorporates this information into the typization. Work-flow interface are generally subsumed as *behavioral types* [@Anc16] and of high interest regarding concurrent execution. Behavioral types have the potential to prevent safety and liveness issues [@Hut16]. The fact that this variant of type specifications have an effect on liveness is especially relevant, because liveness properties cannot be tested for at runtime, as has been discussed.

Within the context of actors, scientific exploration of static constraints on actor behaviors replacements regarding method availability (message acceptability) has already been done [@Hut16]. The type-bounded behaviors of Akka Typed are an experimental implementation regarding this concern. It demonstrates how a certain degree of static type safety can be introduced through the Actor addresses. However, it takes a rather rigid approach, by simply defining a most basic supertype of all messages through a type parameter and forbidding the behavior to change such that messages of this type could not be understood anymore.

Active objects primarily address the problem of contracts for actors. Their object abstraction provides static interfaces. A compiler can ensure message compatibility [@Ber14]. The changing of behavior is reflected as a change of the object's internal state. However, actors can in general alter their behavior such that they do not always accept the same kinds of messages. Only a certain sequence of messages is then valid. Intuitively, this fact is somewhat contrary to the static notion of objects the AO abstraction facilitates. It would imply that the offered methods of an active object is not a static set but can change dynamically depending on the object's internal state. In theory, it is however possible to alter the type annotation (the proxy object) on the client side of an active object dynamically. Method restrictions can occur while method compatibility is still ensured through a compiler [@Pun01b]. In object-orientation, this characteristic is usually referred to as *nonuniform method availability* [@Hut16].  

There is a generalization of describing valid method invocation orders for objects. Two kinds of notions have been established in the literature. One notion is focusing on the introduction of very formally defined theoretical models (e.g.\ based on process calculi) into typization, as do for example *process types* [@Pun95a;@Hut16]. Another notion is based on less formally defined ideas summarized as *typestate*. The nonuniform method availability we've just described is a special variant of typestate referred to as *session types* [@Anc16]. We've found that modern active object variants like Orleans do not endeavor into method invocation order capabilities.

Regarding microservices, we've mentioned WSDL as an interface description format. However, WSDL merely expresses static information and does not incorporate work-flow details [@Mon16b]. More sophisticated standards provide the expression towards behavior contracts, e.g.\ WS-BPEL (__W__eb __S__ervice -- __B__usiness __P__rocess __E__xecution __L__anguage) [@Anc16]. These standards build upon the ideas of formal concepts like process calculi, especially CCS and the &pi;-calculus [@Dra17a]. As with WSDL, they have been utilized in the SOA context, but it appears to us that these standards are yet rather neglected in the microservice domain. We presume this is due to the same reasons regarding too much complexity that is hindering easy service development. Once again, we argue for programming language-based solutions to overcome this hindrance. In fact, a primary design goal of Jolie was to build upon and extend WSDL interface descriptions and WS-BPEL orchestration, while fixing some of their formal semantics ambiguities [@Anc16;@Mon14].


In general, behavioral type theoretical concepts do not seem to be widely applied in practice yet. Dragoni *et al.*\ [@Dra17a] argue that this is because they restrain the applicability of services, which is undesired by programmers. For a more detailed overview of behavioral contracts we refer the interested reader to Hüttel *et al.*\ [@Hut16] and Ancona *et al.*\ [@Anc16].

~ Findings
[Main findings]{.findings-title}

* Microservices lack the theoretical framework and tool support to provide type safety between services. 
+ [TODO]{.red}
{.findings-list}
~

-->


### Software Artifact Analysis


Sections [#ch-actor-impl] and [#ch-microservice-impl] covered the solution strategies when programming with actors and microservices. The previous sections of this chapter compared the capabilities resulting from model properties and the expressed strategies. Now we want to merit attention to the effects that the programming models have on the resulting software artifacts. We concern ourself with three metrics: the *lines of code* (LoC) it takes to express the respective functionality, the size of the resulting artifacts, and the *startup time* (ST) of each artifact. 

All Akka actors are compiled into a single monolithic application. Therefore, the respective Akka metrics refere to the resulting monolith. The Spring-based microservices are independent programs, so we give the metrics for each service engine separately.

The LoC give us an indication of the programming effort is takes to implement a given functionality. We've counted the LoC using the CLOC [@CLOC] tool. Since Spring Boot relies heavily on configuration to adapt it's default behavior, we've counted the content of configuration files as source code. 

We measure size in terms of the bytes of each JAR (__J__ava __Ar__chive) file. There are several ways to package a JAR. Two kinds are of relevance to us. We define a *skinny JAR* (sJAR) as the archive containing merely the byte code and direct resources (e.g.\ property files) of a program's source code. Subsequently, we use *fat JAR* (fJAR) for an archive containing the data of the skinny JAR version, together with it's direct dependencies (e.g.\ other libraries in their skinny JAR version), and the deployment information required to execute the application on a standard Java runtime environment. Fat JARs are therefore executable artifacts.

The startup time is the time it takes an incarnation of a fat JAR [until the functionality can be issed.]{.red} 

Table [#tab-artifact-metrics] gives the measured metrics for the Echo artifacts. As a reminder, the Core artifact is the library implementing the domain specific logic. Hence, Core's skinny JAR is part of all fat JARs of the microservice engines as well as the Akka monolithic engine. The Web application is the frontend client that both Echo system implementations have to serve their functionality too [(?schlechter satz)]{.red}. The LoC metric of the Web application is merely given as a reference relative to the other artifacts.

~ Begin Center
~ Begin TableFigure { #tab-artifact-metrics; caption: "Lines of code, byte code sizes, and startup times of software artifacts"; page-align:here }
|-------------------|------|-----------| ----------| ---------|
| Artifact          | LoC  | sJAR (KB) | fJAR (KB) | ST (sec) |
+-------------------+-----:+----------:+----------:+---------:+
| Akka monolith     | 4487 | 1004.3     | 76 775.1  | 5.5      |
| ------------------|------|-----------|-----------|----------|
| CatalogStore (MS) | 1838 | 56.1      | 89 225.8  | 14.6     |
| ------------------|------|-----------|-----------|----------|
| IndexStore (MS)   | 724  | 23.8      | 83 518.2  | 8.8      |
| ------------------|------|-----------|-----------|----------|
| Searcher (MS)     | 656  | 22.2      | 81 754.4  | 8.0      |
| ------------------|------|-----------|-----------|----------|
| Web Crawler (MS)  | 716  | 23.5      | 83 517.9  | 9.0      |
| ------------------|------|-----------| ----------|----------|
| Parser (MS)       | 703  | 24.2      | 83 519.1  | 8.3      |
| ------------------|------|-----------| ----------|----------|
| Registry (MS)     | 334  | 9.9       | 90 699.7  | 9.5      |
| ------------------|------|-----------| ----------|----------|
| Gateway (MS)     | 889  | 30.5       | 83 655.1  | [??]{.red}     |
| ------------------|------|-----------|-----------|----------|
| Updater (MS)      | 693  | 23.9      | 83 518.3  | 8.8      |
| ------------------|------|-----------| ----------|----------|
| Core (library)    | 5203 | 323.1     | &mdash;   | &mdash;  |
| ------------------|------|-----------| ----------|----------|
| Web (frontend)    | 3144 | &mdash;   | &mdash;   | &mdash;  |
| ------------------|------|-----------| ----------|----------|
{  }
~ End TableFigure
~ End Center

~ todo
Analyse der Tabellen-Einträge
~

The Akka monolithic engine has of course by far the most lines of code. A monolith implements the whole system within a single artifact, while each microservice merely implements a part of the overall system. Note that the DTO classes used to send asynchronous messages via AMQP are implemented in Core rather than directly within the service code bases. 

<!--
This is contrary to the microservice paradigm in principle, which states that shared code bases should be avoided [(hab ich das eigentlich im Kapitel 4 beschrieben?!)]{.red}. As a result, we usually have to expect duplicate DTO class code between the services.  
-->

<!--
However, Spring's AMQP integration greatly simplifies JSON deserialization of messages out of the box, if we use the very same class on the sending and receiving end. We resorted to shared classes and have them within the shared Core, to ease our application's development effort. To reflect the values that the paradigm intends and the resulting expected development effort, we've adjusted the LoC values of each microservice by the DTO class sizes each service uses. 
-->

The resulting overall LoC sum of all microservices is [4915]{.red}. We see, although Spring provides very expressive declarative programming APIs, the Akka interface is still a bit less verbose.

Even more interrestingly, each microservice engine takes considerably more time to startup than the entire Akka monolithic engine. The inversion of control model that powers the declarative programming style of Spring adds considerable runtime overhead. 

The summized skinny JAR size of all microservice code bases is 169.1 KB [STIMMT DAS WIRKLICH?!]{.red}, which is considerably more compared to the 1004.3 KB of the skinny Akka monolith. We've analyzed the content of the respective skinny archive files and made the following observations that affect the difference in byte code size:

* The actor codebase is written in Scala, and we make heavy use of `case class`{language:scala} constructs. Scala's `case class`{language:scala}es are very compact class definitions that are mostly written in a single line of code. Instantiated objects are immutable, hence they suit very well for the data transfer objects that we exchange as messages in actor programming. Though these class definitions are compact, they still compile to dedicated `.class` files. In contrast, all DTO classes used for messages between microservices are part of the shared Core library. The byte code sizes of these classes subsequently do not participate to the sJAR size of each microservice's artifact. 
* Scala is primarily a functional programming language and usage of so-called *anonymous functions* is relatively common. Since Scala targets the JVM, these anonymous functions are evalutated by the compiler as instance creation expressions of the `Function`{language:scala} class. Subsequently, anonymous functions are compiled into dedicated `.class` files too [@Ode16]. 
* Spring provides many utility functionality transparently, for example DTO class to JSON marshalling. Akka HTTP requires us to define JSON serializer classes manually. These serializer compile to relatively significant bytecode sizes. 

The fat JAR sizes show the impact of the declarative programming styles provided by Spring. The price for the relatively low LoC of each service is that the compiler has to add lots of dependencies into the fJAR executables. These dependencies are then utilized at runtime to realize the delared functionality. As a result, every microservice engine is larger (in bytecode size) and upon incarnation also considerably slower than the entire actor engine.


~ todo
Bar plot der fat JAR sizes, wo die MS balken anders eingefärbt sind als der Akka monolith
~



~ Findings
[Main findings]{.findings-title}

+ Programming actors in Akka is generally more expressive than using Spring for microservices regarding lines of code. Microservices architectures require programmers two write several distinct applications, which produces additional LoC. [stimmt das eh zu meinen Zahlen?]{.red} 
+ Spring's produces huge executable artifacts. Every single service engine is larger than the entire Akka monolith.
+ [TODO]{.red}
{.findings-list}
~