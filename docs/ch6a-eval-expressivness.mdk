
# Evaluation {#ch-evaluation}


~ Epigraph { caption: "Jeannette M. Wing" }
Thinking like a computer scientist means more than being able to program a computer. It requires thinking at multiple levels of abstraction.
~


In Chapters [#ch-actor-model] and [#ch-microservice-paradigm] we introduced the concepts of actors and microservices. Chapter [#ch-implementation] described the strategies of each model to implement concurrent systems like the Echo scenario. We discussed each model separately and focused on the individual concepts of each model. In this chapter, we compare and evaluate both models relative to each other. As we have demonstrated, both actors and microservices qualify for expressing concurrent computation. Their mechanisms and abstractions also support parallel computation on multicore processor as well as distributed execution on multiple hosts. Several authors [@Kan12;@Kar09;@Agh99] suggest that programming models regarding parallel and distributed contexts should be evaluated based on two objectives: *expressiveness* for programmers and *efficiency* of execution. 

Section [#sec-eval-expressiveness] compares the key properties that are the foundation of the concurrent execution of both models and the resulting capabilities. The model capabilities allow us to evaluate the expressiveness of each programming model. Section [#sec-eval-efficiency] provides a benchmark for the actor- and microservice-based implementations of the Echo scenario. The results of this benchmark evaluate the efficiency of the programming models.


## Expressiveness and Capabilities {#sec-eval-expressiveness}


In this section, we evaluate and compare the key properties of the actor and microservice programming models, as well as the capabilities we can express with these models. Programming language theory knows a concept called *expressiveness* or *expressive power*. This concept also becomes more and more relevant in the light of concurrency theory. There, the *relative expressive power* is used to compare two formal concurrency models [@Fel91;@Gor16]. Evaluations on a strictly formal level require the rules and boundaries of formal frameworks. Therefore, often programming languages are analyzed. Concurrency theory focuses on *process languages*. These languages are founded on the formal frameworks of so-called *process calculi* [@Per16], which we briefly discuss in due course. Here, we do not concern ourselves with formal proofs of behavioral equivalence however. Instead, we revert to informal discussions about the observational equivalence of concepts we can express in the actor and microservice model, as has been often done in the literature before [@Fel91]. All strategies that we express in both models are essentially encodings of ideas [@Gor16]. Ultimately, we are interested if actors and microservices have the expressive power to convey the same ideas. The two models are equally capable to express a concept if the solution of one model produces an equally powerful functionality (informally) as the solution of the other model.


### Encapsulation and Isolation


Actor and microservice semantics rely on the strict separation of component states. We must ensure that state is conceptually well encapsulated within a component, and practically isolated from the outside. Encapsulation is a concept we know from object-oriented programming. As Snyder points out, OOP usually offers mechanisms to restrict the access to an object's state. A client gets access to an object's state by issuing requests for the *services* an object offers [@Sny93]. These "services" -- not to be confused with the concept of a *microservice* -- are what Meyer calls "well-defined interfaces" in the form of *routines*. Meyer considers these services a necessity for encapsulation [@Mey97]. 

Both actors and microservices offer well-defined interfaces in their own way. For an actor, the interface is the sum of the messages the actor understands through its behavior. For microservices, the interface is based on the sum of the facilitated communication channels, e.g.\ the REST interfaces the service exposes and the messages it consumes from a message queue. Only through the interfaces can we access or modify the service's state.

Table [#tab-comparison-encapsulation] at the end of this section summarizes the encapsulation-related matters as they are facilitated by Akka actors and Spring-based microservices.  


#### Shared and Mutable State


One fundamental characteristic of both actors and microservices is their notion of shared state. Summarizing Chapter [#ch-actor-model], the actor model encapsulates state exclusively within an actor. Therefore, the state is only accessible to and modifiable by the actor itself. Additionally, actors provide single-threaded semantics while processing messages. An actor processes only one message at a time. The isolated turn principle eliminates the need for synchronization, since message are free of low-level data races, and a turn has exclusive access to the current state. The actor's state is fully isolated.

On the other hand, we cannot apply the same reasoning for microservices in general. The paradigm states nothing about how state has to be handled internally. Depending on the programming paradigm we use to implement the service, state is not necessarily exclusive internally. In OOP for example, several objects can access the same memory location. Furthermore, concurrent access to the state is also possible, e.g.\ as a reaction to several invocations of the service's interface within a short time span. Microservices do not ensure single-threaded semantics. In general, we therefore assume that we must synchronize the access to the service's internal state. Additionally, the microservice paradigm dictates that we must avoid shared memory *between* services, as well as all kinds of shared resources in general. Since every service runs within a dedicated system process, avoiding shared memory implies no direct intersection between service process boundaries. Typical communication channels satisfying the requirements given in Section [#sec-independence-and-interaction] also prevent reference sharing to joined mutable data. All viable channel technologies provide some sort of message passing designed to transfer information between the different memory spaces of distinct processes [@Les09].

Actors generally face more challenges when it comes to truly ensuring state separation. The components can exist within the same process boundaries and access the same memory locations. Depending on the programming paradigm we use to implement the actors, exposing shared state to others can be rather easy. At the same time, exposed state is not necessarily apparent to the programmer. Think of the example we discussed for Akka. We can use an arbitrary object as a message. If we do not construct an object in an immutable fashion, the message transfer shares the object's state. Concurrent access and modification to this shared state causes unpredictable runtime issues. Especially the imperative programming style leans on mutable state. Actors in imperative languages therefore require extra care to preserve the model semantics. The functional paradigm tends to avoid these problems inherently. Functional languages model the behavior as a function and only this function is modifiable exclusively by the actor. If the actor model is integrated into the programming language directly, the language is able to enforce restrictions preventing shared mutability problems by design. Erlang is the prime example [@Vin07]. However, library-based actor implementations cannot ensure full isolation by themselves [@Kos16].


#### Persistence and IO {#sec-comparison-persistence-io}


The encapsulation and isolation principle of actors and microservices has one more important implication. Recall that state is exclusive to a single component. Hence, each component must also take exclusive care if we require durable state across the component's lifetime. In our scenario, every CatalogStore must have its exclusive database and every IndexStore its exclusive reverse index data structure. However, neither an actor runtime nor a microservice technique can enforce this persistence restriction. The obligation of correct configuration lies solely with the programmer. 

We also desire concurrent interaction to persistence mechanisms to increase throughput. Microservices easily leverage the concurrent interaction capabilities of a database management system via to the service's internal concurrent structure. The thread-pool strategy of Spring as well as the software transaction mechanism transparently extend to database interactions. 

Actors face more problems, since they are not concurrent internally. Like with all actions in the actor model, database interactions must execute in a turn-based fashion and are therefore sequential. We have outlined that we can apply the same strategies as for synchronous communication to improve the persistence-efficiency of actors. Either we employ additional concurrency constructs (futures) or we delegate interactions to child actors. Futures always have the potential to violate the isolated turn principle. Delegation forces us to share the database between several actors, violating the exclusive ownership of (shared) state. 


#### Cohesion, Coupling and Independence


Message passing interfaces and strong encapsulation make actors and microservices *cohesive*. Bon√©r [@Bon16] also defines truly isolated components combined through message passing communication as *decoupled* in two dimensions. On the one hand, the components are decoupled in *time*, which is the requisite for concurrent execution. On the other hand, the components are decoupled in *space*, and therefore we can execute them remotely and even move them between locations.

Regarding time, actors facilitate asynchrony intrinsically through the model design. Nevertheless, actor systems tend to offer synchronous primitives on top of the asynchronous style. Programmers receive better abstractions, at the cost of increased coupling. Microservices are free to choose the IPC style, as long as the IPC mechanism is based on message passing rather than shared memory, which further reduces the coupling.

Regarding space, actors are conceptually fully isolated. In practice, ensuring true isolation is difficult, especially for library-based actor implementations. We have discussed the conceptional problems for Akka in detail in Section [#sec-actor-isolation]. In the end, the programmer has to guarantee the isolation by complying to programming conventions. Infringing these conventions introduces or exposes shared mutable state, which is a violation of the actor model. Also, shared mutability increases the coupling to the sharing component, both in time and in space. 

Microservices have an inherent advantage regardless of the chosen programming model. The only true paradigm requirement is the avoidance of shared memory sections with other processes. Either the operating system enforces the memory boundaries, or the hardware separation resulting from distribution guarantees spacial decoupling. Besides, their distinct codebases further decouple the microservices. Only a shared library increases their coupling. For example, we facilitate a custom Core library in Echo. Core increases the service's coupling relative to the library. We have implemented all domain-specific functionality, as well as *data transfer objects* (DTO) within the Core. The DTOs are the domain objects we use as messages. Therefore, all microservices are coupled among each other by the DTO classes. Actors suffer from the coupling problem unequally more. The actor runtime intrinsically binds every actor. Different interfaces to an actor system can exist. Akka demonstrates interface diversity for Java and Scala. Yet, the actors cannot escape the coupling to Akka's codebase. Additionally, Echo's actors are also coupled by the DTOs in Core, just like the microservices. 

These two notions, high cohesion and low coupling, allow us to reason about the *independence* of task units. Independence is one of the primary concepts of the microservice paradigm. The literature describes independence as a direct consequence of high cohesion and low coupling [@Dra17a;@Dra17b;@Dra17c;@Sha17b]. We deem the strong process-based form of independence superior to the notion provided by the actor construct. Actors are passive tasks which react to messages. An actor can only perform actions when the runtime executes the actor. Microservices can show active behavior on their own.


~ Begin Center
~ Begin TableFigure { #tab-comparison-encapsulation; \
                      caption: "Comparison of encapsulation-related matters in Akka and a Spring-based MSA"; \
                      page-align:here; }

|----------------|------------------------------------|------------------------------|
| Characteristic | Akka                               | Spring MSA                   |
+----------------+------------------------------------+------------------------------+
| Shared state   | Not enforced, obligation of the    | Ensured through processes    |
|                | programmer                         | memory boundaries            |
| ---------------|------------------------------------|------------------------------|
|                | Single-threaded semantics, free of | Concurrent access inside the |
| State mutation | synchronization, threatened by     | service is possible, but     |
|                | language features                  | requires synchronization     |
| ---------------|------------------------------------|------------------------------|
|                | Single-threaded semantics          | Concurrent interaction with  |
| Persistence/IO | dampens throughput, improved       | outside freely possible      |
|                | with futures or delegation         |                              |
| ---------------|------------------------------------|------------------------------|
| Cohesion       | High cohesion through strong encapsulation and message passing   ||
| ---------------|------------------------------------|------------------------------|
| Coupling       | Coupled to common codebase         | Low coupling through         |
|                | and the runtime                    | independent codebases        |
| ---------------|------------------------------------|------------------------------|
| Independence   | Passive units, subject to runtime  | Active units, subject to OS  |
| ---------------|------------------------------------|------------------------------|

~ End TableFigure
~ End Center


### Communication and Message Routing


According to the general concerns of concurrent computation, tasks without mutable shared memory require other kinds of communication links which facilitate message passing instead. Since both the actor- and the microservice model strictly omit shared state, they too require what we call *communication channels* for messaging. These channels transport information from a source to a destination. A *sender* writes data to the channel, and subsequently the *receiver* reads the data from the channel. Independent of the concrete channel technology, message passing is a form of implicit synchronization of the information, since the event of reading a message can intrinsically only occur *after* the message was sent. In contrast, shared state explicitly requires a defined order of accessing the information [@And83].

We have identified various forms of information flows offered by channel concepts throughout the literature [@Cou05;@Mon14;@Gui09;@Spe90;@Roe15;@Agh99;@Tan07;@Bac03]. Generally, the flows can be distinguished alongside two dimensions: number of recipients and response coupling. Authors declare varying taxonomies for the resulting combinations. Table [#tab-communication-styles-overview] provides an overview of the terminology we use in the remainder of this work. Subsequently, Table [#tab-communication-styles-comparison] summarizes the communication capabilities of Akka actors and Spring-based microservices regarding these communication styles at the end of this section.

~ Begin Center
~ Begin TableFigure { #tab-communication-styles-overview; \
                      caption: "Communication Styles"; \
                      page-align:here;}

|------------------|--------------------------|---------------------------|
|                  | One-to-One               | One-to-Many               |
+------------------+--------------------------+---------------------------+
| **Synchronous**  | Request/response         | &mdash;                   |
| -----------------|--------------------------|---------------------------|
| **Asynchronous** | Notification             | Publish/subscribe         |
|                  | Request/async.\ response | Publish/async.\ responses |
|------------------|--------------------------|---------------------------|

~ End TableFigure
~ End Center

Asynchronous one-to-one messaging is inherent to the actor model. The message-sending primitive realizes notification style communication. Responses are asynchronous too. Akka provides the `sender()` method within actors. The method produces the `ActorRef`{language:scala} of the originator of the current turn's message. Microservices achieve asynchrony via message queues. Responding depends on the channel protocol. AMQP does not transmit the sender's location. If we must send a response, we need to include the location information into request messages individually. 

We can model synchronous one-to-one messaging on top of the actor messaging primitive. Every synchronous communication can be expressed using asynchronous constructs in general, and vice versa [@Agh97]. Akka provides linguistic support for request/response messaging through the `ask [?]` method of `ActorRef`{language:scala}. Microservices utilize network mechanism dedicated to the synchronous interaction pattern. In the service context, REST is the most prominent example. 

One-to-many communication is neither inherent as a primitive to actors nor microservices, and therefore requires additional effort. Conceptually, we model the communication style by sending a message to each intended recipient in a notification fashion (message broker). Akka has message broker capability in their message router constructs through the `BroadcastRoutingLogic`{language:scala}. Echo implements the routing logic inside a separate actor. In Echo's MSA, the RabbitMQ service does not suffice for one-to-many message distribution. AMQP only supports what the JMS terminology calls *queue* semantics (one-to-one), but not the JMS *topics* (one-to-many). We must employ another messaging technology. *Kafka* [@ApacheKafka] is a widely adopted publish/subscribe streaming system with very lightweight message constructs.

<!--
, and therefore appropriate for the microservice paradigm. 
-->

One important realization is the difference in messaging interfaces. While Akka provides few but homogenous interfaces (`tell [!]`, `ask [?]`, and `RoutingLogic`{language:scala}s) across all language bindings, the microservice model does not enforce any kind of interface. REST, AMQP and Kafka all have different interfaces. Since all Echo services are based on Spring, at least we express the interaction with each communication mechanism in the same way within each service. But the microservice paradigm is also open for arbitrary technology stacks, and every stack provides its own interface for each mechanism.   

~ Begin Center
~ Begin TableFigure { #tab-communication-styles-comparison; \
                      caption: "Comparison of communication styles and their implementation constructs as we express them Akka and a Spring-based MSA"; \
                      page-align:here; }

|-------------------------|---------------------------------------------|---------------------------|
| Communication Style     | Akka                                        | Spring MSA                |
+-------------------------+---------------------------------------------+---------------------------+
| Request/response        | `ask` method of `ActorRef`{language:scala}, | Remote procedure call     |
|                         | delegation pattern                          | with REST                 |
| ------------------------|---------------------------------------------|---------------------------|
| Notification            | `tell` method of `ActorRef`{language:scala} | Message queue service     |
|                         |                                             | like RabbitMQ             |
| ------------------------|---------------------------------------------|---------------------------|
| Request/async response  | Request and response with                   | Request and response      |
|                         | `tell` method of `ActorRef`{language:scala} | through message queue     |
| ------------------------|---------------------------------------------|---------------------------|
| Publish/subscribe       | Router with                                 | Message broker service    |
|                         | `BroadcastRoutingLogic`{language:scala}     | like Kafka                |
| ------------------------|---------------------------------------------|---------------------------|
|                         | `BroadcastRoutingLogic`{language:scala}     | Request through message   |
| Publish/async responses | for request, responses with                 | broker, responses through |
|                         | `tell` method of `ActorRef`{language:scala} | message queue             |
| ------------------------|---------------------------------------------|---------------------------|

~ End TableFigure
~ End Center


### Conception of Concurrent Execution {#sec-conception-concurrent-execution}


Actors and microservices are both concurrently executed components within their system architectures. However, their execution-modalities are fundamentally different. Hence, both constructs have different *notions* of concurrency. Each notion is a direct result of the underlying concepts.


#### Continuations, Threads and Processes


Scala's original actors provide two different execution semantics [@Hal09]. One of the semantics schedules the actors on threads. These actors are executed in an inversion of control manner [@Hal06], similarly to the strategy pursued by the Spring framework. The other of the two semantics is purely event-based and therefore without IoC. Thread-based actors are invoked by their current thread to execute a turn. Upon completion, the actor returns to the calling thread. On the other hand, event-based actors do not have (or need) a dedicated thread and therefore cannot return to one. Instead, they facilitate a much cheaper concept called *continuation-passing style* known from functional programming. A function refrains from returning a computed result and calls a subsequent function instead, the so-called *continuation closure*. Akka extends this approach and defines as single closure for all messages until we replace the behavior. This approach is more effective [@Hal12]. We already gave an example of a continuation with `Actor.same`{language:scala} for Akka's type-restricted behaviors. `Dispatcher`{language:scala}s influence the thread assignment strategy for concurrently running the behavior closures [@Hal12]. Although it uses threads, we still consider the continuation closure approach as event-based, since a thread can be seen as merely a trajectory in continuation space [@Shi97]. Nevertheless, threads are conceptually similar to processes, except that several threads exist within a single process [@Bac03]. There, the actor thread-pools live in one or few processes and many actors share the same memory boundaries of their respective process. 

Although they execute on top of threads, the isolated turn principle essentially defines actors as single-threaded entities. The combination with asynchronous message passing allows the runtime to concurrently execute these logical single-threaded components. In general, an actor has no notion of concurrency at all. However, we have demonstrated how to introduce additional concurrency constructs into the scope of actors, as long as these additional constructs do not break the actor model semantics. Section [#ch-actor-impl] demonstrated futures with their pitfalls as one option. In combination with the continuation abstraction, Akka actors are powerful and still extremely light-weighted constructs.  

On the other hand, microservices are concurrent distributed processes. The model paradigm tolerates a more widespread notion of concurrency than actors do. Internally, services do not have a counterpart to the isolated turn principle. Though a service also receives messages via a public API and reacts to them, the MSA style permits design flexibility regarding internal task unit concurrency. For example, a widespread strategy in the domain of distributed systems is to utilize several threads to perform blocking operations [@Tan07]. A microservice applies this strategy to perform blocking operations without blocking the service's entire process, and react to numerous messages simultaneously. Spring's IoC container provides this strategy automatically for requests through its thread-pool. 
 
The drawback of this degree of freedom is the set of issues internal concurrency introduces. In general, accessing state is not a safe operation anymore, if the respective state is read- and writable across threads. We must use synchronization then, e.g.\ in the form we have demonstrated in the Java case study. When we program with microservices, we are therefore not free from the many hassles of low-level concurrency per se. We have seen this in Echo's MSA variant, where we use transactional memory for synchronization. 

However, a service's scope of responsibility limits the service's size. Consequently, the size also limits the internal concurrency considerations of a service relative to the overall system. As a result, linguistic approaches to SOC tend to avoid internal concurrency considerations completely by applying an idea resembling the C processes case study of Section [#sec-concurrency-os-level]. For example, Jolie offers the `concurrent`{color:blue} primitive as one option for the execution modality of services. The primitive spawns dedicated processes to concurrently execute the service behavior in response to messages [@Mon16b]. This idea has close resemblance to the cameo delegation pattern of actors. Of course, the design freedom of the MSA style also allows actor-based concurrency internally. The benefits of synchronization-free programming can be harvested by microservices too. 


#### Distribution and Location Transparency


Communication via message passing has one fundamental property: no mutable memory is shared between the communicating components. Conceptually, message passing does not require the components within the same memory space. As a result, it does not matter whether the components run on the same core, different processors or even different host machine [@Fel90]. In short, message passing enables distribution. 

The actor model builds upon message passing to share state information between actors. Additionally, actors are well isolated from each other. Based on these properties, Agha recasted the initial notion of actors in the light of distributed computation [@Agh85a]. All actor addresses, and therefore also Akka's `ActorRef`{language:scala}s, make the location of the underlying actor transparent. A runtime system that is part of a cluster handles the actual message delivery on the same local node and on remote nodes. Addresses provide a uniform interface free of location considerations.

Microservices intrinsically fall into the domain of distributed systems as well, if the services leverage a network-based communication mechanism. There is no guarantee of a unified channel interface for all services and mechanisms. We have given Unix pipes as an illustrative mechanism. Pipes facilitate the file descriptor interface that Unix promotes. This interface is limited to local node interaction, that is the memory boundaries of a single host OS. Channels operating on the network level are distributed communication mechanisms. Network channels facilitate message passing and provide a uniform interface for remote as well as local communication [@Spe90]. Sockets are the most basic example. The socket interface is homogenous regarding whether a socket is on the same local or a remote node. However, sockets still require the *concrete* address [@Bac03]. In order to have the recipients' location transparent, the microservice paradigm requires additional effort in the form of discovery mechanisms. We have demonstrated how Echo integrates discovery based on Feign and Eureka directly into the client-side communication interface using Spring's declarative programming style.


#### Fairness and Resource Consumption


Actors and microservices represent concurrent building blocks of equal status in their respective architectures. It is important to reason about their chances to make even progress, since we have a uniform view on concurrent execution [@Bus90]. Our view does not distinguish quasi-simultaneous execution on a single processor, truly parallel execution on multiple CPUs, and distributed execution among several host machines. The property of uniform progress is called *fairness* and is closely related to the liveness of concurrent programs and systems, i.e.\ to avoid starvation [@Agh85a;@Agh99].

Actors are entities inside an actor runtime. Their scheduling is the responsibility of this runtime system, viz.\ the system's execution strategy. As passive components, actors have no proactive sense and therefore merely react to events (received messages). The actor system delivers the message and assures that the receiving actor processes the message eventually. Therefore, the runtime must schedule every actor regularly to prevent starvation [@Kan12;@Kar09]. The major benefit is that actor systems can greatly reduce processing resource consumption. Given an actor's mailbox is empty, the runtime does not have to invoke the actor, since there is no work to do [@Agh14].  

On the other hand, scheduling is a nonconcern for microservices. Every MSA is a composition of concurrent distributed processes. The MSA implicitly delegates the scheduling to the host operating system(s) -- namely their *scheduling policies* [@Bac03]. We cannot make specific assumptions on execution rates in general, but require these rates to be positive. This *finite progress assumption* [@And83] is the foundation of liveness for every microservice. However, there is one drawback to the lack of scheduling concern in MSAs. The architecture cannot influence the resource consumption based on a service's actual demand. An operating system always allocates resources towards every process. Therefore, every task unit of an MSA also stresses its hosts processing power on a regular basis, at least to a small amount. This drain on resources exists even when the services neither have pending requests nor perform active behaviors of their own. In these cases, every process activation is simply a waste of energy and host resources [@Tan07].

Table [#tab-fundamental-concurrency-issues] gives an overview of how actors and microservices meet fundamental issues of concurrent programming.

~ Begin Center
~ Begin TableFigure { #tab-fundamental-concurrency-issues; \
                      caption: "Comparison of Akka actors and Spring-based microservices meeting fundamental issues of concurrent execution"; \
                      page-align:here; }

|-----------------|--------------------------------|---------------------------------|
| Issue           | Akka                           | Spring MSA                      |
+-----------------+--------------------------------+---------------------------------+
| Expression      | Actor object, concurrent       | Service program execution,      |
|                 | execution by runtime           | concurrent scheduling by OS     |
| ----------------|--------------------------------|---------------------------------|
|                 | Message passing primitives     | Message passing IPC mechanisms, |
| Communication   | (e.g.\ `tell`, `ask`), uniform | no shared memory, no uniform    |
|                 | interface across all actors    | interface across all services   |
| ----------------|--------------------------------|---------------------------------|
|                 | Implicit among actors due to   | Implicit among services due to  |
| Synchronization | message passing, single-       | message passing, potentially    |
|                 | threaded semantics internally  | required internally             |
| ----------------|--------------------------------|---------------------------------|
| Progress        | Guaranteed by runtime          | Expected from operating system  |
| ----------------|--------------------------------|---------------------------------|   

~ End TableFigure
~ End Center


### Scalability and Modularity {#sec-scalability-modularity}


Their ability to *scale* is arguably one of the most relevant reasons given in the literature to utilize actor- and microservice-based architectures [@Tas13;@Hal09;@Mon16a;@Dra17c;@Sal16;@Che17;@Sal16;@Dra17b]. Based on the definition given by Bondi [@Bon00], *scalability* is an attribute that influences the performance of networks, systems and processes in general. From the empirical knowledge of industrial Erlang applications it has been suggested that scalability is more important than raw system performance [@Hal12]. Many different aspects influence scalability. From a concurrent point of view, every influence hindering parallelism has a negative impact. Examples are synchronization (cf.\ Java case study in Section [#sec-concurrency-language-level]) and (temporal) deadlocks. The strong isolation and message passing principles of actors and microservices (isolated turn principle, avoidance of shared memory) reduce coordination and contention cost. Therefore, message passing and isolation have a positive influence on scalability capabilities by limiting safety and liveness issues [@Bon16].


#### Forms of Scalability


Many different forms and classification approaches for scalability exist. Two merit attention here. *Load scalability* refers to a steady performance if the demand or work increases. *Structural scalability* refers to the ability of the topology to change the amount of components, in this case concurrent task units [@Bon00].

Two notions of scaling a system are relevant to us. *Vertical scalability*, or simply *scaling up*, refers to an increase of resource utilization, especially multiple cores and memory on a single host. The influencing factors are asynchronous messaging, refrain from blocking, and synchronization. Actors conceptually support these requirements well, as long as the units refrain from blocking inside their turns. The microservice approach meets the requirements also quite well, when services back asynchronous communication mechanisms and refrain from RPCs. In general though, the internal concurrency capability introduces the risk of facilitating potential hindrances of scaling up. Besides, the scheduling efforts of actor runtimes and operating systems aim for an optimal utilization of available resources [@Bac03]. *Horizontal scalability*, also *scaling out*,  *distance scalability* or *geographical scalability*, refers to the utilization of additional hardware resources (hosts). Distribution capability is the prerequisite. The uniform abstraction of concurrent and distributed execution of actors as well as the process nature of microservices combined with network IPCs provide the foundation to scale out [@Bon00;@Dra17c;@Dra17b;@AkkaMDR;@Agh99;@Tan07].

One approach to achieve scaling out is the concept of load balancing we have already discussed. Akka actors build upon the same conceptual ideas using the router constructs. They allow us to distribute work in various strategies, e.g.\ round-robin or broadcast. Round-robin is one example of a load distribution strategy. Server- and client-side load balancing is merely the distinction of a `Router`{language:scala} within the sending actor itself, or inside an intermediate routing actor. Microservices either use dedicated balancing services for server-side balancing, or client-side mechanisms like Ribbon. In one way or another, load balancing is a valuable concept for both actors and microservices, e.g.\ to avoid overflowing mailboxes and to enable timely responses to requests. Some task units are naturally well suited for load balancing capabilities [@Mon16a;@Car17], e.g.\ Echo's API Gateway. The major difference lies in the trade-off that comes with load balancing in each model. As we have mentioned, a `Router`{language:scala} is a supervision-managed set of routees and therefore brings all obligations of actor supervision. Microservices are more loosely coupled and do not know the concept of supervision in general. Hence, load balancing for microservices does not come with additional obligations.

A conceptual disadvantage of load balancers is that the balancers do not know about the progress of potential recipients by default. The work gets distributed regardless of the current capacity of the receivers. Load balancers can take work load metrics into account of course, as does for example the `SmallestMailboxRoutingLogic`{language:scala} of Akka. This routing logic aggregates the mailbox capacities of all routees first. With this information, the logic then forwards the message to the actor with the smallest mailbox. However, the information aggregation *before* a message is dispatched increases the overall processing duration [@Roe15;@All13]. 

Another kind of load balancers are message queue channels. The receiving components actively pull messages from the queue when they have computation capacity. Therefore, the tasks distribute load among themselves based on their demand [@Cou05;@Dra17c]. 


#### Dynamic Reconfiguration


*Dynamic reconfiguration* relates to a change in a system's topology at runtime. We can add, remove or relocate task units divergent from the static initialization configuration [@Agh85b]. Actors support dynamic reconfiguration inherently through the primitive that allows actors to spawn new actors. We already demonstrated this ad hoc instantiation with the dynamically created response handlers that the Searcher spawns for the delegation-based synchronous communication. The loose coupling of microservices also provides opportunities for changing topologies. Discovery registries and asynchronous messages through intermediate message queues provide the foundation. Reconfiguration greatly effects scalability, because it increases the optimal utilization of hardware resources [@Kan12].

A general prerequisite for dynamic reconfiguration is location transparency. Actors as well as microservices have sophisticated solutions. Two additional properties, *mobility* and *elasticity*, become possible as a result. Mobility refers to the relocation of components between nodes [@Agh99;@Kan12;@Tan07]. Elasticity is a form of scalability summarizing the ability of a system to scale the number of components dynamically depending on the current demand. Hence, elasticity improves the load scalability while minimizing the resource consumption. We can scale actors and microservices in a non-uniform way due to their component properties. Each individual component type allows us to incarnate many instances without the requirement to duplicate the residual component types as well (in contrast to classic monolithic applications) [@Dra17b;@Dra17c].

Echo does not provide mobility nor elasticity. However, the general approach is conceptually identical for actors and microservices, therefore we present a short outline. In principle, we are able to create and terminate stateless task units easily on demand (elasticity). Since these units have no state that requires relocation, this reconfiguration also doubles as mobility. Akka does not provide string mobility that requires the migration of state. Other runtimes like Orleans do provide state migration [@Ber14]. Stateful Stores are a bigger concern. In general, when we (re-)created a stateful unit, it is not safe to assume that its persistent state (database, reverse index) is up to date. Therefore, we must update the state with regard to all outstanding modifications. *Event sourcing* is a convenient concept which persist all modifying commands to Stores in a so-called *event logs* [@Ber16;@New15]. A new or reactivated Store requests the history of modifications prior to the units existence. Message brokers have the potential to double as event logs. Kafka offers optional persistence support for messages. Akka's *Persistence* module is also convenient to introduce persistence of routed messages. In both cases, it is within the obligation of the Store units to persist a counter or reference to the last received event separately. This reference is required to determine the required partial history.

In general, we deem the concerns related to dynamic reconfiguration more easily met with actors. Spawning new units is a core concept of the basic model primitives. Microservices themselves have no general notion of other services beyond interaction. We need an additional layer to manage changing topologies. *Cloud management frameworks* are a category of tools that seem convenient.

Table [#tab-scalability-compatibility-matrix] summarizes the capabilities for each scalability variant provided through Akka and Spring.

~ Begin Center
~ Begin TableFigure { #tab-scalability-compatibility-matrix; \
                      caption: "Capability matrix of scalability variants and their support by Akka actors and Spring-based microservices"; \
                      page-align:here; }

|------------------------|-----------------------------------|---------------------------------|
| Scalability Form       | Akka                              | Spring MSA                      |
+------------------------+-----------------------------------+---------------------------------+
|                        | Very efficient resource           | Limited by the synchron-        |
| Vertical scalability   | utilization if no blocking        | ization of the internal service |
|                        | inside actor                      | concurrency (STM)               |
| -----------------------|-----------------------------------|---------------------------------|
| Horizontal scalability | Akka cluster                      | Requires network IPC            |
| -----------------------|-----------------------------------|---------------------------------|
| Load scalability       | Server-side load balancing        | Client-side load balancing      |
|                        | with routing logic                | with Ribbon, message queues     |
| -----------------------|-----------------------------------|---------------------------------|
| Structural scalability | Location transparency             | Requires discovery mechanism    |
|                        | inherent in actor addresses       | for location transparency       |
| -----------------------|-----------------------------------|---------------------------------|
| Dynamic                | Inherent through basic            | Requires service registry for   |
| reconfiguration        | model primitive                   | integration                     |
| -----------------------|-----------------------------------|---------------------------------|
| Mobility               | Weak mobility (no relocation of persistent state of Stores)        ||
| -----------------------|-----------------------------------|---------------------------------|
|                        | Requires resource control         | Requires appropriate cloud      |
| Elasticity             | of cluster (see [@Moa17]), not    | management framework,           |
|                        | supported by Echo                 | not supported by Echo           |
| -----------------------|-----------------------------------|---------------------------------|  

~ End TableFigure
~ End Center


#### Extensibility and Technology Diversity {#sec-technological-heterogeneity}


Another result of the reconfiguration capability is that actor and microservice architectures are also open for extension. In contrast to dynamic reconfiguration, where we add or remove instances of existing task units at runtime, we use *extensibility* to refer to the introduction of either new versions of existing components (update) or new components entirely (addition). Extensibility in general benefits from high cohesion and low coupling of the components. There are two different kinds of extensibility [@Agh85a;@Bac03]:

* static, where we adapt the architecture's code, recompile and then redeploy
* dynamic, where we add a new component to the architecture at runtime

The independent deployment capability of each single service engine allows us to simply add new components at runtime. The reconfiguration does not impact existing services. New services simply consume the existing services. We then gradually update old services to let them integrate with new components [@Mon16a].

Actors face more challenges. Every actor requires an actor system to exist within. Erlang and its runtime system were tailored to support actors. As a result, the *BEAM* virtual machine supports code loading and replacement for live upgrades [@Vin07;@New15]. The JVM does not support similar features. Therefore, Akka requires the restart of the system to introduce new kinds of actors. The same program structure defines all actors (monolith). Subsequently, the actors compile into a single monolithic executable, which limits Akka actors to static extensibility. In a clustered setup however, we do not need to introduce a new component into all cluster nodes at once. Therefore, the cluster is able to retain its uptime, while we upgrade and redeploy the individual cluster nodes. Besides differences in the VM optimization, Erlang's upgrade strategy is conceptually similar. The BEAM does not support the replacement of single actors, but merely of entire code modules [@New15]. 

Another interesting concern is the technology limitations regarding the conception of new components. An actor is bound to its runtime, which is free to provide interface bindings for numerous programming languages, e.g.\ as Akka does for Java and Scala. We are able to use the Java binding from other JVM languages as well, as [@Sub11] demonstrates for Groovy and JRuby. However, we cannot overcome the JVM as the target platform. Interoperability with Akka.NET would broaden our possibilities, but to our knowledge interoperability is not available. The strong memory boundaries and open communication interfaces of microservices provide a whole different level of flexibility. We can conceive a service using every programming language and technology we desire, as long as the tools are able to interact with the open communication channels.

Echo's services facilitate Java and the Spring framework for all microservice components. However, we could have also written every service with a different technology stack. Even now, we can replace existing services by new versions using different technologies.  


~ Begin Center
~ Begin TableFigure { #tab-modularity; \
                      caption: "Comparison of modularity capabilities of Akka actors and Spring-based microservices"; \
                      page-align:here; }

|-------------------------|----------------------------------|----------------------------------|
| Characteristic          | Akka                             | Spring MSA                       |
+-------------------------+----------------------------------+----------------------------------+
| Extensibility           | Static (phased restarts)         | Dynamic                          |
| ------------------------|----------------------------------|----------------------------------|
| Technological           | Compatible to the Akka interface | Open for arbitrary technology    |
| Diversity               | (JVM technology), no compatible  | stacks due to open interfaces    |
|                         | runtimes available today         | and communication channels       |
| ------------------------|----------------------------------|----------------------------------|   

~ End TableFigure
~ End Center


### Integrating Actors and Microservices {#sec-actor-ms-integration}


So far, our evaluation has shown that we can express the same capabilities with both actors and microservices. 

Both constructs isolate state, communicate through a wide range of interaction styles, and their execution modality enables parallelization and distribution in a transparent way. The major benefit of all these capabilities is a high degree of modularity as well as great flexibility for scaling. Each model brings its own set of trade-offs, and we as programmers must accept one of these sets in order to leverage the capabilities.

As a final capability evaluation, we want to reason whether all these properties enable actors and microservices to integrate as equal concurrent task units. We have already seen that the combination of concurrency models is a common and important practice. Actors often incorporate futures, and microservices use and mix arbitrary concurrency constructs internally. We will entertain this integration thought first with some theoretical considerations and then discuss the practical approach regarding Akka and Spring.

As we have pointed out, there are two kinds of correctness properties: safety properties and liveness properties. The combination of two concurrency models must not weaken the safety or liveness properties. There are also two approaches to assess the correctness of a computation: *testing* and *verification*. From a theoretical point of view, we can violate every safety property by a finite execution. Hence, we can test for safety at runtime. On the other hand, liveness properties cannot be violated by some finite execution in general. Even if an arbitrary finite execution causes a violation, there is some continuation of the same execution for which the property still holds eventually [@Siv99]. Thus, we cannot test for liveness at runtime. This theoretical limitation raises the need for other concepts to either guarantee or at least inspect the liveness of tasks. We require strict theoretical frameworks to apply formal verification techniques [@Sin09]. For actors, the theoretical actor model provides this framework. However, we have seen that rather pragmatic rules define the microservice model in comparison. We yet lack a formal framework.


#### Actor Model and Process Calculi


Among the theories of formulating concurrent computation we find a family called *process calculi* or *process algebras*. These calculi define formal models composed of so-called *processes*[^fn-process-concurrency-theory] which communicate within the laws and conditions laid out by their theory. Baeten [@Bae05] defines *process* as any kind of *behavior* of a *discrete event system*, such that it is observable through discrete actions. These actions include interactions with other discrete event systems. The other systems then react to these interactions. Therefore, Baeten terms all interacting systems as *reactive systems*, which are the base for parallel and distributed computing. As a result, one approach towards concurrency theory is the path of process algebras.

[^fn-process-concurrency-theory]: These are the processes of concurrency theory we have mentioned before. We must not confuse them with operating system processes.

Some process calculi gained considerable prominence. Examples are Milner's *Calculus of Communicating Systems* (CCS) [@Mil80] that was the initial work in this domain. Hoare's *Communicating Sequential Processes* (CSP) [@Hoa78] was the first to introduce message passing instead of global variables for process communication. For our considerations, the *&pi;-calculus* [@Mil92], also by Milner, merits special attention. The &pi;-calculus has a notion of process networks, including mobility and dynamic reconfiguration [@Bae05;@Mon97]. 

Much work was done on the field of process algebras, since they allow us to express a theoretical basis for arbitrary domains and requirements. In fact, more practical approaches to express interacting processes frequently have their foundation in a process calculus. Some calculi also suit well for microservices. The Jolie language for example is based on a calculus dedicated to service-orientated computing called *SOCK* (__S__ervice __O__riented __C__omputing __K__ernel) [@Gui06]. In turn, SOCK is inspired by CCS and the &pi;-calculus. This relation of process algebra and microservices is especially interesting, since the actor model and process calculi share a long history. Hewitt as well as Milner published their initial works on the actor model and CCS in 1973. Since then, these two approaches mutually influenced and inspired the scientific development of each other. Fitting examples are the *Asynchronous Sequential Processes* (ASP), which bear close resemblance to active objects, but with a more coarse granularity [@Kos16]. 

Scholars have long tried to formulate a theoretical link between actors and various calculi, with mixed and mostly limited success. To our knowledge, to most promising approaches in the literature so far merely succeeded at describing interoperability between actors and some calculi that show a strong similarity. For example, Montanari & Talcott [@Mon97] demonstrate the cooperation of actors and agents of the &pi;-calculus. 

As Agha *et al.*\ [@Agh97] discuss in an extensive work, a true equivalence theory among a formal *actor calculus* and some process calculus requires the formulation of a *simulation relation* among the primitives. This was done among different process calculi but is yet unfound regarding actors. Agha *et al.*\ state as the foundational challenges:

> "Three points of contrast between the basic actor model and process calculi are: the choice of communication model, the choice of communicable values, and the issue of fairness."

Note that we have discussed these issues as concerns in varying degrees throughout this thesis. Eventually, Agha *et al.*\ argue that instead of trying to find an analogy between an actor- and a &pi;-calculus, it is expedient to engage in the definition of high-level semantics for programming languages. Then, we are able to reason about program equivalence of actors- and &pi;-programs. 


#### Combining Akka Actors and Spring Microservices {#sec-combining-akka-spring}


Since we did not implement our Echo microservices in a SOP language like Jolie, we did not provide them the formal foundation of a process calculus. We would not be able to reason about the correctness properties after integration anyway, because there is no known theoretical link between the actor model and a SOC calculus yet. Nevertheless, we have seen that scholars are still motivated to describe interoperability between actors and calculi processes. Therefore, we think about the approach to integrate our Akka actors and Spring-based microservices. From a theoretical point of view, two concurrent units require a shared communication channel in order to interact [@Agh97]. 

The microservice principles allow the services a rather high degree of freedom regarding their communication. REST-based state transfer via HTTP is a popular choice. We have demonstrated that AMQP is also a viable channel. Actors, on the other hand, are more restricted, since all actors must receive the *message* constructs in a uniform way. By implication, this restriction means that we can still use different communication channels as long as the channels comply to a homogenous message receiving abstraction.

*Akka HTTP* [@AkkaHTTP] is part of the Akka library collection. It provides a full client- and server-side HTTP stack on top of the basic actor construct. This way, actors receive HTTP requests like ordinary messages, just as if the messages were sent by other actors: 

```{language:scala}
override def receive = {
  case SomeMessage(_)                           => // handle message
  case HttpResponse(status, headers, entity, _) => // process response
}
```

A unique address identifies every actor. This address is specific to a concrete actor system and not conform to a URI (__U__niform __R__esource __I__dentifier) as is required by HTTP in general. We must utilize an integration layer between a HTTP-addressable unit and the actual actor [@AkkaHTTP]. 

Though this style of receiving messages is in principle conform to the actor abstraction, there are certain limits. By implication, HTTP endpoints also do not comply to actor addresses in general. The standard *send* mechanism through `tell` and `ask` therefore do not qualify to dispatch HTTP requests. We require an alternative interface. The example below uses `pipeTo` to have the integration layer reroute the response as an `HttpResponse`{language:scala} message to the sending actor (delegation):

```{language:scala}
Http().singleRequest(HttpRequest(URI(s"http://example.com")
  .withQuery(s"name", s"value"))
  .pipeTo(self)
```

We see, not all the basic actor primitives suit for usage outside the actor construct. However, well introduced abstractions like Akka HTTP allow actors to provide their *actor behavior* to the outside in a microservice-like *service behavior* fashion. Communication between actors and microservices is possible in principle. Hence, we can construct systems which distribute tasks between actors and microservices.  

The general integration idea is not novel. We have mentioned the theoretical foundation from [@Mon97] for incorporating actors and agents of the &pi;-calculus. They also use so-called *actor-&pi; coordinators* to translate between communication channels. These coordinators are similar to the integration layer of Akka HTTP. However, interoperability is merely a concern of static configuration, because processes have only a static notion of interconnection topology in general. This static notion violates the dynamic reconfiguration inherent to actors [@Akm90;@Agh85b]. In order to overcome this limitation, microservice architectures utilize bridge technologies like service discovery. Hence, we require actors to integrate into this discovery mechanism, effectively rendering each actor into a mere microservice. This unified approach is not quite common yet, but technologies start to emerge which build on this idea. An example is *Lagom* [@LightbendLagom], a reactive microservice system framework built on top of Akka.


~ Findings
[Main findings]{.findings-title}

+ Process calculi provide the theoretical frameworks for formal microservice specifications and service-oriented computing languages.
+ The theoretical link between actors and process calculi is yet an open scientific question.
+ Actors and microservices can integrate without a formal basis. However, the correctness properties of the models are then not guaranteed.
{.findings-list}
~


### Software Artifact Analysis


Sections [#ch-actor-impl] and [#ch-microservice-impl] covered the solution strategies when we program with actors and microservices. The previous sections of this chapter compared the resulting capabilities. Now we give attention to the effects that the programming models have on the resulting software artifacts when we express these capabilities. We concern ourselves with three metrics: the *lines of code* (LoC) it takes to express the respective functionality, the *size* of the resulting artifacts, and the *startup time* of each artifact. 

All Akka actors are compiled into a single monolithic application. Therefore, the respective Akka metrics refer to the resulting monolith. The Spring-based microservices are independent programs, so we give the metrics for each service engine separately. The LoC give us an indication of the programming effort is takes to implement a given functionality. We have count the LoC using the CLOC [@CLOC] tool. Since Spring Boot relies heavily on configuration to adapt it's default behavior, we count the content of configuration files as source code. We measure size in terms of the bytes of each JAR (__J__ava __Ar__chive) file. There are several ways to package a JAR. Two kinds are relevant to us. We define a *skinny JAR* (sJAR) as the archive that contains merely the bytecode and direct resources (e.g.\ property files) of a program's source code. Subsequently, we use *fat JAR* (fJAR) for an archive that contains the data of the skinny JAR version, together with its direct dependencies (e.g.\ other libraries in their skinny JAR version), and the deployment information that a standard Java runtime environment requires to execute the application. Fat JARs are therefore executable artifacts. The startup time is the time from process incarnation until the application is fully operational.

Table [#tab-artifact-metrics] gives the metrics for our Echo artifact implementations. As a reminder, the Core artifact is the library that implements the domain-specific logic. Hence, Core's skinny JAR is part of all fat JARs of the microservice engines as well as the monolithic Akka backend. The Web application is the frontend client that connects to both Echo backend implementations. We give the LoC metric of the Web application merely as a reference relative to the other artifacts.

~ Begin Center
~ Begin TableFigure { #tab-artifact-metrics; \
                     caption: "Lines of code, bytecode sizes, and startup times of software artifacts"; \
                     page-align:here }

|-------------------|------|-----------| ----------| --------------|
| Artifact          | LoC  | sJAR (KB) | fJAR (KB) | Startup (sec) |
+-------------------+-----:+----------:+----------:+--------------:+
| Akka backend      | 4487 | 1004.3    | 76 775.1  | 5.5           |
| ------------------|------|-----------|-----------|---------------|
| CatalogStore (MS) | 1838 | 56.1      | 89 225.8  | 14.6          |
| ------------------|------|-----------|-----------|---------------|
| IndexStore (MS)   | 724  | 23.8      | 83 518.2  | 8.8           |
| ------------------|------|-----------|-----------|---------------|
| Searcher (MS)     | 656  | 22.2      | 81 754.4  | 8.1           |
| ------------------|------|-----------|-----------|---------------|
| Web Crawler (MS)  | 716  | 23.5      | 83 517.9  | 9.2           |
| ------------------|------|-----------| ----------|---------------|
| Parser (MS)       | 703  | 24.2      | 83 519.1  | 8.6           |
| ------------------|------|-----------| ----------|---------------|
| Registry (MS)     | 334  | 9.9       | 90 699.7  | 9.4           |
| ------------------|------|-----------| ----------|---------------|
| Gateway (MS)      | 889  | 30.5      | 83 655.1  | 9.7   |
| ------------------|------|-----------|-----------|---------------|
| Updater (MS)      | 693  | 23.9      | 83 518.3  | 8.7           |
| ------------------|------|-----------| ----------|---------------|
| Core (library)    | 5203 | 323.1     | &mdash;   | &mdash;       |
| ------------------|------|-----------| ----------|---------------|
| Web (frontend)    | 3144 | &mdash;   | &mdash;   | &mdash;       |
| ------------------|------|-----------| ----------|---------------|

~ End TableFigure
~ End Center

The Akka backend engine has of course by far the most lines of code. A monolith implements the whole system within a single artifact, while each microservice merely implements a part of the overall system. Note that the Core library implements the DTO classes we use to send asynchronous messages via [AMQP.]{tex-cmd-after:"\,"} The microservices do not implement these DTOs themselves within their codebases. The resulting overall LoC sum of all microservices is 6553. This makes the microservice codebase about 46\ % larger than the actor codebase. We see, although Spring provides very expressive declarative programming APIs, the Akka interface is still less verbose. However, the more compact syntax of Scala compared to Java also contributes to the difference. Even more interestingly, each microservice engine takes considerably more time to startup than the entire Akka backend engine. The inversion of control model that powers the declarative programming style of Spring adds considerable runtime overhead. 

The sum of skinny JAR sizes of all microservice codebases is 241.1 [KB.]{tex-cmd-after:"\,"} This size is considerably less compared to the 1004.3 KB of the skinny Akka backend. We have analyzed the content of the respective skinny archive files and made the following observations that affect the difference in bytecode size:

* The actor codebase is written in Scala, and we make heavy use of `case class`{language:scala} constructs. Scala's `case class`{language:scala}es are very compact class definitions that are mostly written in a single line of code. Though these class definitions are compact, they still compile to dedicated `.class` files. Instantiated objects are immutable, hence they suit very well for the objects we exchange as messages in actor programming. Messages in the actor model are not only for transferring data, but also to transmit commands. Thus, we use very fine-grained message types, and subsequently a lot of `case class`{language:scala} definitions. Few lines of code for these definitions let the compiler produce lots of separate `.class` files. In contrast, all the DTO classes for the messages between microservices are part of the shared Core library. The bytecode sizes of these classes consequently do not participate to the sJAR size of each microservice's artifact. 
* Scala is primarily a functional programming language. Hence, we make frequent use of so-called *anonymous functions*. Since Scala targets the JVM, the compiler evaluates these anonymous functions as instance creation expressions of the `Function`{language:scala} class. Subsequently, every anonymous function compiles into a dedicated `.class` file too [@Ode16]. 
* Spring provides a lot of utility functionality transparently, for example DTO class to JSON marshalling. Akka HTTP requires us to use the *Spray* [@LightbendSpray] library to define custom JSON serializer classes manually. These serializers compile to relatively significant bytecode sizes (e.g.\ merely 31 LoC produce about 200 KB[^fn-uncompressed-class-file]).

[^fn-uncompressed-class-file]: A JAR file is essentially a compressed archive file. The direct size of a `.class` file does not contribute at a ratio of 1:1 to the sJAR size.

The fat JAR sizes show the impact of the declarative programming style of Spring. The price for the relatively low LoC of each service (and subsequently the reduced effort to write many distinct programs) is that the compiler adds lots of dependencies into the fJAR executables. These dependencies come into play at runtime to realize the declared functionality. As a result, every microservice engine is larger (in bytecode size) and upon incarnation also considerably slower than the entire actor engine.


<!--
~ todo
Bar plot der fat JAR sizes und startup time, mit 2 Achsen. Falls ich das noch irgendwie hinkriegen sollte
~
-->


~ Findings
[Main findings]{.findings-title}

+ Programming actors demands less program code than microservices. Even compact programming styles cannot compensate the overhead in LoC from several codebases.  
+ Spring produces huge executable artifacts. Their bytecode size and the overhead at startup is the price for the reduced programming effort.
+ Microservice architectures are drastically larger in terms of executable component sizes compared to a monolithic actor architecture.
{.findings-list}
~