~ Categories and Subject Descriptors
Language Constructs and Features, Concurrent programming structures
~

~ Keywords
Actors, Comparison, Semantics, Abstractions, Microservice, Event-driven Architecture
~

# Actor-based Concurrent Programming versus Reactive Microservices

* Abstract
* Preface
* Acknowledgements
* Table of Contents
* Introduction
    * Motivation
    * Scope of this Thesis
    * Methodology used
    * Road Map
* Programming Paradigms
    * Imperative and Procedual Programming
    * Object-oriented Programming
    * Functional Programming
    * Event-Driven and Flow-Driven Programming
    * Logic and Constraint Programming
    * Other Programming Paradigms

* Models of Concurrent Computation
    * Basic Concepts in Concurrency
        * Execution Order and Nondeterminism
        * Concurrency at the Programming Language Level
        * Concurrency at the Operating System Level
    * Threads, Locks and Shared State
    * Actors and Active Objects
    * Software Transactional Memory
    * Other Approaches and Concurrency Primitives

* The Microservice Architecture Style


* Event-driven Microservices
    * Event-driven Architectures



* Distributed Actors
    * From concurrent to distributed computing

    * Distribution Transparency
      : see [@Wal96] zu transparent RPC
    * Actor addressing

    * Virtual Distributed Actors
    * Autonomous Agents

    * Erlang Actors
    * Akka
    * (Other Frameworks: Orleans, Scala Actors)

* Similarities of Actors and Microservices

* Differences of Actors and Microservices

* Experiment
    * Scenario
    * Microservice-based Architecture
    * Actor-based Architecture
    * Discussion


* Discussion
    * Isolation
    * Open/well-defined Communication Interface
    * Scalability and Parallelization
    * Fault-tolerance
    * Resilience
    * Mobility


* Conclusion


--------


* Introduction
    * Motivation
    * Scope of this Thesis
    * Methodology used
    * Road Map
* Concurrent Programming
    * Sequential vs Concurrent Execution
    * Actor Model
    * Active Objects
    * Parallel and Distributed Execution
    * Distributed Actors (and Autonomouse Agents)
        * Distribution Transparency
          : see [@Wal96] zu transparent RPC
* Microservice Architecture
    * 

* A highly concurrent and distributed domain specific search engine
    * Search Engines Design and System Components
    * Podcasts: Decentralized media syndication

* Discussion
    * Isolation
    * Open/well-defined Communication Interface
    * Scalability and Parallelization
    * Fault-tolerance
    * Resilience
    * Mobility
* Conclusion


--------


* Abstract
* Preface
* Acknowledgements
* Table of Contents
* Introduction
    * Motivation
    * Scope of this Thesis
    * Methodology used
    * Road Map
* Concurrent Programming
    * Execution Order and Nondeterminism
    * Threads, Locks and Shared State
    * Concurrency at the Programming Language Level
        : allgemeines über die Abstraktionen von Nebenläufigkeit, zB Futures, STM, etc
    * Concurrency at the Operating System Level
        : The Process, Inter-process Communication, inherent concurrency
    * Concurrency at the Network Level
* Microservice Paradigm
    * Principles of MS
        : No shared state, etc
    * Communication Channels
        : Point to Point, Publish/Subscribe, Open/well-defined Communication Interface
    * Service Granularity: Size vs. Number of Services
        : "micro should refere to the scope of responsibility, not the lines of code"
    * Polyglot Programming
    * OO-Perspective
        * Are MS just Distributed Objects (done right)?
* Actor-based Programming
    * Basic Actor Idea
    * Isolation
        : every actor owns its state exclusively (should also have unique DB -> bad performance, discuss in Actor-Impl chapter)
    * Immutable Message Passing
    * Typed Actors/Active Objects
    * Combining Actor with other Concurrency Models
        * Futures
        * Software Transactional Memory (STM)
    * OO-Perspective
        * Data Abstractions
            : Encapsulation and Information Hiding
        * SOLID design principles
        * Design by Contract
        * Substitution and Behaviour
        * Are Actors (and Active Objects) just Distributed Objects?
* Common concerns of Concurrent, Parallel and Distributed Programming
    * Isolation and autonomy
        : "promise behaviour via API/protocol" --> design by contract
    * Communication and Data Coupling
        : Sync vs Async, Immutable Messages
    * Persistance
        : Polyglot Persistance, Event/Command Sourcing (??? brauche ich das? - vll für mehrere parallele Stores, wenn einer nachträglich online geht)
    * Fault tolerance
        : "failure isolation"
    * Resilience
        : "ability to heal from failure" - break free from strong coupling of synchron comm.; circuit breakers
    * Scalability
    * Load balancing
        * Server and Client Side LB
    * Elasticity / Code Mobility
        : Location transparency, elasticity = "move around in isolation"
* A Concurrent, Parallel and Distributed Problem Scenario: Domain Specific Search Engine 
    * Domain Description
        : Podcasts = Decentralized media syndication
    * Concurrent Tasks
        * Fetching data (feeds/websites), parsing data (feeds,websites), registering new entities (podcast/feeds, episodes), extending stores directory/index, serving search requests
    * Scalability Opportunities
        * Scalability through ??? (scaling up = changing allocated resources: memory, CPU)
        * Scalability through Parallelization and Distribution (scaling out)
    * Elasticity Considerations
    * Polyglot Persistence (based on Isolation)
* An Actor-based Problem Solution
    * Isolation
        : State + Behaviour
    * Synchronous and Asynchronous Communication
        : Channel types (point-to-point, pub/sub), specialized channels (dead letters, guaranteed delivery --> siehe "Akka in Action"); easy to get pub/sub or MQ routing behaviour via Routers (mostly same Actor as Supervisor); why not use JMS (it would offer both MQ/PubSub behaviour, but is not open and not lightweight)
    * Data Coupling
        : Messages are always "state at a specific point in time", but when the receiver gets it, it might already be outdated --> just live with it, no ACID; messages are transported via Actor System (e.g. Akka) and therefore data is coupled via the access to the API (e.g. only Scala/Java and compatible languages  - Groovy - may join the system); avoid any pattern that needs to wait for consensus between actors -> they should be able to make progress individually (vgl RegisterEpisodeIfNew, hier könnte auch der parser beim catalog nachfragen); message immutability (den ganzen aufwand den ich getrieben habe um die DTOs immutable zu kriegen, denn Akka macht pass by reference wen die nachricht innerhalb der selben JVM zugestellt wird --> und das macht probleme)
    * Persistence
        : Database (Postgres/Lucene) owning based on isolation, Subactor Handlers for DB access: many workers for one "logical" store because the backend data stores (DB, search index) can handle multiple connections --> breaking the "own your state exclusively paradigm"; Polyglot Persistance
    * Load balancing: 
        : Mailbox, Dispatcher, Command-query separation for stores (CQS, siehe wikipedia, definiert von Bertrand Meyer; create/update/delete = command messages need to be sent to all stores, read = query messages need only to be sent to one store --> **das hier vll eher ein Thema zu Event sourcing?**); Router and Routing Logic (Broker, RoundRobin)
    * Fault Tolerance
        : Supervision and Error Kernel
    * Resilience
    * Scalability
    * Elasticity / Code Mobility
        : Cluster / Remoting of Akka, built in discovery system among nodes  
    * Configuration, logging, and deployment
    * Performance measurement of Actors
* A Microservice-based Problem Solution
    * Isolation
        : State + Behaviour, Database (Postgres/Lucene) owning, Spring Thread Pool for DB access
    * Synchronous and Asynchronous Communication
        : REST and other lightweight stuff, async kafka (but offers only pub/sub), the case for AMQP/RabbitMQ for async jobs (leightweight, open protocol = polyglot, not like JMS) --> use PubSub/Kafka for DataStores (all stores need to update the data records) and MQ/AMQP for Workers (each job needs to be done by one worker)
    * Data Coupling
        * No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
    * Persistence
        : One DB per MS
    * Load balancing    
        * to be done manually in API gateway, or via MQ 
    * Cluster / Remoting
        : Was kann ich hier **allgemein** dazu sagen?; Entkopplung von fixen Adressen (Location Transparency)
    * Fault Tolerance
        : Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 
    * Resilience
    * Scalability,
    * Elasticity / Code Mobility
        : requires Discovery mechanism of clients, Consol (alternativ ZooKeeper, Eureka, etc) 
    * Configuration, logging, and deployment
    * Performance measurement of Microservices
* Evaluation
    * Software Quality Attributes
        : SOA qual. attr.
    * Quality Metrics
        * Internal Quality Metrics
            : Coupling metrics, cohesion metrics, granularity metrics, complexity metrics, autonomy metrics, reusability metrics
        * External Quality Metrics
    * Performance Measurement
* Discussion
    * The Case for Actors
        * Case Study: Why do Scala Programmers mix Actors with other Concurrency Constructs?
    * The Case for Microservices
    * Empirical Indications
        : Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refactorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
* Outlook & Conclusion
    : Services as First-Class Citizens
---

Some core papers/books I really need to include and focus on:

* Immutability Changes Everything. Helland, Pat. 2015
* Reactive Microservice Architectures. Boner Jonas. Book

---

Publicationen die ich vll brauchen kann, wenn ich gewissen Themenfelder bearbeite/argumentiere

## Concurrency Probleme durch Datenbanken

* Bernstein, P .; Hadzilacos, V .; Goodman, N. (1987). “Concurrency Control and Recovery in Database Systems”, Addison Wesley, ISBN 0-201-10715-5.

## Parallel/Distributed

* Isard, M.; Budiu, M.; Yu, Y.; Birrell, A.; Fetterly, D. (2007) “Dryad: Distributed Data-Parallel Programs from Sequential Building Blocks” European Conf on Computer Systems (EuroSys) 