

Sind MS == verteilte Objekte? 

Nein. Beim Konzept der vert. Obj wird der Ort des Obj versteckt. Dh bei einem Methodenaufruft ist mir nicht bekannt, ob das Obj lokal oder remote liegt. Da vert. Obj die selbe API wie "normale" (= lokale Obj) haben, habe ich keinerlei Hemmungen low-level API methoden anzuwenden. Bsp: Aufsummieren einer Eigenschaft "Size" über alle meine Objekte einer Kategorie. Bei lokalen Objekte iteriere ich über alle Objekte, rufe o.getSize() auf und summiere die Werte auf. Bei vert. Obj ist mir nicht bekannt ob die Objekte lokal oder remote liegen, deshalb sieht hier die Summenbildung entsprechend gleich aus. Bei angenommen 1000 Objekten führt dies im Worst Case zu 1000 separaten RPCs.
Bei Microservices würde man eine derartige API vermeiden, denn hier ist immer klar, welche Aufrufe lokal (innerhalb des MS) sind, und welche einen RPC (also den aufruf eines anderen MS) bewirken, da man aktiv zB die REST-Schnittstellen ansprechen muss. Um beim Summenbeispiel zu bleiben würde man hier entweder über lokale Elemente iterieren, oder einen ensprechenden Endpoint einrichten, welcher die Summe über alle Elemente eines entfernten MS anfordert.

=> MS != distr. Obj.

Sind Distributed Actors == verteilte Objekte  

Nein. Hier gilt im Prinzip das selbe Argument wie bei MS. Einen anderen Actor anzusprechen ist eine dedizierte Operation, die sich vom Aufruft der API eines "normalen" Objekts unterscheidet (am Ende läuft es auf den konkreten Syntax der Actor Implementierung hinaus, aber es sollte jedenfalls so sein - Akka macht es einem aus genau diesem Grund sehr sehr schwer einen Actor direkt mittels `new` zu instanzieren - was besonders bei der Java API auffällt - und verlangt stattdessen, dass man via einer `ActorRef` kommuniziert, welche ausschließlich das Senden von Actor-Nachrichten erlaubt, und alle direkten Methodenaufrufe verhindert).
Bzgl des Simmenbeispiels würde man entweder innerhalb des Actors alle Objekte durchiterieren, oder eine Nachricht an einen anderen Actor schicken, dass dieser über alle Objekte die dort vorhanden sind iteriert. Idealerweise sollte dieser dann auch gleich mit dem Ergebnis weiterarbeiten können, sodass der aktuelle Actor nicht auf eine Antwort warten muss. Somit ist auch bei Actors der lokale und der nebenläufige (ggf verteilte) Aufruft nicht zu verwechseln

Sind Active Obj == vert. Obj?

Possibly. Worin unterscheiden sich aktive Objekte von Actors? In der API. Es wird der Methodenaufruf von der Methodenausführung getrennt. Mit anderen Worten, in der Zeile nachdem man `actObj.doSomething()` aufgerufen hat, ist diese Methode noch nicht umbedingt garantiert fertig (ja es kann gut sein, dass sie noch nicht einmal angefangen wurde auszuführen). Aktive Objekte (jedenfalls in Akka) sind intern via Actors implementiert. Während man einem Aktor jede beliebige Nachricht schicken kann, und dieser **zur Laufzeit** unterscheidet ob er diese versteht/bearbeiten kann, ist bei einem aktiven Objekt durch die Ansprache des aktiven Objekts über eine Methode via das Typsystem **zur Compiletime** sichergestellt, dass der interne Actor die Nachricht auch verarbeiten kann (daher werden aktive Objekte in Akka auch "Typed Actors" genannt). Asynchron ist ein aufruf nur, wenn die Methoden alle `void` als Rückgabewert haben. Ansonsten handelt es sich beim Methodenaufrufs eines Typed Actors um einen synchronen Aufruft (!), und im Falle einer Ortsverteilung der beiden Akteure auch wieder nur um einen RPC. Daher können aktive Objekte in die selben Probleme laufen, wie sie vert. Objekte haben. 


Allgemeine Anmerkungen (von mir selbst frei geschrieben, ohne Literaturverweise bisher):

* Die Abstraktion verteilter Objekte ist "leaky". Die Problem sind in dem Paper "A Note on Distributed Computing" beschrieben (welches auch in der Akka Doku verlinkt wird). Eine Diskussion der Frage, ob MS nur vert. Objekte neu aufgelegt sind, und ob die verteilten Erweiterungen des Actor Models diese zu vert. Objekten machen (und somit automatisch zu deren Problemen führen), ist sicherlich wichtig und wertvoll! 

* Distributed Objects was a concept of some 20 years ago. Here, objects did not have to exists within the same program boundary, but could be distributed across multiple programs and therefore host machines. Examples of such are Java RMI or CORBA. They seem to share many conceptual similarities that we are discussing here. On the one hand, the design goals of Microservices seem to aim towards the single-purpose, minimal and slim skeleton that distributed objects have compared to full-fletched monolithic applications. On the other hand, their distributed nature inherently lead towards the possibilities of transparent concurrent/parallel execution, like actors or active objects do. However, distributed objects were found to be a "leaky" abstraction, due to some conceptual problems. Therefore we should discuss weither Microservices, Actors and Active Objects are in fact distributed Objects, which would mean that the same problems would also occur with them.
    1. Do Microservices qualify as Distributed Objects?
    2. Do (Distributed) Actors qualify as Distributed Objects?
    3. Do (Distributed) Active Objects qualify as Distributed Objects?

    => die Diskussionen siehe oben