
# Conclusion {#ch-conclusion}

...

## Outlook and Future Work


<!--
~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~
-->


We've evaluated the conceptualities of Actors and Microservices, formulated arguments favoring each, and motivated their potential integration. In this final section, we want to argue a conceptual evolution towards a unification.

For the scope of this thesis, we've found it rather difficult to narrow on the essential characteristics that constitute the Microservice paradigm. We believe this observation to be also reflected in the literature, where we've frequently found authors to tend to fairly short, unilateral or superficial definitions for the sake of an easier and more focused argumentation. For example, REST is by far the most popularly pointed out mechanism of sole communication, without entertaining neither the possibility nor implications of other and especially non request/response channels.

In our opinion this is due to the fact that the Microservice style, although conceived as an aim towards minimalistic components, is on the other hand too allowing in general regarding the conception options for each single service of any system. The lack of a more coherent technological context among at least some or even all service components also hinders the introduction of enhancing concepts. Challenges regarding behavioral types, choreographies or means of verification have already been outlined. Such would only be possible with greater difficulties and come with restrictions nevertheless. As was motivated, languages dedicated to the service-oriented programming paradigm offer the potential towards overcoming this limitation. Even more, if these languages are based on a process calculus, such open up the potentials of their profound theoretical properties and resulting possibilities. 

Some authors, like Bonér [@Bon16;@Bon17], are advocating for Microservices following the conceptualities as are outlined by the Actor model. However, this raises the legitimate question of why an Actor approach should not be pursued in the first place? As Guidi *et al.*\ [@Gui17] point out, general purpose languages utilizing mechanisms that are competing with Microservice concerns, like concurrency and scalability, do not provide a conceptual distinction between the behavior of a task and the deployment thereof. This is true even for very sophisticated Actor language like Erlang and Orleans, as well as equally potent frameworks like Akka. 

It is our believe however, that service-oriented programming languages are already fostering components that are following many of the conceptualities of Actors. CAOPLE services for example are limited to asynchronous communication [@Xu16]. Yet SOP languages keep the openness of well-defined interfaces, such that the interoperability of heterogenous technologies is ensured, while their preservation of independent deployment capabilities allows for gradual replacement and evolution. This decoupling of technological dependencies are a valuable for future proof system development and maintenance.

We see ourselves affirmed in the literature, from a theoretical as well as a practical perspective. As has been pointed out, Agha *et al.*\ [@Agh97] argument towards regarding high-level language semantics instead, and then reason about equivalence to actor- and in their case &pi;-programs. We see constructs and conceptualities of the service-oriented programming paradigm exactly as such high-level language concepts and their semantics is convenient to be compared to Actor and Microservice programming, as we've aimed to point out throughout this thesis. On the other hand, Bonér is arguing for an evolution of the Microservice principles towards reactive systems which are more closer to Actor systems in general [@Bon16]. We've found his arguments to have resemblance to the fundamentals of process algebra theory.

As a result, it is our believe that language-based solutions are worth future endeavors. Promising prototypes as Jolie essentially produce constructs that are rather similar to Actors - except that the creation of new components is not an essential primitive. The profound foundation on process algebra and other theoretical concepts provide the basis for applying formal methods to introduce advanced mechanisms. For example, a Curry-Howard isomorphism has been shown between session types and the &pi;-calculus process model which resulted further work, e.g.\ how multiparty sessions (multiple services interactions) relate to certain techniques of logical reasoning, or a support for parametric polymorphism in behavioral types by reconstruction in classical linear logic. Such findings provide a strong indication that correct Microservice system conception can also be improved through such techniques [@Dra17a]. 

The utilization of such formalisms is of course possible for the enhancement of the Actor model too, e.g.\ as was done by introducing the *Join* calculus into Erlang Actors to allow internal parallelization and deterministic concurrency [@Kan15].

In any case, Actor and Microservice technologies can greatly influence their mutual evolution by *learning from* and *growing closer too* each other. For example, Akka already provides circuit breakers for `ask`-calls within its HTTP module. Additionally, Akka cluster nodes (in the version Echo is using) require static configuration for initial discovery. Just recently, automatic discovery capability using the Consul service registry has been merged into the Akka codebase for a future release.   

<!--
Languages like Jolie demonstrate how (micro-)service oriented computing can be facilitated on a language level. Microservices in general, and Jolie in particular, are having much in common with Actor Systems, as we've described in this thesis. Besides concurrency, concerns like scalability and [???]{.mind} are approached well by matured technologies like Akka or Erlang, on a programming language level [@Gui17]. However, their Actor abstraction prevents them from facilitating multiple communication channels in a uniform way, as was just demonstrated for HTTP. Service-oriented languages on the other hand can integrate multiple channels and their respective protocols in a seamless way. Extending Jolie programs with HTTP is demonstrated in [@Mon16b].
-->

~ todo
Future Work
~

We deem it worth to investigate if there are theoretical frameworks incorporating both actors and microservices

* As we've demonstrated, Spring-based microservices produce heavy-weighted executable JAR files. The reason for the resulting size is that all dependencies are included into these JARs by the Java 8 compiler. However, great parts of these libraries are potentially never used. Recent trends in the Java evolution lead to Project Jigsaw (<http://openjdk.java.net/projects/jigsaw/>) starting from Java 9 and above. Jigsaw is an umbrella term for tools to create smaller runtimes with merely the required parts of the original JDK [TODO: stimmt das wirklich? Ist das nur das JDK was abgeschnitten wird, oder auch alle Libraries?]{.red}. It is worth to investigate the potential byte size savings as well as the resulting performance improvements.  

* Worth to investigate the applicability of the actor model as the microservice internal concurrency approach.