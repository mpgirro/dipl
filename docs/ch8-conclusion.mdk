
# Conclusion {#ch-conclusion}


~ Epigraph { caption: "Henry David Thoreau"}
The price of anything is the amount of life you exchange for it.
~


...

~ todo
Hier soll 1 SEITE! sein in der ich zusammenfasse wie ich die Research Questions beantwortet habe, welche Contributions ich gemacht habe, was die Ergebnisse/Erkenntnisse waren und 1-2 Sätze zu Future Work. Mehr nicht!
~

...



* We've pointed out differences of Erlang and Orleons compared to Akka


~ todo
Future Work
~

FUTURE WORK (kürzer geschrieben)

* We've motivated the integration of Akka actors and Spring-based microservices in Section [#sec-combining-akka-spring]. Investigate the effects on efficiency within a mixed architecture integrating actors and microservices as equal concurrent task units.

* Since actors and microservices share so many similarities, future work includes the investigation of a theoretical link between the actor model and a SOC calculus.

FUTURE WORK 1:

We did not benchmark horizontal scalability to several machines. Also, we did not integrate actors and microservices into the same system architecture as equal concurrent task units for our benchmark. We deem it interresting if efficiency is improved by a combination approach of two task unit variants.

* From a more theoretical point of view, we see the integration of actors and microservices relevant. 

* For that, service-oriented computing languages provide in our view the right foundation, since the microservice model lacks a formal framework

* The microservice model in our architecture lacks a formal framekwork (process calculus)

* Also, a major limitation of both actors and microservices is the lack of checkable compatibility (*design by contract*). Some work on static analysis for actors has been done in the literature. The work by D'Osualdo *et al.* [@DOs13] for example defines a checkable model for Erlang-styled concurrency. This model can be also expressed as processes of a suitable calculus. Recall that service-oriented computing languages incorporating microservices into the language level built upon process calculi. We deem it worth to investigate into contract verification tequniques for the actor model and SOC calculi, towards a theoretical foundation for integrating actors and microservices.



FUTURE WORK 2:

We deem it worth to investigate if there are theoretical frameworks incorporating both actors and microservices

* As we've demonstrated, Spring-based microservices produce heavy-weighted executable JAR files. The reason for the resulting size is that all dependencies are included into these JARs by the Java 8 compiler. However, great parts of these libraries are potentially never used. Recent trends in the Java evolution lead to Project Jigsaw (<http://openjdk.java.net/projects/jigsaw/>) starting from Java 9 and above. Jigsaw is an umbrella term for tools to create smaller runtimes with merely the required parts of the original JDK [TODO: stimmt das wirklich? Ist das nur das JDK was abgeschnitten wird, oder auch alle Libraries?]{.red}. It is worth to investigate the potential byte size savings as well as the resulting performance improvements.  

* Worth to investigate the applicability of the actor model as the microservice internal concurrency approach.


~ todo
Der Text unten ist schon nicht schlecht. Allerdings will ich sagen das ich eigentlich SOC languages super und wertvoll finde. Und da wir gezeigt haben das Actors schon oft in Programmiersprachen eingebaut wurden, und wir gezeigt haben wie ähnlich sich Actors und Microservices sind, ist hier viel mehr potential für Arbeit da. 

Außerdem finden wir das zB eben Design by Contract in beiden fällen zu kurz kommt. Hier könnte man eine verbindende Arbeit durchführen. Blablabla
~


In the course of this work, we've found a weakness of actors as well as microservices. Their limitation of checkable compatibility (cf. *design by contract*) is presenting [???]{.red}. Actors intrinsically type messages dynamically upon processing. The high degree of usable communication mechanisms and the lack of building upon a formal framework (process calculus) hinders a universal interface checker for microservices. Some work on static analysis for actors, especially Erlang, has been done in the literature. D'Osualdo *et al.* [@DOs13] for example defined a checkable model for Erlang-styled concurrency. This model can be also expressed as processes of a suitable calculus. We believe that service-oriented process calculi are a suitable evolutionary step for microservices. Due to the high similarity between actors and microservices, we beliefe that theoretical work that has been done for actors is viable for 

The theoretical work that has been done for actors is suitable for the foundation of further work. 

* Work on Design by Contract capabilities:
    * Akka homogenous interface, but intrinsically dynamically typed. 
    * MSA free for all kinds of mechanism, every technology stack with own interface, hard to do any kind of compatibility checking
    * Investigate further into capabilities/methodologies/technologies/opportunities/etc.


---

## Outlook and Future Work


<!--
~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~
-->


We've evaluated the conceptualities of Actors and Microservices, formulated arguments favoring each, and motivated their potential integration. In this final section, we want to argue a conceptual evolution towards a unification.

For the scope of this thesis, we've found it rather difficult to narrow on the essential characteristics that constitute the Microservice paradigm. We believe this observation to be also reflected in the literature, where we've frequently found authors to tend to fairly short, unilateral or superficial definitions for the sake of an easier and more focused argumentation. For example, REST is by far the most popularly pointed out mechanism of sole communication, without entertaining neither the possibility nor implications of other and especially non request/response channels.

In our opinion this is due to the fact that the Microservice style, although conceived as an aim towards minimalistic components, is on the other hand too allowing in general regarding the conception options for each single service of any system. The lack of a more coherent technological context among at least some or even all service components also hinders the introduction of enhancing concepts. Challenges regarding behavioral types, choreographies or means of verification have already been outlined. Such would only be possible with greater difficulties and come with restrictions nevertheless. As was motivated, languages dedicated to the service-oriented programming paradigm offer the potential towards overcoming this limitation. Even more, if these languages are based on a process calculus, such open up the potentials of their profound theoretical properties and resulting possibilities. 

Some authors, like Bonér [@Bon16;@Bon17], are advocating for Microservices following the conceptualities as are outlined by the Actor model. However, this raises the legitimate question of why an Actor approach should not be pursued in the first place? As Guidi *et al.*\ [@Gui17] point out, general purpose languages utilizing mechanisms that are competing with Microservice concerns, like concurrency and scalability, do not provide a conceptual distinction between the behavior of a task and the deployment thereof. This is true even for very sophisticated Actor language like Erlang and Orleans, as well as equally potent frameworks like Akka. 

It is our believe however, that service-oriented programming languages are already fostering components that are following many of the conceptualities of Actors. CAOPLE services for example are limited to asynchronous communication [@Xu16]. Yet SOP languages keep the openness of well-defined interfaces, such that the interoperability of heterogenous technologies is ensured, while their preservation of independent deployment capabilities allows for gradual replacement and evolution. This decoupling of technological dependencies are a valuable for future proof system development and maintenance.

We see ourselves affirmed in the literature, from a theoretical as well as a practical perspective. As has been pointed out, Agha *et al.*\ [@Agh97] argument towards regarding high-level language semantics instead, and then reason about equivalence to actor- and in their case &pi;-programs. We see constructs and conceptualities of the service-oriented programming paradigm exactly as such high-level language concepts and their semantics is convenient to be compared to Actor and Microservice programming, as we've aimed to point out throughout this thesis. On the other hand, Bonér is arguing for an evolution of the Microservice principles towards reactive systems which are more closer to Actor systems in general [@Bon16]. We've found his arguments to have resemblance to the fundamentals of process algebra theory.

As a result, it is our believe that language-based solutions are worth future endeavors. Promising prototypes as Jolie essentially produce constructs that are rather similar to Actors - except that the creation of new components is not an essential primitive. The profound foundation on process algebra and other theoretical concepts provide the basis for applying formal methods to introduce advanced mechanisms. For example, a Curry-Howard isomorphism has been shown between session types and the &pi;-calculus process model which resulted further work, e.g.\ how multiparty sessions (multiple services interactions) relate to certain techniques of logical reasoning, or a support for parametric polymorphism in behavioral types by reconstruction in classical linear logic. Such findings provide a strong indication that correct Microservice system conception can also be improved through such techniques [@Dra17a]. 

The utilization of such formalisms is of course possible for the enhancement of the Actor model too, e.g.\ as was done by introducing the *Join* calculus into Erlang Actors to allow internal parallelization and deterministic concurrency [@Kan15].

In any case, Actor and Microservice technologies can greatly influence their mutual evolution by *learning from* and *growing closer too* each other. For example, Akka already provides circuit breakers for `ask`-calls within its HTTP module. Additionally, Akka cluster nodes (in the version Echo is using) require static configuration for initial discovery. Just recently, automatic discovery capability using the Consul service registry has been merged into the Akka codebase for a future release.   

<!--
Languages like Jolie demonstrate how (micro-)service oriented computing can be facilitated on a language level. Microservices in general, and Jolie in particular, are having much in common with Actor Systems, as we've described in this thesis. Besides concurrency, concerns like scalability and [???]{.mind} are approached well by matured technologies like Akka or Erlang, on a programming language level [@Gui17]. However, their Actor abstraction prevents them from facilitating multiple communication channels in a uniform way, as was just demonstrated for HTTP. Service-oriented languages on the other hand can integrate multiple channels and their respective protocols in a seamless way. Extending Jolie programs with HTTP is demonstrated in [@Mon16b].
-->




