
# Conclusion {#ch-conclusion}


~ Epigraph { caption: "Henry David Thoreau"}
The price of anything is the amount of life you exchange for it.
~


In this thesis, we compared the programming of concurrent computation with the actor and microservice model. We've explored the interrelations of the two models and filled a gap in the literature. In order to do so and answer our research questions, we've designed Echo, a domain-specific search engine as a concurrent system prototype scenario. We also provide an actor implementation based on Akka as well as a microservice implementation based on the Spring framework of this system scenario. Finally, we gave an [evaluation/comparison]{.red} of the expressable capabilities of each model, and an efficiency benchmark of the system implementations.


## Research Questions Revisited


[TODO]{.red}


### RQ1: Why do actors and microservices qualify for programming concurrency? { -; toc:clear }


Actors and microservices encapsulate their state exlusively and all their communication solely facilitates message passing semantics. These properties provide a temporal and spacial decoupling, which allows for their implicit concurrent execution through an actor runtime or an operating system respectively.  


### RQ2: How is concurrency facilitated in the actor and microservice programming model? { -; toc:clear }



The execution modality of actors and microservices already introduces concurrency among the task units. Both models can also utilize additionally concurrency sources. The actor model has a long tradition of using futures, e.g.\ for (semi-)synchronous communication abstractions. In general, actors can be combined with every other concurrency model, as long as the combination does not introduce new safety or liveness issues. 

Microservices are free to employ internal concurrency using every model available to their technology stack.

[TODO more]{.red}


### RQ3: What are the expressive capabilities of actors and microservices regarding concurrent programming concerns like parallelization/distribution, communication, and scalability? { -; toc:clear }

[TODO]{.red}

We've shown that both models have to apply different implementation strategies, but can achieve the same capabilities in general. Their implementation strategies come with different trade-offs for each model.

In general, we can expect larger executable artifacts and more resource consumption from the microservice approach, since the model produces independent programs. The author initially expected that the microservice style would also show a significantely higher programming effort, e.g.\ in lines of code. The suspected reason was the need to maintain a dedicated codebase for each service. However, we demonstrated how a declarative programming styles can significantely reduce the programming effort. The price is the resulting size of the executable artifacts.  

The actor model achieves the same capabilities in a single codebase. This single codebase implies that at least a portion of the actors (in a distributed deployment) exist within the same process and memory boundires. Much of the programmer's effort results from the liability of guaranteeing that no mutable state is accessible through reference sharing among any two actors to ensure the model semantics.


### RQ4: How does the performance between actors and microservices compare in a multi-core environment relative to a concurrent system scenario? { -; toc:clear }


[TODO ein paar Sätze zu den Ergebnissen des Benchmarks]{.red}

The benchmark results show that, in the context of our scenario, the performance of actors is generally better than the performance of microservices. Since we've ensured that the domain-induced impact on the performance is uniform between both system implementations, the difference in the performance results from the efficiency leveraged from the underlying concurrent programming model. We've also shown that microservices facilitating an asynchronous communication style have merely a slight overhead compared to actors, [which is a result of the communication mechanism and the programming model]{.red}. However, the benchmark also exposed that strictly synchronous communication (request/response) among services shows a clear [?nachteil/verschlechterung?]{.red} compared to the request/asynchronous response style facilitated by actors. 


## Future Work


In this thesis, we did not benchmark the effects of distribution due to our limited access to hardware resources. Also, although we've motivated the integration of Akka actors and Spring-based microservices in Section [#sec-combining-akka-spring], we did not investigate the effects on efficiency within a mixed architecture integrating actors and microservices as equal concurrent task units.

A major limitation of both actors and microservices is the lack of checkable compatibility (design by contract). Some work on static analysis for actors has been done in the literature. The work by D'Osualdo *et al.* [@DOs13] for example defines a checkable model for Erlang-styled concurrency. This model can be also expressed as processes of a suitable calculus. Recall that service-oriented programming languages incorporate the microservice model into the language level, and sometimes build upon a process calculus. We deem it worth to fathom into contract verification techniques for the actor model and SOC calculi, towards a theoretical foundation for integrating actors and microservices.

Besides, from our experiences in this work, it is the authors general believe that the microservice styles suffers from the lack of a theoretical framework. We therefore think that service-oriented programming languages are a highly promising evolutionary step, which is worth further investigation.

<!--

We deem it worth to investigate further into service-oriented programming languages

...

From our experiences in this work, it is the authors believe that the microservice styles suffers from the lack of a theoretical framework. Service-oriented programming languages, and their foundation on service-oriented computing calculi try to fill this deficiency. 


---

FUTURE WORK (kürzer geschrieben)

* We've motivated the integration of Akka actors and Spring-based microservices in Section [#sec-combining-akka-spring]. Investigate the effects on efficiency within a mixed architecture integrating actors and microservices as equal concurrent task units.

* Since actors and microservices share so many similarities, future work includes the investigation of a theoretical link between the actor model and a SOC calculus.

FUTURE WORK 1:

We did not benchmark horizontal scalability to several machines. Also, we did not integrate actors and microservices into the same system architecture as equal concurrent task units for our benchmark. We deem it interresting if efficiency is improved by a combination approach of two task unit variants.

* From a more theoretical point of view, we see the integration of actors and microservices relevant. 

* For that, service-oriented computing languages provide in our view the right foundation, since the microservice model lacks a formal framework

* The microservice model in our architecture lacks a formal framekwork (process calculus)

* 

* Actors and Microservices can be (semi)-independently upgraded, but there is no guarantee/ensurance for compatibility of new versions -> Design by Contract

FUTURE WORK 2:

We deem it worth to investigate if there are theoretical frameworks incorporating both actors and microservices

* As we've demonstrated, Spring-based microservices produce heavy-weighted executable JAR files. The reason for the resulting size is that all dependencies are included into these JARs by the Java 8 compiler. However, great parts of these libraries are potentially never used. Recent trends in the Java evolution lead to Project Jigsaw (<http://openjdk.java.net/projects/jigsaw/>) starting from Java 9 and above. Jigsaw is an umbrella term for tools to create smaller runtimes with merely the required parts of the original JDK [TODO: stimmt das wirklich? Ist das nur das JDK was abgeschnitten wird, oder auch alle Libraries?]{.red}. It is worth to investigate the potential byte size savings as well as the resulting performance improvements.  

* Worth to investigate the applicability of the actor model as the microservice internal concurrency approach.


~ todo
Der Text unten ist schon nicht schlecht. Allerdings will ich sagen das ich eigentlich SOC languages super und wertvoll finde. Und da wir gezeigt haben das Actors schon oft in Programmiersprachen eingebaut wurden, und wir gezeigt haben wie ähnlich sich Actors und Microservices sind, ist hier viel mehr potential für Arbeit da. 

Außerdem finden wir das zB eben Design by Contract in beiden fällen zu kurz kommt. Hier könnte man eine verbindende Arbeit durchführen. Blablabla
~


In the course of this work, we've found a weakness of actors as well as microservices. Their limitation of checkable compatibility (cf. *design by contract*) is presenting [???]{.red}. Actors intrinsically type messages dynamically upon processing. The high degree of usable communication mechanisms and the lack of building upon a formal framework (process calculus) hinders a universal interface checker for microservices. Some work on static analysis for actors, especially Erlang, has been done in the literature. D'Osualdo *et al.* [@DOs13] for example defined a checkable model for Erlang-styled concurrency. This model can be also expressed as processes of a suitable calculus. We believe that service-oriented process calculi are a suitable evolutionary step for microservices. Due to the high similarity between actors and microservices, we beliefe that theoretical work that has been done for actors is viable for 

The theoretical work that has been done for actors is suitable for the foundation of further work. 

* Work on Design by Contract capabilities:
    * Akka homogenous interface, but intrinsically dynamically typed. 
    * MSA free for all kinds of mechanism, every technology stack with own interface, hard to do any kind of compatibility checking
    * Investigate further into capabilities/methodologies/technologies/opportunities/etc.


---



## Outlook and Future Work
-->

<!--
~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~
-->

<!--
~ green

We've evaluated the conceptualities of Actors and Microservices, formulated arguments favoring each, and motivated their potential integration. In this final section, we want to argue a conceptual evolution towards a unification.

For the scope of this thesis, we've found it rather difficult to narrow on the essential characteristics that constitute the Microservice paradigm. We believe this observation to be also reflected in the literature, where we've frequently found authors to tend to fairly short, unilateral or superficial definitions for the sake of an easier and more focused argumentation. For example, REST is by far the most popularly pointed out mechanism of sole communication, without entertaining neither the possibility nor implications of other and especially non request/response channels.

In our opinion this is due to the fact that the Microservice style, although conceived as an aim towards minimalistic components, is on the other hand too allowing in general regarding the conception options for each single service of any system. The lack of a more coherent technological context among at least some or even all service components also hinders the introduction of enhancing concepts. Challenges regarding behavioral types, choreographies or means of verification have already been outlined. Such would only be possible with greater difficulties and come with restrictions nevertheless. As was motivated, languages dedicated to the service-oriented programming paradigm offer the potential towards overcoming this limitation. Even more, if these languages are based on a process calculus, such open up the potentials of their profound theoretical properties and resulting possibilities. 

Some authors, like Bonér [@Bon16;@Bon17], are advocating for Microservices following the conceptualities as are outlined by the Actor model. However, this raises the legitimate question of why an Actor approach should not be pursued in the first place? As Guidi *et al.*\ [@Gui17] point out, general purpose languages utilizing mechanisms that are competing with Microservice concerns, like concurrency and scalability, do not provide a conceptual distinction between the behavior of a task and the deployment thereof. This is true even for very sophisticated Actor language like Erlang and Orleans, as well as equally potent frameworks like Akka. 

It is our believe however, that service-oriented programming languages are already fostering components that are following many of the conceptualities of Actors. CAOPLE services for example are limited to asynchronous communication [@Xu16]. Yet SOP languages keep the openness of well-defined interfaces, such that the interoperability of heterogenous technologies is ensured, while their preservation of independent deployment capabilities allows for gradual replacement and evolution. This decoupling of technological dependencies are a valuable for future proof system development and maintenance.

We see ourselves affirmed in the literature, from a theoretical as well as a practical perspective. As has been pointed out, Agha *et al.*\ [@Agh97] argument towards regarding high-level language semantics instead, and then reason about equivalence to actor- and in their case &pi;-programs. We see constructs and conceptualities of the service-oriented programming paradigm exactly as such high-level language concepts and their semantics is convenient to be compared to Actor and Microservice programming, as we've aimed to point out throughout this thesis. On the other hand, Bonér is arguing for an evolution of the Microservice principles towards reactive systems which are more closer to Actor systems in general [@Bon16]. We've found his arguments to have resemblance to the fundamentals of process algebra theory.

As a result, it is our believe that language-based solutions are worth future endeavors. Promising prototypes as Jolie essentially produce constructs that are rather similar to Actors - except that the creation of new components is not an essential primitive. The profound foundation on process algebra and other theoretical concepts provide the basis for applying formal methods to introduce advanced mechanisms. For example, a Curry-Howard isomorphism has been shown between session types and the &pi;-calculus process model which resulted further work, e.g.\ how multiparty sessions (multiple services interactions) relate to certain techniques of logical reasoning, or a support for parametric polymorphism in behavioral types by reconstruction in classical linear logic. Such findings provide a strong indication that correct Microservice system conception can also be improved through such techniques [@Dra17a]. 

The utilization of such formalisms is of course possible for the enhancement of the Actor model too, e.g.\ as was done by introducing the *Join* calculus into Erlang Actors to allow internal parallelization and deterministic concurrency [@Kan15].

In any case, Actor and Microservice technologies can greatly influence their mutual evolution by *learning from* and *growing closer too* each other. For example, Akka already provides circuit breakers for `ask`-calls within its HTTP module. Additionally, Akka cluster nodes (in the version Echo is using) require static configuration for initial discovery. Just recently, automatic discovery capability using the Consul service registry has been merged into the Akka codebase for a future release.   
~

-->

<!--
Languages like Jolie demonstrate how (micro-)service oriented computing can be facilitated on a language level. Microservices in general, and Jolie in particular, are having much in common with Actor Systems, as we've described in this thesis. Besides concurrency, concerns like scalability and [???]{.mind} are approached well by matured technologies like Akka or Erlang, on a programming language level [@Gui17]. However, their Actor abstraction prevents them from facilitating multiple communication channels in a uniform way, as was just demonstrated for HTTP. Service-oriented languages on the other hand can integrate multiple channels and their respective protocols in a seamless way. Extending Jolie programs with HTTP is demonstrated in [@Mon16b].
-->




