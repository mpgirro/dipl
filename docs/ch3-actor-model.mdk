
The Actor Model {#ch-actor-model}
===============

~ Epigraph { caption: "C.A.R. Hoare"}
Some problems are better evaded than solved.
~


<!--## A Model of Computation {#sec-actor-primitives}-->


In this thesis, we will focus on one particular abstraction for modelling concurrent computation. It is based on a formalism Hewitt *et al.* [@Hew73] introduced in the 1970s. As the models name suggests, at its foundation it builds upon the abstraction of *Actors* as basic building blocks. Agha describes them a self-contained, interactive and independent components that are communicating via asynchronous message passing [@Agh90]. He also reformulated the Actor model into three basic primitives they can perform upon receiving a message [@Agh85a]:

1. Sending a finite number of messages to itself or other known actors.
2. Creating a finite number of new actors.
3. Changing its internal behavior for the next message that it receives with the so-called *replacement behavior*.

In order to send a message, the unique *address* of an Actor must be known. The underlying system delivers the message. In general, the order of delivery is nondeterministic. Actor addresses can be announced to other Actors by sending the address as a message. This allows for *dynamic reconfiguration* [@Agh90].

Messages are processed one at a time. Therefore, they have to be buffered in the so-called *mailbox* if an Actor is not able to process an incoming message immediately, because it is already engaged in a message handling operation. Accessing the mailbox is race-free, and therefore safe [@Hal09].


## Message Passing and Encapsulation {#sec-actor-messaging-encapsulation}


The Actor abstraction defines that the only possible form of communication between Actors is by exchanging messages. This implies that there is no directly shared state between them. Actor semantic means state is *encapsulated* within an Actor exclusively. To access the state, it must be requested by sending an appropriate message. 

Processing messages is done in a serialized fashion. This provides the basis for *isolation* [@Les09]. All state modifications done while processing a single message appears *atomic*, i.e.\ it is not interrupted by other messages to the Actor [@Agh99], because they get buffered inside the mailbox.

It is important to realize that requested state informations are always mere snapshots of an Actor's state at a specific point in time (the point where this Actor processes the requesting message), and the information can therefore already be outdated once the requestor receives the snapshot answer [@And83]. On the other hand, the isolation of state frees Actors from the implications that shared state or resource handling bring with them, like bottlenecks introduced by sequential locking [@Agh90].  

To ensure snapshots do not violate encapsulation semantics and prevent accidentally exposing direct access to any internal state or resource, passed messages must be guaranteed to be immutable, copied or proxied [@Kos16]. This allows save coordination at a distance [@Hel15]. 

Changing internal state within an Actor is realized through the third of the basic primitives: behavior replacement. In general, this primitive can be used to change the behavior of the Actor entirely - in the Actor taxonomy also called to *become* different operations for all following messages. However, it can also become the same operations, but for a different state [@Weg90]. It is important that this action though does not break the *referential transparency* of the Actors identifiers used to send messages to it [@Agh90]. Therefore, changing Actor internals has no effect on its reachability for other Actors. The Actor logically stays the same, but will behave differently when processing the next message.

This strict encapsulation of state and decoupling via immutable, asynchronous message passing leads to a strong form of *isolation* between Actors [@Agh14]. State within an Actor is mutable, but isolated from the outside and only available through immutable snapshots.

Additionally, state can only be changed while processing a message. Therefore, as De Koster *et al.* illustrate in detail, the processing of a single message can be viewed as an isolated operation. This is important when reasoning about Actors, as it is done with respect to the single-threaded semantic which is providing the granularity of a turn[^fn-isolated-turn-principle] [@Kos16;@Ber14]. They call this *Isolated Turn Principle*. It guarantees the safety of Actors, as they are free of low-level data races (for only one message is processed at a time, and each message belongs to a single Actor), but high-level races (depending on the interleaving of messages within the mailbox) can still occur. It also guarantees computation progress with each turn [@Agh97], and thus liveness. 

[^fn-isolated-turn-principle]: In this context, *turn* is used to refer to the processing of a single message. Various terminologies have been used for this over the decades. A good overview of Actor model taxonomy and the equivalence of various terms is given in [@Kos16].


## Unified Abstraction
<!--## Unifying Concurrent, Parallel and Distributed Computation-->


Until now, the Actor model has been described as a general model of computation. The abstraction of Actors provides a strict separation of components state, as well as a loose coupling via asynchronous message passing. As such, Actors encapsulate not only data and functionality, but also their own *thread of control*, making Actors autonomous [@Agh99]. This allows for a concurrent execution of such components, effectively making the Actor abstraction into a model of *inherent concurrent computation* [@Agh91]. 

There are numerous models that are able to provide inherent concurrency, such as logic programming or  functional programming. The benefit of the Actor abstraction however is, that it supports a direct expression of state [@Agh91]. This state can only be manipulation within an Actor and while it is processing a message -- an operation that is guaranteed to be atomic, as was pointed out. Omitting to share state and only communicating it via asynchronous message passing greatly improves the safety of Actors, as it eliminates a whole class of errors, the *race conditions* [@Cha13]. 

The dynamic data flow of messages is the primary source of nondeterminism. No order of messages is guaranteed when multiple Actors send messages to the same Actor. The actual order of processing the messages affects the behavior, resulting in nondeterminism. The benefit of not enforcing a message order eliminates unnecessary synchronization overhead [@Kar09; @Agh90; @Agh99].

The Actor model provides a strict concept of isolated and decoupled components. The only link between Actors is the delivery of messages, based on their addresses. These addresses are virtual by not exposing any physical location information [@Ber14; @Tas13]. Actors are therefore not restricted to physical locations by their addresses. As a result, concurrently executed components are not required to be inside the same process boundary, nor the same host machine in fact, because the addresses can bridge the gap in physical distance. Separating virtual and physical location is generally referred to as *location transparency* [@Kar09;@Agh99]. The concurrent components of the Actor model inherently also support parallel component execution, as they can be transparently assigned to processor cores.

Additionally, location transparent addresses enable referencing Actors even outside the scope of a CPU, providing the foundation for distributed execution on different nodes [@Kar09]. Execution on the same CPU is therefore often referred to as *intra-node*, while distributed execution as *inter-node* parallelism [@Reh13]. Inter-node components are still physically close, and can assume that their communication channel is reliable. Inter-node components can make no safe assumption on the safety and reliability of their communication channel, except of being more costly and volatile in any case [@Agh99]. Thus, a particular characteristic of the Actor Model is its facilitation of one and the same primitive for task unit communication in concurrent, parallel and distributed execution contexts.


## Actor Systems and Variations {#sec-actor-systems}


Actors are computational entities, but not individually deployable on operating systems in general. They require a runtime environment to exist within, the so-called *Actor system*. Such have two general concerns: providing the linguistic support for utilizing its Actors (programming interface and model semantic) and achieving their efficient execution [@Kar09]. 

Depending on the underlying programming model, the Actor abstraction and primitives can pose a challenge for programmers, as the model primitives provide a very low-level abstraction to model computation via an (almost) pure communication paradigm. Thus, Actor systems tend to provide more high-level primitives [@Agh90;@Weg90], e.g.\ for expressing various communication patterns.

Efficiency can pose a challenge, as the idioms of the underlying system must be used to map concurrency to the Actor abstraction. In thread-based environments like the *Java Virtial Machine* (JVM), the relatively heavy JVM threads provide the foundation for the execution of relatively light-weighted Actor constructs. The JVM maps its threads to OS processes, thus each Actor would be executed as a system process in general. Haller & Odersky [@Hal09] call this an "impedance mismatch" between message passing (event-based) and thread-based programming. In this concrete example, the negative impact could be mitigated by not assigning one thread per Actor, but using a scheduling strategy such that many Actors may share the resources provided by fewer threads [@Kar09]. 

Many Actor system implementations do exist. We've identified three that merit special attention, as they are to out knowledge the most significantly applied in industrial applications. They will be referred to with varying relevance throughout the remainder of this work.

*Erlang* [@Arm93;@Vin07] is a programming language dedicated to Actor-based programming, and is well-known for introducing the concept to a broader industrial application. In contrast to most programming languages, an Erlang program has the main focus on the *processes* constructs (Actors), rather than e.g.\ objects or functions. It was designed to meet challenges like high concurrency, availability, fault-tolerance and live-upgrades [@Vin07;@Kos16].

*Akka* [@LightbendAkka] is an Actor framework for the JVM, offering bindings for the Java and Scala programming languages. It was highly inspired by Erlang and facilitates many of its conceptualities in order to meet similar concerns like scalability, fault tolerance and remoting/distribution. As a library, it is faced with conceptual difficulties endangering the model semantic, which are typically avoided with dedicated ecosystems, as does for example Erlang and its virtual machine called BEAM. Chapter [#ch-actor-impl] will be regarding Akka in more detail. 

*Orleans* [@Ber14] is a recent variant of an object-oriented interpretation of Actors called *Active Objects*. It has been constructed to meet the requirements of highly distributed deployment setups, currently referred to as *cloud computing*. A rather unique approach compared to Erlang, Akka and most other systems is the *virtuality* of its Actors, i.e.\ they are merely instantiated when addressed and thus required.


## Active Objects {#sec-active-objects}


As was pointed out, Actor systems aim to provide a more high-level interface than the basic primitives to express concurrency. One specific way to realize this is through the concept of *objects* as were introduced in the *Object-oriented Programming* (OOP) paradigm. These objects encapsulate state and offer operations on this data [@Agh90; @Weg90]. In the terminology of the Smalltalk programming language, these operations are invoked by sending a so-called *message* to an object, bearing resemblance to the Actor concepts and terminology [@Sco06].

Yonezawa *et al.* [@Yon86] were the first to introduce classic "passive" objects extended by their own *thread of control* in a programming language called ABCL/1[^fn-abcl1]. These object's state is only accessible from within themselves. Access or modification to any state is achieved by invoking their public interface methods. Such objects are not idle by default and only perform operations when called upon, but may be *active* on their own since they live in their own thread. Thus comes their name: *Active Objects* (AO). When such an Active Object's method is invoked, the actual method execution is decoupled and performed concurrently. This is usually realized through a *proxy object* on the client side (invoker), which merely mirrors the AO's public interface and handles the message dispatch, while the actual computation is done on a server object (the invoked Active Object) running on a separate thread in general [@Lav95]. Meyer [@Mey97] points out one general notion of Active Objects emphasizing a viewpoint with a focus on conceptualities that will merit special attention in due course:

> "Each object is a single, identifiable process-like entity (not unlike a Unix process) with state and behavior."

[^fn-abcl1]: __A__ctor__B__ased __C__oncurrent __L__anguage. The */1* indicates that it is merely the first of a whole family of languages. Thus, it's often omitted in the literature. Consecutive versions do not follow a sequential numbering though, e.g.\ *ABCL/R*, *ABCL/f* or *ABCL/c+*.

Though AOs aim to provide a purely object-oriented abstraction of Actors, it has been argued that Actors themselves already represent the very essence of object-orientation [@Agh90]. Scholars have long debated the fundamental concepts of object-orientation. The only truly undebated characteristic seems to be encapsulation of state [@Kni96] coupled to a set of operations sharing this data [@Weg90]. Additionally, Actors share object concepts like their ability to be created, having a unique identity (address), a public interface [@Sny93]. Thus, it has often been argued that either Actors are convenient for the foundation of Active Objects, or that AO's are suited to be used to implement Actors [@Lav95].

Its worth pointing out that due to this conformity of the Actor construct with the object essence, scholars do not use the terminologies consistently. In this thesis, we use *Actors* to refer to the concept formulated by Hewitt and refined by Agha, and *Active Objects* for the pattern introduced by Yonezawa to abstract the Actor semantic into a classic object API. However, in the literature, "Active Object" can also be found to be used interchangeably with the term "Actor".

The following example illustrates the subtle difference in the behavior of classic versus active objects:

``` {language:java}
class Fnord {
    private int a = 1;
    void add(int b) {
        a += b;
    }
    int get() {
        return a;
    }
}
```

Using the above class `Fnord`{language:java}, the following simple procedure is created:

``` {language:java}
1   final Fnord f = ...; // obtain reference to an instance
2   f.add(1);
3 
4   print(f.get()); 
```

In a single threaded program, once line 4 is reached, it is safe to assume that the addition has been executed and the internal field `a` was altered. The returned value by the `get()` call in line 4 will result in `2`. 

Altering the definition to `class Fnord extends ActiveObject`{language:java}, with some arbitrary base class `ActiveObject`{language:java} that will turn `Fnord`{language:java} into an Active Object implementation, this observation does not hold any more. When reaching line 3, there is no guarantee that the addition has actually been executed. Line 2 only dispatched the message and returned to leave the activity to its own flow of execution. Line 4 will block (because `get` has a return value) and wait until the message has been dispatched and an answer arrived. But we cannot assume that we will receive the value `2`, because other messages can be received and therefore processed before the underlying Actor of `f`. 

The major benefit of the Active Object abstraction compared to classic Actors *type safety* regarding the strong typization of messages [@Lav95]. An Actor in general can receive any type of message. Only when the message was received and is about to be processed, the Actor can decide whether it is actually able to understand the message's type. This is a form of *dynamic type checking* at runtime -- even in statically typed programming languages.

Active Objects on the other hand provide ordinary object-like interfaces. Sending a message to an AO means calling a method with a fixed signature of the object (the proxy respectively). Thus, only the methods available in the objects public interface are valid to be called, and a compiler is able to statically ensure this during compile time. This is true for the messages dispatched, as well as for state passed by a messages via any method arguments. On the other hand, due to the nature of AO interfaces, they only provide message passing in a point-to-point communication style. Broadcasting messages would require one method call to address multiple objects, which isn't intended by the object abstraction [@Yon86].

The Active Objects method signatures do not only define communication with a certain degree of static type safety, but also influence the behavior of the object's thread of control, that is they constrain synchronization [@Lav95]. In the original work of Yonezawa *et al.* they introduce multiple types of message passing for method invocation [@Yon86; @Kos16]:

* Past Type
  : The message is dispatched and the sending object's thread of control immediately continues. It does not wait until the message has been processed by the receiver. This is equal to message passing in the Actor model.

* Now Type
  : The message is dispatched and the sender waits for a result. Its thread of control blocks until the receiver processed the message and replied the result. This is equal to a procedure call with a return value.

* Future Type
  : The senders thread of control immediately returns, but receives a reference to the result that will be available at some point in the future, once the receiving object has processed the message and replied.

The example above illustrates two of these behaviors of method invocation of Active Objects. While `void add(int)`{language:java} only dispatches a message and immediately returns (past type), `int get()`{language:java} actually waits for a result (now type). Using the future type requires to include an additional abstraction of concurrency, the *Future*. 


## Integration of other Concurrency Abstractions {#sec-actor-concurrency-combination}


The Actor model is a mature, general purpose model for expressing concurrent computation. It has some clear principles which must be upheld in order to ensure the intended semantic. Besides these, the model does not make additional assumptions and restrictions. This makes Actors flexible and applicable for general purpose computation. Concurrency, or the suitability for it, is basically merely an inherited side-effect. As a result, it allows the model to be combined with additional arbitrary approaches to express computation (even concurrent ones), as long as such do not jeopardize the Actor semantic.

As such, mixing Actors with other concurrency models has been common. The reasons for introducing additional abstractions are manifold. Tasharofi *et al.* empirically found that the major inadequacies of Actor systems are thought by programmers to be in their lack of efficiently supporting blocking operations (especially IO) and that many communication protocols are hard to express in an asynchronous messaging style [@Tas13].  

Therefore, in order to overcome these shortcomings, additional concurrency models are interweaved. This raises the issue of the requirements for any two concurrency models being *composable* without any inconsistencies. Swalens *et al.* regard two concurrency models as composable if their integration does not result in any new effects regarding *safety* and *liveness* that have not been there before [@Swa14]. The Isolated Turn Principle of the Actor model already gives a strong boundary to ensure these properties [@Kos16]. Added concurrency concepts therefore must not weaken these. Especially, the introduction of low-level data races is very easy by new abstractions, and must be carefully avoided [@Tas13]


### Futures


The traditional notion of a procedure call is that the execution flow only continues once the computation performed by the called procedure has finished. Of course, given procedure could dispatch a concurrent execution and return without a result, thus the flow of execution may actually resume before said computation is finished in general. However, if given procedure provides a return value, the control flow is expected to *block* until respective value has been calculated [@Tan07].

In many cases the respective result is not required immediately by the subsequent computation. The control flow may continue without accessing given value for some time. Thus, it is possible to resume the caller's activity, while the called procedure is executed concurrently in a separate thread of control. The procedure initially simply returns a placeholder that will contain the actual result value at some point in the future [@Wel05; @Fla99]. Such values are therefore used in a *semi-synchronous* fashion. Their calculation is performed *asynchronously* in general. The calling and the called thread are again *synchronized* once the placeholder is issued for the actual result. This is sometimes dubbed to *touch* or *claim* the value, and may expand to blocking the current control flow if the result is not yet available [@Wel05; @Tas13]. 

The concept of such eventually retrievable values is not uniformly named in the literature. Baker & Hewitt [@Bak77] describe the concept of a *Future* which deliver the result of an expression eventually. Liskov & Shrira [@Lis88] extended this idea by introducing a data type called *Promise* for result values that may be single-assigned at some point in the future. More seldomly used terms are *Eventual*, *Delay* or *Deferred* [@Pra18]. The kind of evaluation order expressed by these concepts is sometimes referred to as *call-by-future* [@Bak77] or *call-by-need* [@Agh85a].

Some programing languages, among them Java and Scala, have a special view on such eventual values, for they support both `Future`{language:java}s as well as `Promise`{language:java}s. There, a `Future`{language:java} represents a read-only container used as the placeholder for an eventually computed value, while a `Promise`{language:java} is a single-assignment variable used explicitly to set a value at *some* point in time, i.e.\ to complete a `Future`{language:java}[^fn-java-promise]. In other words, a `Future`{language:java} refers to a `Promise`{language:java} that will be kept eventually [@Hal18; @Pra18].

[^fn-java-promise]: Therefore it is called `CompletableFuture`{language:java} in Java, instead of `Promise`{language:java} as it is in Scala.

Though today all designations tend to be used interchangeably, and refer to roughly the same idea [@Swa14], we will confine to the term "Future" as it is used in Java and Scala, and to the semantic as is provided by these languages.

There has been a long tradition of combining Actors with Futures. Agha describes that Actors are often used to model call-by-need computation [@Agh85a], which is essentially a Future. It can also be traced back to ABCL/1 and its Active Object notion [@Yon86]. Three kinds of message passing for AOs have already been discussed. The example then merely demonstrated two (past type and now type). The third, coincidentally called *future type*, is actually the result of combining Actor concurrency semantic with the Future concurrency abstraction [@Tas13]. Orleans uses Promise/Futures as the only form of method call for all Active Objects [@Ber14].  

For a complete formal definition of Future semantics we refer the interested reader to Flanagan & Felleisen [@Fla99].


### Software Transactional Memory


The asynchronous messaging style of Actors tends to become a burden when it is required to have some sort of consensus between several Actors. The model does not provide an adequate mechanism to abstract operations involving multiple messages [@Sub11]. Such is expected to be taken care of by the programmer.

The *Transaction* is a well-known concept to provide a single-threaded appearance to the access of state or memory that is generally accesses concurrently. A transaction encapsulates a computation that does not have to be atomic by itself (e.g.\ code block), but still logically appears to happen within a single instant in time [@Les09]. Therefore, all memory modifications done inside the transaction become atomic from the outside perspective. If a transaction becomes invalid, all state modifications are rolled back across the entire code segments involved in the transaction. Write collisions are one reason for transactions to become invalid. Upon a collision, the isolation of the transaction cannot be guaranteed anymore [@Sub11]. *Software Transactional Memory* (STM) refers to transactional semantics realized in software[^fn-hardware-transaction]. In the scope of this thesis, STM is the only considered transaction mechanism.

[^fn-hardware-transaction]: Originally, the concept was proposed for supporting transactions in functional languages, but in hardware. Hence the distinction.

Combining transactions with actors can have a huge impact on performance. Especially write collisions raise the amount of coordination required. Though this can be done transparently by abstractions provided by an actor system, it always means additional message processing of the actors involved, potentially turning into a bottleneck [@Sub11].
