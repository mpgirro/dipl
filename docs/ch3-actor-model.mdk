The Actor Model {#ch-actor-model}
===============



~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~

~LitNote
* [@Agh85a] "ACTORS: A Model of Concurrent Computation in Distributed Systems"
* [@Agh85b] "Concurrent Programming Using Actors: Exploiting Large-Scale Parallelism"
~

In this thesis, we will focus on one particular abtraction for modelling concurrent computation. It is based on a formalism Hewitt [original referenced needed]{.mind} introduced in the 1970s. As the models name suggests, at its foundation it build upon the abstraction of *Actors*. Agha describes them a self-contained, interactive and independent components that are communication via asynchronous message passing [@Agh90]. Therefore it performes actions in response to received messages.

Upon receiving a message, an Actor can react in with three basic primitives:

1. Sending a finite number of messages to itself or other known actors.
2. Creating a finite number of new actors.
3. Changing its internal behaviour for the next message that it receives with the so-called *replacement behaviour*.
 
In order to send a message, the unique *address* of an Actor must be known. The unterlying system delivers the message. In general, the order of delivery is non-deterministic. Actor addresses can be announced to other Actors by sending the address as a message. This allows for *dynamic reconfiguration* [@Agh90].

Messages are processed one at a time. Therefore, they have to be buffered in the so-called *mailbox* if an Actor is not able to process an incomming message immediately, because it is already engaged in a message handling operation [citation needed]{.mind}

## Message Passing and Isolation 

~LitNote
* every Actor owns its state exclusively (should also have unique DB -> bad performance, discuss in Actor-Impl chapter) --> das DB thema sollte ich lieber im praktischen solution teil bei "persistence" beschreiben
* It should be hard to create an actor directly, better reference it via an actor ref. [@Sub11] gives nice JAva code with factor method
* messages need to be immutable
~

The Actor abstraction defines that the only possible form of communication between Actors is by exchanging messages. This has the semantical implication that there is not directly shared state between them [citation needed]{.mind}. Actor semantic means state is *encapsulated* within an Actor exclusively. To access the state, it must be requested by sending an appropriate message. 

It is important to realize that requested state informations are always mere snapshots of any Actors state at a specific point in time (the ppint where this Actor processes the requesting message), and the information might therefore be already outdated once the requestor receives the snapshot answer [citation needed]{.mind}. This is the semantic of any form of asynchronous communication [citation needed]{.mind}. On the other hand, it frees Actors from the implications any form of shared state or resource handling, like the bottle-necks introduces by sequential locking, brings with it [@Agh90].  

To ensure snapshots do not violate encapsulation semantic and prevent accidentally exposing direct access to any internal state or resource, passed messages must be guaranteed to be *immutable* [citation needed?]{.mind}. This allows save coordination at a distance [@Hel15]. 

Changing internal state within an Actor is modeled with the third of the basic primitives: behaviour replacement. It is important that this action though does not break the *referential transparency* of the Actors intentifiers used to send messages to it [@Agh90]. Therefore, changing Actor internals has not effect on its reachability for other Actors. 

This strict encapsulation of state and decoupling via immutable, asynchronous message passing leads to a strong form of *isolation* between Actors [citation needed]{.mind}. State within an Actor is mutable, but isolated from the outside and only available through immutable snapshots.

Preserving Actor semantics can be a challenge when used with programming languages focusing on different concepts and values. In *Object Oriented Programming* (OOP), encapsulation is the principle that the internal object state is only available within the object. Therefore, only an objects instance methods are allowed to access the instances state [@Mey97]. Object methods provide well-defined interfaces realizing access control, and are used to issue requests to modify or read state variables [@Sny93]. 

Object-oriented Actor implementations might be facing challenges here however. The concept of *visibility* often found in OOP might break loosen up the consistency of encapsulation [citation needed]{.mind}. The *Java* programming languages for example offers multiple granularities for the visibility of class fields. A `public`{language:java} field can be accessed without using a method interface and - given it is not declared `final`{language:java} - may also be modified the same way. The following code snippet illustrates the problem in Java using Akka (which will be discussed in more detail in chapter [#ch-Actor-solution])):

``` {language:java}
public class Foo extends UntypedActor { 

    public String bar;

    public void onReceive(final Object msg) {  
        // handle msg
    } 
}
```

Any Java-based Actor implementation faces the potential problem that custom written Actor classes might easily break the required Actor semantic. Object-oriented Actor implementations therefore often offer APIs where interaction with an Actor instance is not issued directly through the object instances method interfaces:

``` {language:java}
final ActorRef foo = Actors.actorOf(Foo.class).start();
```

An instance of `Foo`{language:java} is not created using the `new`{language:java} as is custom in Java, but hidden inside a factory method. Only a proxy object of type `ActorRef`{language:java} is exposed to the user. `ActorRef` instances do not have the public interface of the Actor class they represent, but ...

Messages to the Actor `foo` are sent..





* The communication with an Actor through a `ActorRef` proxy also has the benefit of loosening the referential transparency up to a *location transparent* [hier lehne ich mich weit aus dem fenster - vll ref. transparency komplett raus lassen?]{.mind} ; ... also opens up to possibility of *location transparency*, a form of decoupling where 



* ensure state is not exposed, example java factor, visibility of fields/methods may break actor semantics
* hier irgendwo [@Sub11] zitieren!

## Active Objects {#sec-active-objects}

~LitNote
* [@Lav95] "Active Object -- An Object Behavioral Pattern for Concurrent Programming"
* active objects are basically Actors with a different API
    * realized with a proxy object
* vorteil: typsicherheit zur compile time, dass nachrichten an das object (den dahinterliegenden generierten Actor) auch wirklich verarbeitet werden k√∂nnen
~

``` {language:java}
class Fnord {
    private int a = 1;
    void add(int b) {
        a += b;
    }
    int get() {
        return a;
    }
}
```

Using the above class `Fnord`{language:java}, we can create the following simple program:

``` {language:java}
1  void doSomething() {
2    Fnord f = ...; // get reference to a Fnord instance
3    f.add(1);
4 
5    print(f.get()); 
6  }
```

In a single threaded program, once line 4 is reached, it is save to assume that the the addition has been executed and the internal field `a` was altered. The returned value by the `get()` call in line 5 will result in `2`. 

Altering the definition to `class Fnord extends ActiveObject {...}`{language:java}, with some arbitrary base class `ActiveObject`{language:java} that will turn `Fnord`{language:java} into an Active Object implementation, this observation does not hold any more. When reaching line 4, there is no guarantee that the addition has actually been executed. Line 3 only dispatched the message, and returned to leave `doSomething` to its own flow of controll. Line 5 will block (because `get` has a return value) and therefore wait until the message has been dispatched and an answer arrived. But we cannot assume that we will receive the value `2`, because other messages could have by received by and therefore processes before the unterlying Actor of `f`. 


## Combination with other Concurrency Abstractions

### Futures

### Software Transactional Memory (STM)

~LitNote
* [@Sub11] demonstrates how Akka support STM together with Actors
~

## Object-Oriented Perspective

### Data Abstractions

Encapsulation and Information Hiding

### SOLID design principles

### Design by Contract

### Substitution and Behaviour