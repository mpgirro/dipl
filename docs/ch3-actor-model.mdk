
The Actor Model {#ch-actor-model}
===============



~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~

## A Model of Computation {#sec-actor-primitives}

~LitNote
* [@Agh85a] "ACTORS: A Model of Concurrent Computation in Distributed Systems"
* [@Agh85b] "Concurrent Programming Using Actors: Exploiting Large-Scale Parallelism"
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
    * 1973 mathematical model
    * Bill Kornfeld and Carl Hewitt [1981] showed that the Actor model could encompass large-scale concurrency.
    * Agha developed Actors as a fundamental model for concurrent computation
~

In this thesis, we will focus on one particular abtraction for modelling concurrent computation. It is based on a formalism Hewitt, Bishop and Steiger [original referenced needed]{.mind} introduced in the 1970s. As the models name suggests, at its foundation it builds upon the abstraction of *Actors* as basic building blocks. Agha describes them a self-contained, interactive and independent components that are communication via asynchronous message passing [@Agh90]. 


Agha reformulated the Actor model into three basic primitives and Actor can perform upon receiving a message [@Agh85a]:

1. Sending a finite number of messages to itself or other known actors.
2. Creating a finite number of new actors.
3. Changing its internal behaviour for the next message that it receives with the so-called *replacement behaviour*.

In order to send a message, the unique *address* of an Actor must be known. The unterlying system delivers the message. In general, the order of delivery is non-deterministic. Actor addresses can be announced to other Actors by sending the address as a message. This allows for *dynamic reconfiguration* [@Agh90].

Messages are processed one at a time. Therefore, they have to be buffered in the so-called *mailbox* if an Actor is not able to process an incomming message immediately, because it is already engaged in a message handling operation [citation needed]{.mind}


## Message Passing and Encapsulation {#sec-actor-messaging-encapsulation}


The Actor abstraction defines that the only possible form of communication between Actors is by exchanging messages. This implies that there is no directly shared state between them [citation needed]{.mind}. Actor semantic means state is *encapsulated* within an Actor exclusively. To access the state, it must be requested by sending an appropriate message. 

Processing a message is *atomic*, i.e. it is not interrupted by other messages to the Actor [@Agh99], for they get buffered inside the mailbox.

It is important to realize that requested state informations are always mere snapshots of any Actors state at a specific point in time (the point where this Actor processes the requesting message), and the information might therefore be already outdated once the requestor receives the snapshot answer [citation needed]{.mind}. This is the semantic of any form of asynchronous communication [citation needed]{.mind}. On the other hand, it frees Actors from the implications any form of shared state or resource handling, like the bottle-necks introduces by sequential locking, brings with it [@Agh90].  

To ensure snapshots do not violate encapsulation semantic and prevent accidentally exposing direct access to any internal state or resource, passed messages must be guaranteed to be immutable, copied or proxied [@Kos16]. This allows save coordination at a distance [@Hel15]. 

Changing internal state within an Actor is realized through the third of the basic primitives: behaviour replacement. In general, this primitive can be used to change the behaviour of the Actor entirely - in the Actor taxonomy also called to *become* different operations for all following messages. However, it can also become the same operations, but for a different state [@Weg90]. It is important that this action though does not break the *referential transparency* of the Actors intentifiers used to send messages to it [@Agh90]. Therefore, changing Actor internals has not effect on its reachability for other Actors. The Actor logically stays the same, but will behave differently when processing the next message.

This strict encapsulation of state and decoupling via immutable, asynchronous message passing leads to a strong form of *isolation* between Actors [@Agh14]. State within an Actor is mutable, but isolated from the outside and only available through immutable snapshots.

Additionally, state can only be changed while processing a message. Therefore, as De Koster et al. illustrate in detail, the processing of a single message can be viewed as an isolated operation. This is important when reasoning about Actors, because "the granularity of reasoning is at the level of a turn[^fn-isolated-turn-principle]" [@Kos16]. They call this *Isolated Turn Principle*. It guarantees that Actors are free of low-level data races (for only one message is processed at a time, and each message belongs to a single Actor), but high-level races (depending on the interleaving of messages within the mailbox) can still occure. 

[^fn-isolated-turn-principle]: In this context, *turn* is used to refere to the processing of a single message. Various terminilogies have been used for this over the decades. [@Kos16] gives a good overview of Actor model taxonomy and the equivalence of various terms.

## Unifying Concurrent, Parallel and Distributed Computation

~LitNote
* Hier beschreiben dass die Actor semantic eine nebenläufige und sogar verteilte ausführung erlaubt
* [@Agh99] "Actors: A unifying model for parallel and distributed computing"
* [@Agh91] "Distributed Execution of Actor Programs"
* [@Cha13] "Native actors- a scalable software platform for distributed, heterogeneous environments"
* [@Kar09] "Actor frameworks for the JVM platform: A Comparative Analysis"
* [@Reh13] "An Actor-based Distribution Model for Realtime Interactive Systems"
~

Up until now, the Actor model was described as a general model of computation. It was initially conceived as such by Hewitt [citation needed?!]{.mind}. However, the abstraction of Actors presented so far provides a strict separation of components state, as well as a loose coupling via asynchronous message passing. As such, Actors encapsulate not only data and functionality, but also their own *thread of control*, making Actors autonomous [@Agh99]. Hewit and [??]{.mind} later showed that this allows for a concurrent execution of such components [citation? war das wirklich erst später?]{.mind}, effectivly making the Actor abstraction into a model of *inherent concurrent computation* [@Agh91]. 

There are numerous models that are able to provide inherent concurrency, such as logic programming or  functional programming. The benefit of the Actor abstraction however is, that it allows for a direct expression of state [@Agh91], as such can only be manipulation within an Actor and while its processing a message - an operation that is, as was pointed out, guaranteed to be atomic. For state is never shared, but only communicated via asynchronous message passing, this eliminates a whole class of errors, the *race conditions* [@Cha13]. The dynamic data flow of messages is the primary source of nondeterminism, for the order of processing the messages affects the behaviour, but therefore eliminates unnecessary synchronization overhead [@Kar09; @Agh99].

On a programming language level, referencing components is usually subject to physical limitations regarding the programs memory, i.e. objects can only reference objects inside the same programs memory space [citation needed]{.mind}. Though this does not affect providing decent approaches for writing concurrent code in general, it certainly hinders providing decent constructs for writing parallel code. Parallel execution requires code execution on different CPU cores *at the same time*, which usually means distinct process memory boundries. Inter-component communication has to happen across these boundries. It can be charged to the virtual machine used for executing the code if such is part of the language concept, as is done in Java where the JVM maps threads to system proccesses for parallelization [@Hal09]. But writing explicit parallel code, e.g. with a *Fork/Join Framework*, can be painful and requires to explicitly prepare code segments that are ment to and data that can be proccessed in parallel [@Lea00].

The Actor model on the other hand provides a strict concept of isolated and decoupled components. The only link between Actors is the delivery of messages, based on their address. These addresses are virtual by not exposing any physical location information [@Ber14; @Tas13], and are thus not restricting the Actors to the limitations of such. Concurrently executed components are not required to be inside the same process boundry, because their addresses can abstract the gape in physical distance between them. This concept is generally refered to as *location transparency* [@Kar09]. Thus, the abstraction of concurrent components of the Actor model inherently also supports parallel execution of such.

Traditionally, distributed computation is regarded its own research discipline separate from parallel computation. However, both concepts are based on the same fundamental idea: Truely concurrent execution (as in *at the same time*) of physically distributed processes [@Agh99]. Agha, Frølund and Kim formulated a simple and sound argumentation [@Agh93]:

> "In a parallel computation some actions overlap in time; by implication these events must be distributed in space."

Again, location transparent addresses allow for referencing Actors even outside the scope of a CPU, providing the foundation for distributed execution on different nodes [@Kar09]. Execution on the same CPU is therefore often refered to as *intra-node*, while distribution execution as *inter-node* parallelism [@Reh13]. Inter-node components are still physically close, and may assume that their communication channel is reliable. Inter-node components can make no safe assumption on the safety and reliability of their communication channel, except it to being more costly and volatile in any case [@Agh99].


[...]{.mind} Boner describes *decoupling in time* as the prerequisite for concurrency, and *isolation in space* as the prerequisite to distribution and mobility [citation needed]{.mind}


## Variations in Actor Systems {#sec-actor-systems}

~Todo
Hier kann ich ein paar Systeme anteasern. zB die Erlang, die alten Scala Actors, (kurz Akka?), und Kilim
~

~LitNote
* [@Kar09] "Actor frameworks for the JVM platform: A Comparative Analysis"
* [@Che17] "Evaluating Scalable Distributed Erlang for Scalability and Reliability"
* [@Hal09] "Scala Actors : Unifying thread-based and event-based programming"
* [@Hal12] "On the integration of the actor model in mainstream technologies"
* [@Ber14] "Orleans: Distributed Virtual Actors for Programmability and Scalability"
* [@Kar09] "Actor frameworks for the JVM platform: A Comparative Analysis"
* [@Cha13] "Native actors- a scalable software platform for distributed, heterogeneous environments"
~

~Todo
Hier sollte ich erklären das die Actors keinen ganzen Thread benötigen, stattdessen viel leichtgewichtiger (und daher billiger sind - im betrieb und da ein thread von der JVM auf einen OS process gemapped werden würde). besonders in Erlang sind sie "lightweight process". In Scala sind sie entweder mit einem Thread Pool umgesetzt (siehe Paper "Unifying thread-based and event-based concurrency"), oder event-based (also kein thread, sondern callbacks?)
~

~LitNote
* [@Hal09] "Scala Actors : Unifying thread-based and event-based programming"
~

The Actor model provides a good, easy to understand abstraction. However, though it is theoretically quite easy to understand, the abstraction can pose as a challenge to be used by programmers, depending on the underlying programming model. Programming languages or libraries providing Actor-based concurrency usually aim towards providing more high-level primitives [@Agh90; @Weg90]. Such can be different kinds of message sending, or in terms of expressing behaviour replacement operations. In functional programming, replacement behaviour is usually expressed by a different function that handles the message processing [irgendwo hab ich sowas mal gelesen. war das das noch mal?!]{.mind}. The imperative paradigm realizes this through all flavours of assignment variants [will ich das so sagen??]{.mind}.





[will ich diese bezeichnung hier verwenden?]{.mind}. The idioms provided must be used to map concurrency to the Actor abstraction. In thread-based environments like the *Java Virtial Machine* (JVM), the relatively heavy JVM threads must be used to implement relatively light-weighted Actor abstration. The JVM maps its threads to OS processes, which leads to...



 a This is to a certain degree contrary. Haller & Odersky [@Hal09] call this an "impedance mismatch" between message passing (event-based) and thread-based programming.  

Additionally, the basic Actor primitives introduced in section [#sec-actor-primitives] provide a very low-level abstraction to model computation via an (almost) pure communication paradigm [@Weg90]. Thus they are not too programmer friendly and [es braucht höhere abstraktionen? hab ich da eine quelle?]{.mind} 

---

~Todo
Das ganze Blabla hier hab ich mir mal so aus der Nase gezogen. Gefällt mir noch gar nicht.
~

On the other hand, if the message passing style is incorporated into the underlying fabric[^fn-computing-fabric], then it can be implemented in an even more efficient way. Erlang is a most famous representative of programming languages representing the Actor model [citation needed]{.mind}. It was initially developed to use for phone stuff in the ??? years, a domain where high concurrency was of the essence [blabla zitieren und so]{.mind}...

Erlang is backed by the Actor model by design. While Scala also was conceived with Actor-based concurrency in mind (though other concurrency form - like thread may be easily used), it depends on JVM threads for under the hood execution [ACHTUNG, wie Hal09 beschreibt gab es bei den alten Scala actors ja auch rein event-based actors]{.mind}. Erlang is also a language design for a virtual machine, the BEAM. However, this VM has been desigend to leverage message-passing communication style. Therefore, the Erlang Actors - called processes -  do not 

[^fn-computing-fabric]: In case of directly to machine code compiled languages, the *fabric*  

## Active Objects {#sec-active-objects}

~LitNote
* [@Lav95] "Active Object -- An Object Behavioral Pattern for Concurrent Programming"
* active objects are basically Actors with a different API
    * realized with a proxy object
* vorteil: typsicherheit zur compile time, dass nachrichten an das object (den dahinterliegenden generierten Actor) auch wirklich verarbeitet werden können
* Act.Obj sind sowohl ein Pattern, als auch prinzipiell eine object-orientierte Abstraction des Actor Models (bzw der Actor Semantic?). Actors können Prinzipiell in welchem Paradigma auch immer umgesetzt sein. Entsprechend sind Act.Obj die "besonders object-orientierten Actors"
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * -> Gleiche Zeit wie Agha das Actor model neu formuliert hat, hat Yonezawa (in [@Yon86]) prinzipiell die Active Objects eingeführt
    * AO "support fixed actor interfaces"
* [@Yon86] "Object-oriented concurrent programming ABCL/1"
    * originale Quelle für das Prinzip von AO?
    * "Thus message passing takes place in a point-to-point (object-to-object) fashion. No message can be broadcast."
* [@Agh90] "Concurrent Object-Oriented Programming"
    * "Actor primitives provide a very low-level description of concurrent systems - much like an assembly language"
    * "High language constructs are necessary both for raising the granularity of description and for encpasulating faults"
* Wenn alle AO ihren eigenen Thread haben, sind sie ja viel heavy-weight als Actors (eher vergleichbar mit Microservices?) --> soll ich das hier andeuten oder eher weiter unten, zB bei den Distr. Obj.?
~

As was pointed out, Actor systems try to provide a more high-level interface than the basic primitives to express concurrency. One specific way to realize this is through the concept of *Objects* introduces in the *Object-oriented Programming* (OOP) paradigm. In OOP, ....

Objects encapsulate state and offer operations on this data [@Agh90; @Weg90]. In the terminology of the Smalltalk programming language, these operations are invoked by sending a so-called message to an object [@Bla13]. This already bears resemblence to the Actor concepts and terminology.

Yonezawa et al. was the first introduced a programming language called ABCL/1[^fn-abcl1] [@Yon86] where classic "passiv" objects are extended by their own *thread of control*. Their state is only accessible from within the objects themselves. Access or modification to any state is achieved by invoking the objects public interface methods. Such objects are not idle by default and only perform operations when called upon, but may be *active* on their own, for they live in their own thread [citation?]{.mind}. Thus comes their name: *Active Objects*. 

[^fn-abcl1]: *ABCL* stands for **A**ctor-**B**ased **C**oncurrent **L**anguage. The */1* indicates that it is merely the first of a whole family of languages. Thus it's often omitted in the literature. Consecutive versions do not follow a sequential numbering though, e.g. *ABCL/R*, *ABCL/f* or *ABCL/c+*.

introduced a notion of classic objects extended by concurrent

~Todo
Erklären wieso Active Objekte was mit Actors zu tun haben. Im prinzip sind sie nur eine OO abstraktion er actor semantik
~

~Todo
Hinweis zur Verwending von Namen "Actor" und "Active Objects". Manchmal werden die Namen synonym verwendet, und für das Act.Obj. Prinzip dann "Agents" ?
~

---

``` {language:java}
class Fnord {
    private int a = 1;
    void add(int b) {
        a += b;
    }
    int get() {
        return a;
    }
}
```

Using the above class `Fnord`{language:java}, we can create the following simple program:

``` {language:java}
1  void doSomething() {
2    final Fnord f = ...; // obtain reference to an instance
3    f.add(1);
4 
5    print(f.get()); 
6  }
```

In a single threaded program, once line 4 is reached, it is save to assume that the the addition has been executed and the internal field `a` was altered. The returned value by the `get()` call in line 5 will result in `2`. 

Altering the definition to `class Fnord extends ActiveObject`{language:java}, with some arbitrary base class `ActiveObject`{language:java} that will turn `Fnord`{language:java} into an Active Object implementation, this observation does not hold any more. When reaching line 4, there is no guarantee that the addition has actually been executed. Line 3 only dispatched the message, and returned to leave `doSomething` to its own flow of controll. Line 5 will block (because `get` has a return value) and therefore wait until the message has been dispatched and an answer arrived. But we cannot assume that we will receive the value `2`, because other messages could have been received by and therefore processes before the unterlying Actor of `f`. 

The major benefit of the Active Object abstraction compared to classic Actors is *type safety*. An Actor in general can receive any type of message. Only when the message was received and is about to be processed, the Actor can decide weither it is actually able to understand the message's type. This is a form of *dynamic type checking* at runtime [citation needed - für den ganzen Absatz]{.mind} - even in statically typed programming languages.

Active Objects on the other hand provide ordinary object-like interfaces. Sending a message to an AO means calling a method with a fixed signature of the object (the proxy respectivly). Thus, only the methods available in the objects *public interface* are even valid to be called, and a compiler is able to statically ensure this during compile time [citation?]{.mind}. This is true for the messages dispatched, as well as for state passed by a messages via any method arguments.

The Active Objects method signatures do not only provide a certain degree of static type safety, but also influence the behaviour of the objects thread of control. In the original work of Yonezawa et al. they introduce multiple types of message passing for method invocation [@Yon86; @Kos16]:

* Past Type ("send and no wait")
  : The message is dispatched and the sending objects thread of control immediatelly continues. It does not wait until the message has been processed by the receiver. This is equal to message passing in the Actor model.

* Now Type ("send and wait")
  : The message is dispatched and the sender waits for a result. Its thread of control blocks until the receiver processed the message and replied the result. This is equal to a procedure call with a return value.

* Future Type ("reply to me later")
  : The senders thread of control immediatelly returns, but receives a reference to the result that will be available at some point in the future, once the receiving object has processed the message and replied.

The example above illustrates two of these behaviours of method invocation of Active Objects. While `void add(int)`{language:java} only dispatches a message and immediately returns (past type), `int get()`{language:java} actually waits for a result (now type). Using the future type requires to include an additional abstraction of concurrency, the *Future*. 

## Combination with other Concurrency Abstractions {#sec-actor-concurrency-combination}

~LitNote
* [@Tas13] "Why Do Scala Developers Mix the Actor Model with other Concurrency Models?"
    * "that many of the programs mix actors with other kinds of concurrent entities such as Java threads."
* [@Les09] "Concurrent Programming Paradigms, A Comparison in Scala"
* [@Swa14] "Towards Composable Concurrency Abstractions"
~

The actor model is a mature, general purpose model for expressing concurrent computation. However, it does not facilitate some requirements as well as other better than others. An easy example is synchronous communication, which is not intended by the model. As such, developers ...

~LitNote
* Drawbacks of breaking the Actor semantic [@Tas13]:
    * potential of fine-grained (low level?) data races (also in [@Swa14], see "safety")
    * reduce readability, maintainability
* [@Swa14]: "We consider two models *composable* if combining them cannot produce new safety or liveness issues"
    * "Safety means that, given a correct input, a program will not produce an incorrect result"
        * "Race conditions are caused by an incorrect interleaving between two models.""
    * "Liveness guarantees a program will terminate if its input is correct"
        * Deadlocks, Livelocks
~

### Futures

~LitNote
* [@Lis88] "Promises: linguistic support for efficient asynchronous procedure calls in distributed systems"
* [@Boe07] "A Complete Guide to the Future"
* [@Fla99] "The semantics of future and an application"
    * wirkt eher unbrauchbar...
* [@Car04] "Asynchronous and Deterministic Objects"
* [@Swa14] "Towards composable concurrency abstractions"
    * Reading a Future value inside an Actor can cause a deadlock (potential block operation)
* [@Tas13] "Why DO scala developers mix the actor model with other concurrency models?"
    * "Futures are place-holders for asyn-chronously computed values; they block the current thread of execution when it tries to access a yet unresolved value. This way, futures provide a light form of synchronization between the producer and the consumer of the value. With their blocking result-resolution semantics, futures provide a natural way of adding par-tial synchrony to actor programs."
~

* Futures
* Promises?


The term *Future* is not consistently found in the literature. It is sometimes interchangably used and set equal to concepts like Promises and ???. Although all of these describe concepts where a placeholder 
is defined for a value that will be available at a later point in time [@Swa14],
they tend to vary slightly in their definitions [liskow citieren?]{.mind}. For the sake of an easier discussion in the later parts of this thesis, we will refere to the Future concept like it is found in Java and Scala. 


... 

There has been a long tradition of combining Actors with Futures. It can be traced back to ABCL/1 and its Active Object notion. Three kinds of message passing for AOs have already been discussed. The example back then only demonstrated two of them though (past type, now type). The third, coincidentially called *future type*, is actually the result of combining Actor concurrency semantic with the Future concurrency abstraction [@Tas13]. It will be demonstrated as part of another example later on.

### Software Transactional Memory (STM)

~LitNote
* [@Sub11] demonstrates how Akka support STM together with Actors
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * "...when an operation spans several messages the programmer must provide a custom synchronisation mechanism to pre- vent potential bad interleavings and ensure correct execu- tion"
~

Operations that span several messages