
The Actor Model {#ch-actor-model}
===============



~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~

## A Model of Computation {#sec-actor-primitives}

~LitNote
* [@Agh85a] "ACTORS: A Model of Concurrent Computation in Distributed Systems"
* [@Agh85b] "Concurrent Programming Using Actors: Exploiting Large-Scale Parallelism"
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
    * 1973 mathematical model
    * Bill Kornfeld and Carl Hewitt [1981] showed that the Actor model could encompass large-scale concurrency.
    * Agha developed Actors as a fundamental model for concurrent computation
~

In this thesis, we will focus on one particular abtraction for modelling concurrent computation. It is based on a formalism Hewitt, Bishop and Steiger [@Hew73] introduced in the 1970s. As the models name suggests, at its foundation it builds upon the abstraction of *Actors* as basic building blocks. Agha describes them a self-contained, interactive and independent components that are communication via asynchronous message passing [@Agh90]. 


Agha reformulated the Actor model into three basic primitives and Actor can perform upon receiving a message [@Agh85a]:

1. Sending a finite number of messages to itself or other known actors.
2. Creating a finite number of new actors.
3. Changing its internal behaviour for the next message that it receives with the so-called *replacement behaviour*.

In order to send a message, the unique *address* of an Actor must be known. The unterlying system delivers the message. In general, the order of delivery is nondeterministic. Actor addresses can be announced to other Actors by sending the address as a message. This allows for *dynamic reconfiguration* [@Agh90].

Messages are processed one at a time. Therefore, they have to be buffered in the so-called *mailbox* if an Actor is not able to process an incomming message immediately, because it is already engaged in a message handling operation [citation needed]{.mind}


## Message Passing and Encapsulation {#sec-actor-messaging-encapsulation}


The Actor abstraction defines that the only possible form of communication between Actors is by exchanging messages. This implies that there is no directly shared state between them [citation needed]{.mind}. Actor semantic means state is *encapsulated* within an Actor exclusively. To access the state, it must be requested by sending an appropriate message. 

Processing messages is done in a serialized fashion. This provides the basis for *isolation* [@Les09]. All state modifications done while processing a single message appears *atomic*, i.e. it is not interrupted by other messages to the Actor [@Agh99], for they get buffered inside the mailbox.

It is important to realize that requested state informations are always mere snapshots of any Actors state at a specific point in time (the point where this Actor processes the requesting message), and the information might therefore be already outdated once the requestor receives the snapshot answer [@And83]. On the other hand, it frees Actors from the implications any form of shared state or resource handling, like the bottle-necks introduces by sequential locking, brings with it [@Agh90].  

To ensure snapshots do not violate encapsulation semantic and prevent accidentally exposing direct access to any internal state or resource, passed messages must be guaranteed to be immutable, copied or proxied [@Kos16]. This allows save coordination at a distance [@Hel15]. 

Changing internal state within an Actor is realized through the third of the basic primitives: behaviour replacement. In general, this primitive can be used to change the behaviour of the Actor entirely - in the Actor taxonomy also called to *become* different operations for all following messages. However, it can also become the same operations, but for a different state [@Weg90]. It is important that this action though does not break the *referential transparency* of the Actors intentifiers used to send messages to it [@Agh90]. Therefore, changing Actor internals has not effect on its reachability for other Actors. The Actor logically stays the same, but will behave differently when processing the next message.

This strict encapsulation of state and decoupling via immutable, asynchronous message passing leads to a strong form of *isolation* between Actors [@Agh14]. State within an Actor is mutable, but isolated from the outside and only available through immutable snapshots.

Additionally, state can only be changed while processing a message. Therefore, as De Koster et al. illustrate in detail, the processing of a single message can be viewed as an isolated operation. This is important when reasoning about Actors, because "the granularity of reasoning is at the level of a turn[^fn-isolated-turn-principle]" [@Kos16]. They call this *Isolated Turn Principle*. It guarantees that Actors are free of low-level data races (for only one message is processed at a time, and each message belongs to a single Actor), but high-level races (depending on the interleaving of messages within the mailbox) can still occure. 

[^fn-isolated-turn-principle]: In this context, *turn* is used to refere to the processing of a single message. Various terminilogies have been used for this over the decades. [@Kos16] gives a good overview of Actor model taxonomy and the equivalence of various terms.

## Unifying Abstraction

<!--
## Unifying Concurrent, Parallel and Distributed Computation
-->

~LitNote
* Hier beschreiben dass die Actor semantic eine nebenläufige und sogar verteilte ausführung erlaubt
* [@Agh99] "Actors: A unifying model for parallel and distributed computing"
* [@Agh91] "Distributed Execution of Actor Programs"
* [@Cha13] "Native actors- a scalable software platform for distributed, heterogeneous environments"
* [@Kar09] "Actor frameworks for the JVM platform: A Comparative Analysis"
* [@Reh13] "An Actor-based Distribution Model for Realtime Interactive Systems"
~

Up until now, the Actor model was described as a general model of computation. The abstraction of Actors provides a strict separation of components state, as well as a loose coupling via asynchronous message passing. As such, Actors encapsulate not only data and functionality, but also their own *thread of control*, making Actors autonomous [@Agh99]. Hewit and [??]{.mind} later showed that this allows for a concurrent execution of such components [citation? war das wirklich erst später?]{.mind}, effectivly making the Actor abstraction into a model of *inherent concurrent computation* [@Agh91]. 

There are numerous models that are able to provide inherent concurrency, such as logic programming or  functional programming. The benefit of the Actor abstraction however is, that it allows for a direct expression of state [@Agh91], as such can only be manipulation within an Actor and while its processing a message - an operation that is, as was pointed out, guaranteed to be atomic. For state is never shared, but only communicated via asynchronous message passing, this eliminates a whole class of errors, the *race conditions* [@Cha13]. 

The dynamic data flow of messages is the primary source of nondeterminism, for no order of messages is guaranteed when multiple Actor sends messages to the same Actor. However, the actual order of processing the messages affects the behaviour, thus it is nondeterministic. On the other hand, this eliminates unnecessary synchronization overhead [@Kar09; @Agh90; @Agh99].

On a programming language level, referencing components is usually subject to physical limitations regarding the programs memory, i.e. objects can only reference objects inside the same programs memory space [citation needed]{.mind}. Though this does not affect providing decent approaches for writing concurrent code in general, it certainly hinders providing decent constructs for writing parallel code. Parallel execution requires code execution on different CPU cores *at the same time*, which usually means distinct process memory boundries. Inter-component communication has to happen across these boundries. It can be charged to the virtual machine used for executing the code if such is part of the language concept, as is done in Java where the JVM maps threads to system proccesses for parallelization [@Hal09]. But writing explicit parallel code, e.g. with a *Fork/Join Framework*, can be painful and requires to explicitly prepare code segments that are ment to and data that can be proccessed in parallel [@Lea00].

The Actor model on the other hand provides a strict concept of isolated and decoupled components. The only link between Actors is the delivery of messages, based on their address. These addresses are virtual by not exposing any physical location information [@Ber14; @Tas13], and are thus not restricting the Actors to the limitations of such. Concurrently executed components are not required to be inside the same process boundry, because their addresses can abstract the gape in physical distance between them. This concept is generally refered to as *location transparency* [@Kar09]. Thus, the abstraction of concurrent components of the Actor model inherently also supports parallel execution of such.

The location transparent addresses allow for referencing Actors even outside the scope of a CPU, providing the foundation for distributed execution on different nodes [@Kar09]. Execution on the same CPU is therefore often refered to as *intra-node*, while distribution execution as *inter-node* parallelism [@Reh13]. Inter-node components are still physically close, and may assume that their communication channel is reliable. Inter-node components can make no safe assumption on the safety and reliability of their communication channel, except it to being more costly and volatile in any case [@Agh99].


[...]{.mind} Boner describes *decoupling in time* as the prerequisite for concurrency, and *isolation in space* as the prerequisite to distribution and mobility [citation needed]{.mind}

...

Thus, a particular characteristic of the Actor Model is its facilitation of one and the same primitive for task unit communication in concurrent, parallel and distributed execution contexts.

## Actor Systems {#sec-actor-systems}

~Todo
Hier kann ich ein paar Systeme anteasern. zB die Erlang, die alten Scala Actors, (kurz Akka?), und Kilim
~

~LitNote
* [@Kar09] "Actor frameworks for the JVM platform: A Comparative Analysis"
* [@Che17] "Evaluating Scalable Distributed Erlang for Scalability and Reliability"
* [@Hal09] "Scala Actors : Unifying thread-based and event-based programming"
* [@Hal12] "On the integration of the actor model in mainstream technologies"
* [@Ber14] "Orleans: Distributed Virtual Actors for Programmability and Scalability"
* [@Kar09] "Actor frameworks for the JVM platform: A Comparative Analysis"
* [@Cha13] "Native actors- a scalable software platform for distributed, heterogeneous environments"
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * beschreibt mehrere Actor Systems
    * beschreibt Actor System Properties
* dieses Paper zu Kilim
~

~Todo
Hier sollte ich erklären das die Actors keinen ganzen Thread benötigen, stattdessen viel leichtgewichtiger (und daher billiger sind - im betrieb und da ein thread von der JVM auf einen OS process gemapped werden würde). besonders in Erlang sind sie "lightweight process". In Scala sind sie entweder mit einem Thread Pool umgesetzt (siehe Paper "Unifying thread-based and event-based concurrency"), oder event-based (also kein thread, sondern callbacks?)
~

~LitNote
* [@Hal09] "Scala Actors : Unifying thread-based and event-based programming"
~

~Todo
We do not provide a comprehensive review on actor systems here
~

The Actor model provides a good, easy to understand abstraction. However, though it is theoretically quite easy to understand, the abstraction can pose as a challenge to be used by programmers, depending on the underlying programming model. Programming languages or libraries providing Actor-based concurrency usually aim towards providing more high-level primitives [@Agh90; @Weg90]. Such can be different kinds of message sending, or in terms of expressing behaviour replacement operations. In functional programming, replacement behaviour is usually expressed by a different function that handles the message processing [irgendwo hab ich sowas mal gelesen. war das das noch mal?!]{.mind}. The imperative paradigm realizes this through all flavours of assignment variants [will ich das so sagen??]{.mind}.





[will ich diese bezeichnung hier verwenden?]{.mind}. The idioms provided must be used to map concurrency to the Actor abstraction. In thread-based environments like the *Java Virtial Machine* (JVM), the relatively heavy JVM threads must be used to implement relatively light-weighted Actor abstration. The JVM maps its threads to OS processes, which leads to...



 a This is to a certain degree contrary. Haller & Odersky [@Hal09] call this an "impedance mismatch" between message passing (event-based) and thread-based programming.  

Additionally, the basic Actor primitives introduced in section [#sec-actor-primitives] provide a very low-level abstraction to model computation via an (almost) pure communication paradigm [@Weg90]. Thus they are not too programmer friendly and [es braucht höhere abstraktionen? hab ich da eine quelle?]{.mind} 

---

~Todo
Das ganze Blabla hier hab ich mir mal so aus der Nase gezogen. Gefällt mir noch gar nicht.
~

On the other hand, if the message passing style is incorporated into the underlying fabric[^fn-computing-fabric], then it can be implemented in an even more efficient way. Erlang is a most famous representative of programming languages representing the Actor model [citation needed]{.mind}. It was initially developed to use for phone stuff in the ??? years, a domain where high concurrency was of the essence [blabla zitieren und so]{.mind}...

Erlang is backed by the Actor model by design. While Scala also was conceived with Actor-based concurrency in mind (though other concurrency form - like thread may be easily used), it depends on JVM threads for under the hood execution [ACHTUNG, wie Hal09 beschreibt gab es bei den alten Scala actors ja auch rein event-based actors]{.mind}. Erlang is also a language design for a virtual machine, the BEAM. However, this VM has been desigend to leverage message-passing communication style. Therefore, the Erlang Actors - called processes -  do not 

[^fn-computing-fabric]: In case of directly to machine code compiled languages, the *fabric*  

...

Some basic properties can be obererves across system implementations.

* TODO: At most once delivery, siehe zB [@AkkaMDR]
* As already outlined, when multiple Actor sends messages to the same recipient, no order of messages in the mailbox is guaranteed. This is the reason for nondeterminism in the Actor model. Some Actor systems however tend to narrow down this property, by ensuring that the messages of one sender are enqueued into the receivers mailbox in the same order as they have been dispatched [@AkkaMDR].
* ..  

## Active Objects {#sec-active-objects}

~LitNote
* [@Lav95] "Active Object -- An Object Behavioral Pattern for Concurrent Programming"
* active objects are basically Actors with a different API
    * realized with a proxy object
* vorteil: typsicherheit zur compile time, dass nachrichten an das object (den dahinterliegenden generierten Actor) auch wirklich verarbeitet werden können
* Act.Obj sind sowohl ein Pattern, als auch prinzipiell eine object-orientierte Abstraction des Actor Models (bzw der Actor Semantic?). Actors können Prinzipiell in welchem Paradigma auch immer umgesetzt sein. Entsprechend sind Act.Obj die "besonders object-orientierten Actors"
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * -> Gleiche Zeit wie Agha das Actor model neu formuliert hat, hat Yonezawa (in [@Yon86]) prinzipiell die Active Objects eingeführt
    * AO "support fixed actor interfaces"
* [@Agh90] "Concurrent Object-Oriented Programming"
    * "Actor primitives provide a very low-level description of concurrent systems - much like an assembly language"
    * "High language constructs are necessary both for raising the granularity of description and for encpasulating faults"
* Wenn alle AO ihren eigenen Thread haben, sind sie ja viel heavy-weight als Actors (eher vergleichbar mit Microservices?) --> soll ich das hier andeuten oder eher weiter unten, zB bei den Distr. Obj.?
* "A paper by C. Ellis and S. Gibbs distinguishes between active objects and passive objects.[20] Passive objects comprise information and behaviour, as stated above, but they cannot determine the timing of this behaviour. Active objects on the other hand can do this. In their article Ellis and Gibbs state that active objects have much more potential for the development of maintainable systems than do passive objects." (*C. Ellis and S. Gibbs, Active Objects: Realities and Possibilities, in Object-Oriented Concepts, Databases, and Applications, eds. W. Kim and F.H. Lochovsky, ACM Press, Addison-Wesley, 1989*)
~

~ important
erklären wie AOs implementiert sind, also mittels eines proxy objects -> darauf referenziere ich manchmal
~

As was pointed out, Actor systems try to provide a more high-level interface than the basic primitives to express concurrency. One specific way to realize this is through the concept of *Objects* introduces in the *Object-oriented Programming* (OOP) paradigm. In OOP, [...]{.mind}

Objects encapsulate state and offer operations on this data [@Agh90; @Weg90]. In the terminology of the Smalltalk programming language, these operations are invoked by sending a so-called message to an object [@Bla13]. This already bears resemblence to the Actor concepts and terminology.

Yonezawa et al. was the first introduced a programming language called ABCL/1[^fn-abcl1] [@Yon86] where classic "passiv" objects are extended by their own *thread of control*. Their state is only accessible from within the objects themselves. Access or modification to any state is achieved by invoking the objects public interface methods. Such objects are not idle by default and only perform operations when called upon, but may be *active* on their own, for they live in their own thread [citation?]{.mind}. Thus comes their name: *Active Objects* (AO). 

[^fn-abcl1]: **A**ctor-**B**ased **C**oncurrent **L**anguage. The */1* indicates that it is merely the first of a whole family of languages. Thus it's often omitted in the literature. Consecutive versions do not follow a sequential numbering though, e.g. *ABCL/R*, *ABCL/f* or *ABCL/c+*.

Though AOs aim to provide a purely object-oriented abstraction of Actors, it has been argued that Actors themself already represent the very essence of object-orientation [citation needed]{.mind}. Scholars have long argued about the fundamental concepts of object-orientation. The only truely undebated characteristic seems to be encapsulation of state [@Kni96] coupled to a set of operations sharing this data [@Weg90]. Additionally, Actors share object concepts like their ability to be created, having a unique identity (address), a public interface... [@Sny93] ... [noch irgendwie weiter biegen das halt smalltalk objecte auch immer nebenläufig sind]{.mind}

Its worth pointing out that due to this conformity of the Actor construct with the object essence, scholars do not use the terminologies consistently. In this thesis, we use *Actors* to refere to the concept formulated by Hewitt and refined by Agha, and *Active Objects* for the pattern introduced by Yonezawa to abstract the Actor semantic into a classic object API. However, in the literature, "Active Object" can also be found to be used interchangably with the term "Actor", e.g. as does Guessoum [@Gue99] [um referenzen zu sparen könnte ich diese einfach entfernen, insofern ich sie nirgends sonst mehr verwende]{.mind}.


The following example illustrates the subtle difference in the behaviour of classic versus active objects:

``` {language:java}
class Fnord {
    private int a = 1;
    void add(int b) {
        a += b;
    }
    int get() {
        return a;
    }
}
```

Using the above class `Fnord`{language:java}, we can create the following simple procedure:

``` {language:java}
1   final Fnord f = ...; // obtain reference to an instance
2   f.add(1);
3 
4   print(f.get()); 
```

In a single threaded program, once line 4 is reached, it is save to assume that the the addition has been executed and the internal field `a` was altered. The returned value by the `get()` call in line 4 will result in `2`. 

Altering the definition to `class Fnord extends ActiveObject`{language:java}, with some arbitrary base class `ActiveObject`{language:java} that will turn `Fnord`{language:java} into an Active Object implementation, this observation does not hold any more. When reaching line 3, there is no guarantee that the addition has actually been executed. Line 2 only dispatched the message, and returned to leave the activity to its own flow of execution. Line 54 will block (because `get` has a return value) and wait until the message has been dispatched and an answer arrived. But we cannot assume that we will receive the value `2`, because other messages could have been received by and therefore processes before the unterlying Actor of `f`. 

The major benefit of the Active Object abstraction compared to classic Actors is *type safety*. An Actor in general can receive any type of message. Only when the message was received and is about to be processed, the Actor can decide weither it is actually able to understand the message's type. This is a form of *dynamic type checking* at runtime [citation needed - für den ganzen Absatz]{.mind} - even in statically typed programming languages.

Active Objects on the other hand provide ordinary object-like interfaces. Sending a message to an AO means calling a method with a fixed signature of the object (the proxy respectivly). Thus, only the methods available in the objects *public interface* are even valid to be called, and a compiler is able to statically ensure this during compile time [citation?]{.mind}. This is true for the messages dispatched, as well as for state passed by a messages via any method arguments. On the other hand, due to the nature of AO interfaces, they only provide message passing in a point-to-point communication style. Broadcasting messages would require one method call to address multiple objects, which isn't intended by the object abstraction [@Yon86].

However, unlike as with classic Actors, due to the nature of object interfaces, AOs only offer messaging in a point-to-point communication style [@Yon86], while in general the address concept of classic Actos allows to abstract multiple recipients behind a single address, this a broadcasting of messages [citation]{.mind}.

The Active Objects method signatures do not only provide a certain degree of static type safety, but also influence the behaviour of the objects thread of control. In the original work of Yonezawa et al. they introduce multiple types of message passing for method invocation [@Yon86; @Kos16]:

* Past Type
  : The message is dispatched and the sending objects thread of control immediatelly continues. It does not wait until the message has been processed by the receiver. This is equal to message passing in the Actor model.

* Now Type
  : The message is dispatched and the sender waits for a result. Its thread of control blocks until the receiver processed the message and replied the result. This is equal to a procedure call with a return value.

* Future Type
  : The senders thread of control immediatelly returns, but receives a reference to the result that will be available at some point in the future, once the receiving object has processed the message and replied.

The example above illustrates two of these behaviours of method invocation of Active Objects. While `void add(int)`{language:java} only dispatches a message and immediately returns (past type), `int get()`{language:java} actually waits for a result (now type). Using the future type requires to include an additional abstraction of concurrency, the *Future*. 

## Combination with other Concurrency Abstractions {#sec-actor-concurrency-combination}

~LitNote
* [@Tas13] "Why Do Scala Developers Mix the Actor Model with other Concurrency Models?"
    * "that many of the programs mix actors with other kinds of concurrent entities such as Java threads."
* [@Les09] "Concurrent Programming Paradigms, A Comparison in Scala"
* [@Swa14] "Towards Composable Concurrency Abstractions"
~

The actor model is a mature, general purpose model for expressing concurrent computation. It has some clear principles which must be upheld in order to ensure the intended semantic. Besides these, the model does not make additional assumptions on the environment it is used in [schlecht formuliert]{.mind}. This make the Actor model flexible and applicable for general purpose computation. Concurrency is basically a mere side-effect from its principles [citation?]{.mind}. As a result, it allows the model to be combined with additional arbitrary approaches to express computation, as long as such do not jeopardize the Actor semantic. Even other concurrency abstractions are not excluded from this.

As such, mixing Actors with other concurrency models has always been common. The reasons for introducing additional abstractions are manyfold. Tasharofi et al. empirically found that the major inadequacies of Actor Systems are found in there lack of efficiently supporting blocking operations (especially IO) and that developers find many communication protocols hard to express in an asynchronous messaging style [@Tas13].  

Therefore, in order to overcome these shortcommings, additonal concurrency models are interweaved. This raises the issue of the requirements for any two concurrency models being *composable* without any inconsistencies.

Swalens et a. regard two concurrency models composable if their integration does not result in any new effects regarding *safety* and *liveness* that have not been there before [@Swa14]. The Isolated Turn Principle of the Actor model already gives a strong boundry to ensure these properties [@Kos16]. Added concurrency concepts therefore must not weaken this.

~LitNote
* Drawbacks of breaking the Actor semantic [@Tas13]:
    * potential of fine-grained (low level?) data races (also in [@Swa14], see "safety")
    * reduce readability, maintainability
~

### Futures

~LitNote
* [@Lis88] "Promises: linguistic support for efficient asynchronous procedure calls in distributed systems"
* [@Fla99] "The semantics of future and an application"
~

The traditional notion of a procedure call is that the execution flow only continues once the computation performed by the called procedure has finished. Of course, given procedure could dispatch a concurrent execution and return without a result, thus the flow of execution may actually resume before said computation is finished in general. However, if given procedure provides a return value, the control flow is expected to *block* until respective value has been calculated. [irgendwas sollte ich hier zitieren]{.mind}

However, in many cases the respective result is not required immediatelly by the subsequent computation. The control flow might continue without accessing given value for some time. Thus it is possible to resume the callers activity, while the called procedure is executed concurrently in a separate thread of control. The procedure initially simply returns a placeholder that will contain the actual result value at some point in the future [@Wel05; @Fla99]. Such values are therefore used in a *semi-synchronous* fashion [TODO wo stand das nochmal?!]{.mind}. There calculation is performed *asynchronously* in general. The calling and the called thread are again *synchronized* once the placeholder is issued for the actual result. This is sometimes dubbed to *touch* or *claim* the value, and may expand to blocking the current control flow if the result is not yet available [@Wel05; @Tas13]. 

The concept of such eventually retrievable values is not uniformly named in the literature. Baker and Hewitt [@Bak77] describe the concept of a *Future* that "delivers the value of an expression at some later time". Liskov and Shrira [@Lis88] extended this idea by introducing a data type called *Promise* for result values that may be single-assigned at some point in the future. More seldomly used terms are *Eventual*, *Delay* or *Deferred* [@Pra18]. The kind of evaluation order expressed by these concepts is sometimes refered to as *call-by-future* [@Bak77] or *call-by-need* [@Agh85a].

Java and Scala, among others like C#, Dart, etc., have a special view on such eventual values, for they support both `Future`{language:java}s as well as `Promise`{language:java}s. There, a `Future`{language:java} represents a read-only container used as the placeholder for an eventually computed value, while a `Promise`{language:java} is a single-assignment variable used explicitely to set a value at *some* point in time, i.e. to complete a `Future`{language:java}[^fn-java-promise]. In other words, a `Future`{language:java} referes to a `Promise`{language:java} that will be kept eventually [@Hal18; @Pra18].

[^fn-java-promise]: Therefore it is called `CompletableFuture`{language:java} in Java, instead of `Promise`{language:java} as is in Scala.

Though today all designations tend to be used interchangeably, and refere to roughly the same idea [@Swa14], we will confine to the term "Future" as it is used in Java and Scala, and to its semantic as is provided by these languages.

~Todo
used for async (remote) procedure calls; may be type safe as in Java/Scala (but was originally dynamically typed)
~

There has been a long tradition of combining Actors with Futures. Agha describes that Actors are often used to model call-by-need computation [@Agh85a], which is essentially a Future. It can also be traced back to ABCL/1 and its Active Object notion [@Yon86]. Three kinds of message passing for AOs have already been discussed. The example back then only demonstrated two of them though (past type and now type). The third, coincidentially called *future type*, is actually the result of combining Actor concurrency semantic with the Future concurrency abstraction [@Tas13]. It will be demonstrated in subsequent examples.

For a complete formal definition of Future semantic we refere the interrested reader to Flanagan and Felleisen [@Fla99].

### Software Transactional Memory

~LitNote
* [@Sub11] demonstrates how Akka support STM together with Actors
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * "...when an operation spans several messages the programmer must provide a custom synchronisation mechanism to pre- vent potential bad interleavings and ensure correct execu- tion"
* [@Sha17c]:
    "control the isolation level across concurrent computations"
~

As we've pointed out, the Actor model provides single-threaded semantic inside an Actor while processing one message. On the other hand however, the asynchronous messaging style tends to become a burden when it is required to have some sort of consensus between multiple Actors, for the model does not provide an adequat mechanism to abstract operations involving multiple messages [@Sub11]. Such is expected to be taken care of by the programmer.

A well known concept to provide a single-threaded appearence on accessing some state or memory that is generally accesses concurrently, is called *transaction*. A transaction is a computation that does not have to be atomic by itself (e.g. larger code block), but still logically appreas to happen within a single instant in time [@Les09]. Therefore, all memory modifications done inside the transaction become atomic from the outside perspective. If for some reason the transaction becomes invalid, usually for it can not be guaranteed to run in isolation due to a write collisions [@Sub11], all state modifications are rolled back accross the entire code segments involved in the transaction. We generally consider transactional semantic realized in software[^fn-hardware-transaction] only, which is commonly refered to as *Software Transactional Memory* (STM).

[^fn-hardware-transaction]: Originally, the concept was proposed for supporting transactions in functional languages, but in hardware. Hence the distinction.

There are multiple ways how transactions are realized. For example, they can be done directly in hardware [citation!]{.mind}. This means on the other hand they are also possible to be modeled entirely within software. 

~Todo
Hier etwas erklären wie STM intern funktioniert, siehe [@Les09]
~  

Combining transactions with Actors can have a huge impact on performance. Especially write collisions raise the amount of coordination required. Though this can be done transparently by abstractions provided by an Actor system, it always means additional message processing of the Actors involved, potentially turning into a bottleneck [@Sub11]. This is especially crucial e.g. for proposed database concepts leveraging the Actor model, for transactions are an essential functionality in database systems [@Sha17c].

