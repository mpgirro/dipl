
The Actor Model {#ch-actor-model}
===============

~ Epigraph { caption: "C.A.R. Hoare"}
Some problems are better evaded than solved.
~


<!--## A Model of Computation {#sec-actor-primitives}-->


In this thesis, we will focus on one particular model of concurrent computation. The *actor model* is based on a formalism Hewitt *et al.*\ [@Hew73] introduced in the 1970s. As the model's name suggests, it builds upon the concept of *actors* as basic building blocks. Agha describes them a self-contained, interactive and independent components that are communicating via asynchronous message passing [@Agh90]. He also reformulated the actor model into three basic primitives an actor can perform upon receiving a message [@Agh85a]:

1. Sending a finite number of messages to itself or other known actors.
2. Creating a finite number of new actors.
3. Changing its internal behavior for the next message that it receives with the so-called *replacement behavior*.

In order to send a message, the unique *address* of an actor must be known. The underlying *actor system* delivers the message. In general, the order of delivery is nondeterministic. Actor addresses can be announced to other actors by sending the address as a message. This method of propagating locations provides the ability of *dynamic reconfiguration* [@Agh90].

Messages are processed one at a time. Therefore, every message has to be buffered in the so-called *mailbox*, if an actor is not able to process an incoming message immediately, because it is already engaged in a message handling operation. Accessing the mailbox is race-free, and therefore safe [@Hal09].


## Message Passing and Encapsulation {#sec-actor-messaging-encapsulation}


The actor concept defines that the only possible form of communication between actors is the exchange of messages. This restriction implies that there is no directly shared state between actors. State is *encapsulated* within an actor exclusively. To access an actor's state, we must send an appropriate message to request it. Processing messages is done in a serialized fashion. This provides the basis for *isolation* [@Les09]. All state modifications done while processing a single message appears *atomic*. New messages do not interrupt an actor currently processing a message [@Agh99], because every message gets buffered inside the mailbox.

It is important to realize that requested state informations are always mere snapshots of the actor's state at a specific point in time (the point where this actor processed the requesting message). The information can therefore already be outdated once the requestor receives the snapshot answer [@And83]. On the other hand, the isolation of state frees actors from the implications of shared state or resource handling, like bottlenecks introduced by sequential locking [@Agh90]. Passed messages must be immutable, copied or proxied to ensure snapshots do not violate encapsulation semantics and prevent accidentally exposing direct access to internal state or resources [@Kos16]. This immutability guarantee allows save coordination at a distance [@Hel15]. 

Changing internal state within an actor is realized through the third of the basic primitives: behavior replacement. In general, this primitive can be used to change the behavior of the actor entirely -- in the actor taxonomy also called to *become* different operations for all following messages. However, the behavior can also become the same operations, but for a different state [@Weg90]. It is important though that behavior replacement does not break the *referential transparency* of the actor's identifiers (addresses) [@Agh90]. Therefore, changing actor internals has no effect on its reachability for other actors. The actor logically stays the same, but will behave differently when processing the next message. This strict encapsulation of state and decoupling via immutable, asynchronous message passing leads to a strong form of *isolation* between actors [@Agh14]. State within an actor is mutable, but isolated from the outside and only available through immutable snapshots.

Additionally, state can only be changed while processing a message. Therefore, as De Koster *et al.*\ illustrate in detail, we can view the processing of a single message as an isolated operation. This is important when reasoning about actors, because it is done with respect to the single-threaded semantics which is providing the granularity of a turn[^fn-isolated-turn-principle] [@Kos16;@Ber14]. They call this *isolated turn principle*. The principle guarantees the safety of actors, because they are free of low-level data races (for only one message is processed at a time, and each message belongs to a single actor). However, high-level races (depending on the interleaving of messages within the mailbox) can still occur. The isolated turn principle also guarantees computation progress with each turn [@Agh97], and thus liveness. 

[^fn-isolated-turn-principle]: In this context, *turn* is used to refer to the processing of a single message. Various terminologies have been used for this over the decades. A good overview of actor model taxonomy and the equivalence of various terms is given in [@Kos16].


## Unified Abstraction
<!--## Unifying Concurrent, Parallel and Distributed Computation-->


Until now, we've described the actor model as a general model of computation. The abstraction of actors provides a strict separation of components state, as well as a loose coupling via asynchronous message passing. Actors encapsulate not only data and functionality, but also their own *thread of control*, making actors autonomous [@Agh99]. This autonomy allows for a concurrent execution of actors components, effectively making the actor abstraction into a model of *inherent concurrent computation* [@Agh91]. 

There are numerous models that are able to provide inherent concurrency, e.g.\ logic programming or  functional programming. The benefit of the actor concept however is the supports for the direct expression of state [@Agh91]. This state can only be manipulation within an actor and while it is processing a message -- an operation that is guaranteed to be atomic. Omitting to share state and only communicating it via asynchronous message passing greatly improves the safety of actors, as it eliminates a whole class of errors, the *race conditions* [@Cha13]. 

The dynamic data flow of messages is the primary source of nondeterminism. No order of messages is guaranteed when various actors send messages to the same actor. The actual order of processing the messages affects the behavior, resulting in nondeterminism. The benefit of not enforcing a message order eliminates unnecessary synchronization overhead [@Kar09; @Agh90; @Agh99].

The actor model provides a strict concept of isolated and decoupled components. The only link between actors is the delivery of messages, based on their addresses. These addresses are virtual by not exposing physical location information [@Ber14; @Tas13]. Actors are therefore not restricted to physical locations by their addresses. As a result, concurrently executed components are not required to be inside the same process boundary, nor the same host machine in fact. The addresses can bridge the gap in physical distance. Separating virtual and physical location is generally referred to as *location transparency* [@Kar09;@Agh99]. The concurrent components of the actor model inherently also support parallel component execution, as they can be transparently assigned to processor cores.

Additionally, location transparent addresses enable referencing actors even outside the scope of a CPU, providing the foundation for distributed execution on different nodes [@Kar09]. Execution on the same CPU is therefore often referred to as *intra-node*, while distributed execution as *inter-node* parallelism [@Reh13]. Intra-node components are still physically close, and can assume that their communication channel is reliable. Inter-node component have no guarantee on the safety and reliability of their communication channel. The messages must travel via network links (cf.\ Fallacy 1: *the network is reliable*). The only valid assumption is that communication is more costly and volatile in any case [@Agh99]. A particular characteristic of the actor model is therefore its facilitation of one and the same primitive for task unit communication in concurrent, parallel and distributed execution contexts.


## Actor Systems and Variations {#sec-actor-systems}


Actors are autonomous computational entities, but not individually deployable on operating systems in general. They require a runtime environment, the so-called *actor system*, to exist within. Actor systems have two general concerns: providing the linguistic support for using actors (programming interface and model semantics) and achieving efficient actor execution [@Kar09]. 

Depending on the underlying programming model, the actor concept and primitives can pose a challenge for programmers, since the model primitives provide a very low-level abstraction to model computation via an (almost) pure communication paradigm. Therefore, actor systems tend to provide additional, more high-level primitives [@Agh90;@Weg90], e.g.\ for expressing various communication patterns.

Efficiency can pose a challenge, as the idioms of the underlying system or platform must be used to map concurrency to the actor abstraction. In thread-based environments like Java's virtual machine, the relatively heavy JVM threads provide the foundation for the execution of relatively light-weighted actor constructs. One implementation for JVM threads is the direct mapping of a thread to an OS process. In this case, each actor is executed as a system process. Haller & Odersky [@Hal09] call this an "impedance mismatch" between message passing (event-based) and thread-based programming. In this concrete example, the negative impact can be mitigated by not assigning one dedicated thread per actor. Instead, the runtime can employ a scheduling strategy similar to operating systems. With scheduling, many actors share the resources provided by fewer threads [@Kar09]. 

Numerous actor system implementations do exist. All diverge in term of features and model semantics realization. We've identified three that merit special attention:

* Erlang
  : A programming language dedicated to actor-based programming is *Erlang* [@Arm93;@Vin07]. It is well-known for introducing programming with actors to a broader industrial application. Erlang was first used by Ericsson in 1986 to build telecommunication infrastructure. In contrast to most programming languages, an Erlang program has the main focus on its so-called *process* constructs (actors), rather than e.g.\ objects or functions. Erlang was designed to meet challenges like high concurrency, availability, fault-tolerance and live-upgrades [@Vin07;@Kos16].

* Akka
  : Released in 2009, *Akka* [@LightbendAkka] is the most important actor framework for the JVM today. It offers bindings for the Java and Scala programming languages. Akka was highly inspired by Erlang and facilitates many of the same conceptualities in order to meet similar concerns. Examples are scalability, fault tolerance and remoting/distribution. As a library, Akka is faced with conceptual difficulties endangering the actor model semantics. These dangers are typically avoided with dedicated ecosystems, as does for example Erlang and its virtual machine called BEAM. Section [#ch-actor-impl] concerns Akka and the challenges posed by the JVM as the target platform in more detail. 

* Orleans
  : A recent variant of an object-oriented interpretation of actors called *active objects* is *Orleans* [@Ber14]. It was constructed by Microsoft Research in 2011 to meet the requirements of highly distributed deployment setups, currently referred to as *cloud computing*. Orleans facilitates what it calls the *virtual actor model*. A virtual actor (called a *grain*) does not exist *pysically* as an entity all the time. A grain is only (re-)instantiated automatically when it is required. In constrast to most other actor variants including Erlang and Akka, this omits the need for lifecyle management. This "virtuality" characteristic turned out to be more suitable in high-scale dynamic workloads of todays cloud computing deployment setups.
 
Erlang, Akka and Orleans have to our knowledge the most significance for industrial applications. In the remainder of this thesis, we will refer to individual characteristics of all three to point out relevant differences and noteworthy capabilities.


## Active Objects {#sec-active-objects}


As was pointed out, actor systems often aim to provide a more high-level interface than the mere  basic primitives to express concurrency. One specific way to realize a higher level is through the concept of *objects* as were introduced in the *object-oriented programming* (OOP) paradigm. Objects encapsulate state and offer operations on this data [@Agh90; @Weg90]. In the terminology of the Smalltalk programming language, operations are invoked by sending a so-called *message* to an object. This terminology already points out the conceptual resemblance between actors and objects in general [@Sco06].

Yonezawa *et al.*\ [@Yon86] were the first to introduce classic "passive" objects extended by their own *thread of control* in a programming language called ABCL/1[^fn-abcl1]. The state of an object in ABCL/1 is only accessible from within the object itself. Access or modification to state is achieved by invoking the public interface methods of the object. However, the objects are not idle by default and only perform operations when called upon. Objects are *active* on their own, since they live in their own thread. Hence comes their name: *active objects* (AO). When an active object's method is invoked, the actual method execution is decoupled and performed concurrently. The method invocation is usually realized through a *proxy object* on the client side (invoker). The proxy merely mirrors the AO's public interface and handles the message dispatch. The actual computation is done on a server object (the invoked active object) running on a separate thread in general [@Lav95]. Meyer [@Mey97] points out one general notion of active objects emphasizing a viewpoint with a focus on conceptualities that will merit special attention in due course:

> "Each object is a single, identifiable process-like entity (not unlike a Unix process) with state and behavior."

[^fn-abcl1]: __A__ctor-__B__ased __C__oncurrent __L__anguage. The */1* indicates that it is merely the first of a whole family of languages. We've found it often omitted in the literature. Consecutive versions do not follow a sequential numbering, e.g.\ *ABCL/R*, *ABCL/f* or *ABCL/c+*.

Though AOs aim to provide a purely object-oriented version of actors, it has been argued that actors themselves already represent the very essence of object-orientation [@Agh90]. Scholars have long debated the fundamental concepts of object-orientation. The author of this thesis came to the conclusion that the only truly undebated characteristic seems to be encapsulation of state [@Kni96] coupled to a set of operations sharing this data [@Weg90]. Additionally, actors share object concepts like the ability to be created, having a unique identity (address) and a public interface [@Sny93]. As a result, it has often been argued that either actors are convenient for the foundation of active objects, or that AOs are suitable to implement actors [@Lav95].

Its worth pointing out that due to this conformity of the actor construct with the object essence, scholars do not use the terminologies consistently. In this thesis, we use *actor* to refer to the concept formulated by Hewitt and refined by Agha, and *active object* for the pattern introduced by Yonezawa to abstract the actor semantics into a classic object API. In the literature however, we've found "active object" to be used interchangeably with the term "actor".

The following example illustrates the subtle difference in the behavior of classic versus active objects:

``` {language:java}
class Fnord {
    private int a = 1;
    void add(int b) {
        a += b;
    }
    int get() {
        return a;
    }
}
```

Using the above class `Fnord`{language:java}, we create the following simple procedure:

``` {language:java}
1   final Fnord f = ...; // obtain reference to an instance
2   f.add(1);
3 
4   print(f.get()); 
```

In a single threaded program, once line 4 is reached, we can safely assume that the addition has been executed and the internal field `a` was altered. The returned value by the `get()` call in line 4 subsequently results in `2`. 

Now we alter the definition to `class Fnord extends ActiveObject`{language:java} with some arbitrary base class `ActiveObject`{language:java} that will turn `Fnord`{language:java} into an active object implementation. Then, the previous observation does not hold anymore. When line 3 is reached, we have no guarantee that the addition was already executed. Line 2 only dispatched the message and returned to leave the activity to its own flow of execution. Line 4 blocks (because `get` has a return value) and waits until the message was dispatched and an answer arrived. But we cannot assume that we receive the value `2` anymore. The active object can receive other messages and process them between our `add(1)` and `get` messages. The nondeterminism introduced by the concurrent behavior hinders us to safely reason about our result value.

We see, although active and passive objects offer the same interface, they do not provide the same degree of safety. The author believes this safety mismatch to be dangerous for programmers in general. The non-AO actor variants regared by the author do not provide interfaces that can be mistaken for non-concurrent entities. Therefore, these actors do not risk offering programmers a false sense of safety. However, there is one major benefit of active objects compared to classic actors. The object interface enables *type safety*. Messages to AOs are strongly typed [@Lav95]. An actor in general can receive every type of message. Only when the message is processed, an actor decides whether it is actually able to understand the message's type. Actors therefore perform *dynamic type checking* at runtime -- even in statically typed programming languages.

On the other hand, active objects provide ordinary object-like interfaces. Sending a message to an AO means calling a method with a fixed signature of the object (the proxy respectively). We are only allowed to call the methods available in the object's public interface. A compiler is able to statically ensure message validity at compile time. This is true for the messages dispatched, as well as for state passed by a messages via any method arguments. Due to the nature of AO interfaces, they only provide message passing in a point-to-point communication style. Broadcasting messages  hypothetical requires one method call to address multiple objects. This behavior isn't intended by the object abstraction [@Yon86].

The active object method signatures do not only define communication with a certain degree of static type safety. Every signature also influences the behavior of an object's thread of control. Therefore, signatures constrain synchronization [@Lav95]. In the original work of Yonezawa *et al.*, they introduce multiple types of message passing for method invocation [@Yon86; @Kos16]:

* Past Type
  : The message is dispatched and the sending object's thread of control immediately continues. The thread does not wait until the message has been processed by the receiver. This behavior is equal to message passing in the classic actor model.

* Now Type
  : The message is dispatched and the sender waits for a result. Its thread of control blocks until the receiver processed the message and replied the result. This behavior is equal to a method call (with a return value) on passiv objects.

* Future Type
  : The sender's thread of control immediately returns, but receives a reference to the result that will be available at some point in the future. The actual result becomes available once the receiving object has processed the message and replied.

The example above illustrates two of these behaviors of method invocation of active objects. `void add(int)`{language:java} only dispatches a message and immediately returns (past type). In contrast, `int get(void)`{language:java} actually waits for a result (now type). Using the future type requires us to include an additional model of concurrency, the *future*. 

<!--
Table [#tab-actor-ao-comparison] gives an overview of the major differences relevant to our considerations between actors and active objects.

~ Begin TableFigure { #tab-actor-ao-comparison; caption: "Major differences between actors and active objects"; page-align:here}
|-------------------------|-------------------|----------------------------------|
| Characteristic          | Actors            | Active Objects                   |
+-------------------------+-------------------+----------------------------------+
| Basic construct         | Arbitrary "actor" | Object                           |
| ------------------------|-------------------|----------------------------------|
| Message typization      | Dynamic           | Static                           |
| ------------------------|-------------------|----------------------------------|
| Message synchronization | Asynchronous      | Synchronous/asynchronous/future, |
|                         |                   | depends on method signature      |
| ------------------------|-------------------|----------------------------------|
~ End TableFigure
-->


## Integration of other Concurrency Abstractions {#sec-actor-concurrency-combination}


The actor model is a mature, general purpose model for expressing concurrent computation. It has some clear principles which must be upheld in order to ensure the intended semantics. Besides these principles, the model does not make additional assumptions and restrictions. This makes actors flexible and applicable for general purpose computation. Concurrency, or the suitability for it, is basically a merely inherited side-effect. As a result, we can combine the model with additional, arbitrary approaches to express computation. Even concurrent models are possible, as long as every introduced concept does not jeopardize the actor semantics.

As a result, mixing actors with other forms of concurrency has always been common. The reasons for introducing additional abstractions are manifold. Tasharofi *et al.*\ empirically found that the major inadequacies of actor systems thought by programmers are their lack of efficiently supporting blocking operations (especially IO) and that many communication protocols are hard to express in an asynchronous messaging style [@Tas13].  

In order to overcome these shortcomings, additional concurrency models are interweaved. This raises the issue of the requirements for two concurrency models being *composable* without inconsistencies. Swalens *et al.*\ regard two concurrency models as composable if their integration does not result in any new effects regarding *safety* and *liveness* that have not been there before [@Swa14]. The isolated turn principle of the actor model already gives a strong boundary to ensure these properties [@Kos16]. Added concurrency concepts must neither weaken these boundaries nor the model properties. Especially, the introduction of low-level data races is very easy for new abstractions and must therefore be carefully avoided [@Tas13].


### Futures


The traditional notion of a procedure call is that the execution flow only continues once the invoked computation has finished. Of course, given procedure can dispatch a concurrent execution and return without a result. The flow of execution then actually resumes before said computation has finished in general. However, if the procedure provides a return value, we expect the control flow to *block* until the respective value is available [@Tan07].

In many cases, we do not immediately require the result for the subsequent computation. The control flow is able to continue without accessing the value for some time. Therefore, it is possible to resume the caller's activity, while the called procedure is executed concurrently in a separate thread of control. The procedure initially returns a simple placeholder that will contain the actual result value at some point in the future [@Wel05; @Fla99]. Such values are used in a *semi-synchronous* fashion. The value calculation is performed *asynchronously* in general. The calling and the called thread are again *synchronized* once we access the placeholder for the actual result. This is sometimes dubbed to *touch* or *claim* the value. Attempting to access a placeholder expands to blocking the current control flow if the result is not yet available [@Wel05; @Tas13]. 

The concept of eventually retrievable values is not uniformly named in the literature. Baker & Hewitt [@Bak77] describe the concept of a *future* which delivers the result of an expression eventually. Liskov & Shrira [@Lis88] extended this idea by introducing a data type called *promise* for result values that may be single-assigned at some point in the future. More seldomly used terms are *eventual*, *delay* or *deferred* [@Pra18]. The kind of evaluation order expressed by these concepts is sometimes referred to as *call-by-future* [@Bak77] or *call-by-need* [@Agh85a].

Some programing languages, among them Java and Scala, have a special view on eventual values. These languages support both `Future`{language:java}s as well as `Promise`{language:java}s. There, a `Future`{language:java} represents a read-only container used as the placeholder for an eventually computed value. In contrast, a `Promise`{language:java} is a single-assignment variable we use to explicitly set a value at *some* point in time, i.e.\ to complete a `Future`{language:java}[^fn-java-promise]. In other words, a `Future`{language:java} refers to a `Promise`{language:java} that will be kept eventually [@Hal18; @Pra18]. Though today all designations tend to be used interchangeably and refer to roughly the same idea [@Swa14], we will confine to the term "future" as it is used in Java and Scala and subsequently to the respective semantics provided by these languages.

[^fn-java-promise]: Therefore it is called `CompletableFuture`{language:java} in Java, instead of `Promise`{language:java} as it is in Scala.

There has been a long tradition of combining actors with futures. Agha describes that actors are often used to model call-by-need computation [@Agh85a], which is essentially a future. It can also be traced back to ABCL/1 and its active object notion [@Yon86]. We've already discussed three kinds of message passing for AOs. The example then merely demonstrated two (past type and now type). The third, coincidentally called *future type*, is actually the result of combining actor concurrency semantics with the future concurrency abstraction [@Tas13]. Orleans uses promises/futures as the only form of method call for all active objects [@Ber14].  

For a complete formal definition of future semantics we refer the interested reader to Flanagan & Felleisen [@Fla99].


### Software Transactional Memory


The asynchronous messaging style of actors becomes a burden when we need some sort of consensus between several actors. The model does not provide an adequate mechanism to abstract operations involving multiple messages [@Sub11]. We need an additional high-level model ontop of the messages.

The *transaction* is a well-known concept to provide a single-threaded appearance to the access of state or memory that is generally accessed concurrently. A transaction encapsulates a computation that does not have to be atomic by itself (e.g.\ code block), but still logically appears to happen within a single instant in time [@Les09]. Therefore, all memory modifications done inside the transaction become atomic from the outside perspective. If a transaction becomes invalid, all state modifications are rolled back across the entire code segments involved in the transaction. Write collisions are one reason for transactions to become invalid. Upon a collision, the isolation of the transaction cannot be guaranteed anymore [@Sub11]. *Software transactional memory* (STM) refers to transactional semantics realized in software[^fn-hardware-transaction]. In the scope of this thesis, STM is the only considered transaction mechanism.

[^fn-hardware-transaction]: Originally, the concept was proposed for supporting transactions in functional languages, but in hardware. Hence the distinction.

Combining transactions with actors can have a huge impact on performance. Especially write collisions raise the amount of coordination required. Though all coordination can happen transparently through an actor system, it always means additional message processing of the actors involved, potentially turning into a bottleneck [@Sub11].
