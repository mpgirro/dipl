
The Actor Model {#ch-actor-model}
===============



~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~

~LitNote
* [@Agh85a] "ACTORS: A Model of Concurrent Computation in Distributed Systems"
* [@Agh85b] "Concurrent Programming Using Actors: Exploiting Large-Scale Parallelism"
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
    * 1973 mathematical model
    * Bill Kornfeld and Carl Hewitt [1981] showed that the Actor model could encompass large-scale concurrency.
    * Agha developed Actors as a fundamental model for concurrent computation
~

In this thesis, we will focus on one particular abtraction for modelling concurrent computation. It is based on a formalism Hewitt [original referenced needed]{.mind} introduced in the 1970s. As the models name suggests, at its foundation it build upon the abstraction of *Actors*. Agha describes them a self-contained, interactive and independent components that are communication via asynchronous message passing [@Agh90]. Therefore it performes actions in response to received messages.

Upon receiving a message, an Actor can react in with three basic primitives:

1. Sending a finite number of messages to itself or other known actors.
2. Creating a finite number of new actors.
3. Changing its internal behaviour for the next message that it receives with the so-called *replacement behaviour*.

In order to send a message, the unique *address* of an Actor must be known. The unterlying system delivers the message. In general, the order of delivery is non-deterministic. Actor addresses can be announced to other Actors by sending the address as a message. This allows for *dynamic reconfiguration* [@Agh90].

Messages are processed one at a time. Therefore, they have to be buffered in the so-called *mailbox* if an Actor is not able to process an incomming message immediately, because it is already engaged in a message handling operation [citation needed]{.mind}

## Message Passing and Encapsulation {#sec-actor-messaging-encapsulation}

~LitNote
* every Actor owns its state exclusively (should also have unique DB -> bad performance, discuss in Actor-Impl chapter) --> das DB thema sollte ich lieber im praktischen solution teil bei "persistence" beschreiben
* It should be hard to create an actor directly, better reference it via an actor ref. [@Sub11] gives nice JAva code with factor method
* messages need to be immutable
~

The Actor abstraction defines that the only possible form of communication between Actors is by exchanging messages. This implies that there is no directly shared state between them [citation needed]{.mind}. Actor semantic means state is *encapsulated* within an Actor exclusively. To access the state, it must be requested by sending an appropriate message. 

It is important to realize that requested state informations are always mere snapshots of any Actors state at a specific point in time (the point where this Actor processes the requesting message), and the information might therefore be already outdated once the requestor receives the snapshot answer [citation needed]{.mind}. This is the semantic of any form of asynchronous communication [citation needed]{.mind}. On the other hand, it frees Actors from the implications any form of shared state or resource handling, like the bottle-necks introduces by sequential locking, brings with it [@Agh90].  

To ensure snapshots do not violate encapsulation semantic and prevent accidentally exposing direct access to any internal state or resource, passed messages must be guaranteed to be *immutable* [citation needed?]{.mind}. This allows save coordination at a distance [@Hel15]. 

Changing internal state within an Actor is realized through the third of the basic primitives: behaviour replacement. It is important that this action though does not break the *referential transparency* of the Actors intentifiers used to send messages to it [@Agh90]. Therefore, changing Actor internals has not effect on its reachability for other Actors. 

This strict encapsulation of state and decoupling via immutable, asynchronous message passing leads to a strong form of *isolation* between Actors [citation needed]{.mind}. State within an Actor is mutable, but isolated from the outside and only available through immutable snapshots.


## Active Objects {#sec-active-objects}

~LitNote
* [@Lav95] "Active Object -- An Object Behavioral Pattern for Concurrent Programming"
* active objects are basically Actors with a different API
    * realized with a proxy object
* vorteil: typsicherheit zur compile time, dass nachrichten an das object (den dahinterliegenden generierten Actor) auch wirklich verarbeitet werden k√∂nnen
~

``` {language:java}
class Fnord {
    private int a = 1;
    void add(int b) {
        a += b;
    }
    int get() {
        return a;
    }
}
```

Using the above class `Fnord`{language:java}, we can create the following simple program:

``` {language:java}
1  void doSomething() {
2    Fnord f = ...; // obtain reference to a Fnord instance
3    f.add(1);
4 
5    print(f.get()); 
6  }
```

In a single threaded program, once line 4 is reached, it is save to assume that the the addition has been executed and the internal field `a` was altered. The returned value by the `get()` call in line 5 will result in `2`. 

Altering the definition to `class Fnord extends ActiveObject {...}`{language:java}, with some arbitrary base class `ActiveObject`{language:java} that will turn `Fnord`{language:java} into an Active Object implementation, this observation does not hold any more. When reaching line 4, there is no guarantee that the addition has actually been executed. Line 3 only dispatched the message, and returned to leave `doSomething` to its own flow of controll. Line 5 will block (because `get` has a return value) and therefore wait until the message has been dispatched and an answer arrived. But we cannot assume that we will receive the value `2`, because other messages could have by received by and therefore processes before the unterlying Actor of `f`. 


## Combination with other Concurrency Abstractions

### Futures

### Software Transactional Memory (STM)

~LitNote
* [@Sub11] demonstrates how Akka support STM together with Actors
~

## Object-Oriented Perspective

### Data Abstractions

Encapsulation and Information Hiding

### SOLID design principles

### Design by Contract

### Substitution and Behaviour