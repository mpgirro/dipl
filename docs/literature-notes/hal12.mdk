# [@Hal12] On the Integration of the Actor Model in Mainstream Technologies

* Integrating the actor model into mainstream software platforms is challenging because typical runtime environments, such as the Java Virtual Machine, have been designed for very different concurrency models.
* Actors are a powerful abstraction for structuring highly concurrent software systems which scale up to many-core processors, as well as scale out to clusters and the cloud.
* Since then, there has been a steady stream of both research results and industrial development, contributing to a renewed interest in actors in academia, as well as innovations powering state-of-the-art frameworks like the Akka event-driven middleware [18].
* Integrating the actor model into mainstream software platforms is a formidable challenge. On the one hand, industrial-strength im-plementations have to make optimal use of underlying runtime en-vironments which typically have not been designed to support ac-tors.
* On the other hand, in order to integrate with existing infras-tructures, it is necessary to support execution modes and constructs that are rather foreign to a pure notion of actors, such as blocking operations, and interoperability with native platform threads.
* High-level domain-specific language (R2). While actors are provided using library abstractions in Scala, it is important that their programming interface is “competitive” with languages with specialized concurrency support.
* Event-driven implementation (R3). Actors should be mapped to lightweight tasks triggered by messaging events. Spending an entire virtual machine thread per actor does not scale to large numbers of actors. At the same time, the benefits of thread-based programming should remain accessible in cases where a purely event-driven model would be too restrictive.
* High performance (R4). The majority of industrial applica-High performance (R4). The majority of industrial applica- tions where actors provide most benefits are highly performance sensitive. Past experience with industrial Erlang appli-cations [1, 14] suggests that scalability is more important than raw performance. On the other hand, it is known that a high-performance virtual machine such as the JVM can enable ap-plications to scale out much more gracefully than other runtime environments. In addition, benchmarking offers a simple evaluation strategy if the compared benchmark programs are of sim-ilar complexity.
* Flexible remote actors (R5). Many medium-sized and large ap-Flexible remote actors (R5). Many medium-sized and large ap- plications can benefit from remote actors, i.e., actors that com-municate transparently over the network. In many cases, flexi-ble deployment mechanisms, e.g., using external configuration, are very important.
* An actor is a process that communicates with other actors by exchanging messages. The principal message send operation is asynchronous. Therefore, an actor buffers incoming messages in a message queue, its mailbox.
* For simplicity, we’re going to refer to the latter as sreceive and to the former as areceive (Akka’s receive) in the following. The main difference between sreceive and areceive is that the former operation is blocking, i.e., the current actor is suspended until a matching message can be removed from its mailbox. On the other hand, areceive is used to define a global message handler, which, by default, is used for processing all messages that the actor receives over the course of its life time. Moreover, the message handler defined by areceive only gets activated when a message can be removed from the mailbox.
* Another important difference is that areceive will never leave a message in the mailbox if there is no matching pattern, which is different compared to sreceive. Whenever the actor is ready to process the next message, saym,m is removed from the mailbox; if there is no pattern that matches m, an event is published to the system, signaling an unhandled message.
* Bridging the Gap: From Erlang to Akka
    * The semantics of sreceive and areceive are quite different. sreceive has the same semantics as “receive” in Erlang [2]. On the other hand, areceive can be implemented more efficiently on the JVM. Each construct enables a different programming style for messag-ing protocols.
    * The main difference between creating an actor in Scala Actors and in Akka is that the above actorOf method in Akka returns an instance of type ActorRef instead of an instance of the specific Actor subclass. One of the main reasons is encapsulation.
*  Encapsulation
    * The actor runtime guarantees thread safety of actor interactions only if actors communicate only by passing messages. However, in Scala Actors it is possible for an actor to directly call a (public) method on a different actor instance. This breaks encapsulation and can lead to race conditions if the state of the target actor is accessed concurrently [11].
    * To prevent such encapsulation breaches, in Akka actors have a very limited interface, ActorRef, which basically only provides methods to send or forward messages to its actor. Akka has built-in checks to ensure that no direct reference to an instance of an Actor subclass is accessible after an actor is created. This mecha-nismworks surprisingly well in practice, although it can be circum-vented. [10]
    * Moreover, encapsulation can be broken by sending mutable objects in messages, giving both the sender and receiver access to the same mutable object.
    * Uniqueness types. Encapsulation can be ensured even in the pres-ence of mutable messages using a typing discipline such as unique-ness types [3]. The capability-based separate uniqueness type sys-tem [9] has been implemented as a prototype for Scala [5]. Using such a typing discipline means that all messages which do not have an ownership transfer semantics are required to be (deeply) copied to avoid introducing shared state. Basically, an ownership transfer requires the sender of a message to give up the permission to access the message after it has been sent.
    * The messages in the actor’s mailbox are processed in FIFO order. The Akka runtime guarantees that at most one message (per receiving actor) is pro-cessed at a time. Each message, say msg, is removed from the mail-box regardless of f. If f is defined for msg, f is applied to it. On the other hand, if f.isDefinedAt(msg) is false, msg is published as an “unhandled message” event to the system (wrapped in an object which additionally contains references to the sender and receiver).
* The Actor Runtime
    * As motivated in the introduction, the most important features of the actor runtime are (a) a lightweight execution environment, and (b) high performance. In the following we will outline how these features are realized in Akka and which ideas of Scala Actors stood the test of time.
    * Event-Based Actors
        * Scala Actors [7] introduced a new approach to decouple actors and threads by providing an event-based operation for receiving messages, called “react”. In this approach, an actor waiting for a message that it can process is not modeled by blocking a thread; instead, it is modeled by a closure which is set up to be scheduled for execution when a suitable message is received. At that point a task is created which executes this continuation closure, and submitted to a thread pool for (asynchronous) execution.
        * Akka has adopted this idea: the continuation of an actor waiting for a message is an instance of the same type. The main difference is that when using “react”, this continuation closure is provided per message to be received; in contrast, in Akka the continuation clo-sure is defined once, to be used for many (or all) messages. Addi-tionally, Akka provides methods to change the global continuation (become/unbecome). The main advantage of Akka’s approach is that it can be implemented much more efficiently on the JVM. In the absence of first-class continuations, implementing “react” re-quires the use of control-flow exceptions to unwind the call stack, so that each message is handled on a call stack which is basically empty. Throwing and catching a control exception for each mes-sage is additional overhead compared to Akka’s execution strategy.
    * Lightweight Execution Environment
        * A key realization of Scala Actors is the fact that for actor programs a workstealing thread pool with local task queues [12] scales much better than a thread pool with a global task queue. The main idea is as follows: when creating a task which executes the message handler to process a message, that task is submitted to the local task queue of the current worker thread. This avoids an important bottleneck of thread pools with a global task submission queue which can quickly become heavily contended. Like Scala Actors, Akka uses Lea’s fork/join pool (an evolu-tion of [12], released as part of JDK 7 [16]). In addition, and un-like Scala Actors, Akka uses non-blocking algorithms for inserting messages into actor mailboxes, and scheduling tasks for execution, which results in a substantial performance boost.
    * Integrating Threads and Actors
        * Integrating (JVM) threads and event-based actors is useful to enable powerful message-processing operations also for regular threads. This facilitates interoperability with existing libraries and frameworks and offers additional convenience, since it enables ac-tors to be more easily used from Scala’s interactive REPL (read-eval-print-loop). Besides Scala Actors, there are other approaches attempting an integration of threads and event-based actors [4].
    * Summary
        * Scala’s partial functions are well-suited to represent an actor’s Scala’s partial functions are well-suited to represent an actor’s continuation.
        * The overhead of unwinding the call stack through exceptions The overhead of unwinding the call stack through exceptions can be avoided by using a single, global message handler. Loss in flexibility can be recovered through constructs for replacing the global message handler.
        * A workstealing thread pool with local task queues is an ideal execution environment for event-based actors.
        * Threads and actors can be integrated in a robust way using first-Threads and actors can be integrated in a robust way using first- class actor mailboxes. On the other hand, this approach does not guarantee unique receivers.