# [@Dra17a] Microservices: yesterday, today, and tomorrow

  * mainstream languages for development of server-side applications, like Java, C/C++, and Python, provide abstractions to break down the complexity of programs into modules. However, these languages are designed for the creation of single executable artefacts, also called monoliths
  * modules of a monolith depend on said shared resources, they are not independently executable
  * Definition 1 (Monolith): A monolith is a software application whose modules cannot be executed independently.
    * Issues:
      * I1: large-size monoliths are difficult to maintain and evolve due to their complexity. Tracking down bugs requires long perusals through their code base
      * I2: monoliths also suffer from the "dependency hell" [55], in which adding or updating libraries results in inconsistent systems that do not compile/run or, worse, misbehave
      * I3: any change in one module of a monolith requires rebooting the whole application. For large- sized projects, restarting usually entails considerable downtimes, hindering development, test- ing, and the maintenance of the project
      * I4: deployment of monolithic applications is usually sub-optimal due to conflicting requirements on the constituent models’ resources: some can be memory-intensive, others computational- intensive, and others require ad-hoc components (e.g., SQL-basedrather than graph-based databases).When choosing a deployment environment, the developer must compromise with a one-size-fits-all configuration, which is either expensive or sub-optimal with respect to the individual modules
      * I5: monoliths limit scalability. The usual strategy for handling increments of inbound requests is to create new instances of the same application and to split the load among said instances. However, it could be the case that the increased traffic stresses only a subset of the modules, making the allocation of the new resources for the other components inconvenient
      * I6: monoliths also represent a technology lock-in for developers, whichare boundto use the same language and frameworks of the original application
  * Definition 2 (Microservice): Amicroservice is a cohesive, independent process interacting via messages
  * From a technical point of view,microservices should be independent components conceptually deployed in isolation and equipped with dedicated memory persistence tools (e.g., databases)
  * Definition 3 (Microservice Architecture): Amicroservice architecture is a distributed application where all its modules are microservices
  * The microservice architectural style does not favour or forbid any particular programming paradigm. It provides a guideline to partition the components of a distributed application into independent entities, each addressing one of its concerns. This means that a microservice, provided it offers its functionalities via message passing, can be internally implemented with any of the mainstream languages cited in the beginning of this section.
  * The principle of microservice architectures assists project managers and developers: it provides a guideline for the design and implementation of distributed applications. Following this principle, developers focus on the implementation and testing of a few, cohesive functionali-ties. This holds also for higher-level microservices, which are concerned with coordinating the functionalities of other microservices.
  * Solutions (S1 is a solution to I1):
    * S1: microservices implement a limited amount of functionalities, which makes their code base small and inherently limits the scope of a bug.Moreover, since microservices are independent, a developer can directly test and investigate their functionalities in isolation with respect to the rest of the system
    * S2: it is possible to plan gradual transitions to new versions of a microservice. The new version can be deployed “next” to the old one and the services that depend on the latter can be gradually modified to interact with the former. This fosters continuous integration [32] and greatly eases software maintenance
    * S3: as a consequence of the previous item, changing a module of a microservice architecture does not require a complete reboot of the whole system. The reboot regards only the microservices of that module. Since microservices are small in size, programmers can develop, test, and maintain services experiencing only very short re-deployment downtimes
    * S4: microservices naturally lend themselves to containerisation [56], and developers enjoy a high degree of freedom in the configuration of the deployment environment that best suits their needs (both in terms of costs and quality of service)
    * S5: scaling a microservice architecture does not imply a duplication of all its components and de- velopers can conveniently deploy/dispose instances of services with respect to their load
    * S6: the only constraint imposed on a network of interoperating microservices is the technol- ogy used to make them communicate (media, protocols, data encodings). Apart from that, microservices impose no additional lock-in and developers can freely choose the optimal re- sources (languages, frameworks, etc.) for the implementation of each microservice
  * In software engineering, architecture is concerned with providing a bridge between system functionality and requirements for quality attributes that the system has to meet.
  * This spike of interest contributed to an increase in the number of existing software architecture patterns (or generally called styles), so that some form of classification was then required. This problem was tackled in one of the most notable works in the field, the book “Software Ar- chitecture: Perspectives on an Emerging Discipline” by Garlan and Shaw
  * The classic by Gamma et al. [36] covers the design of object-oriented software and how to translate it into code presenting a collection of recurring solutions, called patterns.
  * Attention to separation of concerns has recently led to the emergence of the so-calledComponent- based software engineering (CBSE)
  * The last decade has seen a further shift towards the concept of service first [81] and the natural evolution to microservices afterwards
  * Service-Oriented Computing (SOC) is an emerging paradigm for distributed computing and e-business processing that finds its origin in object-oriented and component computing
  * In SOC, a program — called a service — offers functionalities to other components, accessible via message passing
  * Services decouple their interfaces (i.e. how other services access their functionalities) from their implementation
  * The benefits of service-orientation are:
    * Dynamism - New instances of the same service can be launched to split the load onthe system;
    * Modularity and reuse - Complex services are composed of simpler ones. The same services can be used by different systems;
    * Distributed development - By agreeing on the interfaces of the distributed system, distinct development teams can develop partitions of it in parallel;
    * Integration of heterogeneous and legacy systems - Services merely have to implement standard protocols to communicate
  * The idea of componentization used in service-orientation can be partially traced back to the object-oriented programming (OOP) literature; however, there are peculiar differences that led to virtually separate research paths and communities. As a matter of fact, SOC at the origin was - and still is - built on top of OOP languages, largely due to their broad diffusion in the early 2000s
  * However, the evolution of objects into services, and the relative comparisons, has to be treated carefully since the first focus on encapsulation and information is hidden in a shared-memory scenario, while the second is built on the idea of independent deployment and message-passing. It is therefore a paradigm shift, where both the paradigms share the common idea of componentization
  * The next step is adding the notion of business capability and therefore focusing analysis and design on it so that the overall system architecture is determined on this basis
  * The first “generation” of service-oriented architectures (SOA) defined daunting and nebulous requirements for services (e.g., discoverability and service contracts), and this hindered the adop- tion of the SOA model
  * Microservices are the second iteration on the concept of SOA and SOC
  * The aim is to strip away unnecessary levels of complexity in order to focus on the programming of simple services that effectively implement a single functionality
  * Like OO, the microservices paradigm needs ad-hoc tools to support developers and naturally leads to the emergence of specific design patterns
  * First and foremost, languages that embrace the service-oriented paradigm are needed (instead, for the most part, microservice architectures still use OO lan- guages like Java and Javascript or functional ones). The same holds for the other tools for development support like testing suites, (API) design tools, etc.
  * The microservices architecture appeared lately as a new paradigm for programming applications by means of the composition of small services, each running its own processes and communicating via light-weight mechanisms
  * This approach has been built on the concepts of SOA [51] brought from crossing-boundaries workflows to the application level and into the applications architec- tures, i.e. its Service-Oriented Architecture and Programming from the large to the small.
  * The term “microservices” was first introduced in 2011 at an architectural workshop as a way to describe the participants’ common ideas in software architecture patterns [33]
  * Microservices now are a new trend in software architecture, which emphasises the design and development of highly maintainable and scalable software
  * Microservices manage growing com- plexity by functionally decomposing large systems into a set of independent services
  * By making services completely independent in development and deployment, microservices emphasise loose coupling and high cohesion by taking modularity to the next level
  * It also comes with a bundle of problems that are inherited from distributed systems and from SOA, its predecessor. The Mi- croservices architecture still shows distinctive characteristics that blend into something unique and different from SOA itself:
    * Size - The size is comparatively small wrt. a typical service, supporting the belief that the architectural design of a system is highly dependent on the structural design of the organization producing it. Idiomatic use of the microservices architecture suggests that if a service is too large, it should be split into two or more services, thus preserving granularity and maintaining focus on providing only a single business capability. This brings benefits in terms of service maintainability and extendability
    * Bounded context - Related functionalities are combined into a single business capability, which is then implemented as a service.
    * Independency - Each service in microservice architecture is operationally independent from other services and the only form of communication between services is through their pub- lished interfaces
  * The key system characteristics for microservices are: 
    * Flexibility - A system is able to keep up with the ever-changing business environment and is able to support all modifications that is necessary for an organisation to stay competitive on the market
    * Modularity - A system is composed of isolated components where each component con- tributes to the overall system behaviour rather than having a single component that offers full functionality
    * Evolution - A system should stay maintainable while constantly evolving and addingnew features
  * bzgl Teams:
    * Back in 1968, Melvin Conway proposed that an organisation’s structure, or more specifically, its communication structure constrains a system’s design such that the resulting design is a copy of the organisation’s communication patterns [23]. The microservices approach is to organise cross- functional teams around services, which in turn are organised around business capabilities [33]. This approach is also known as “you build, you run it” principle, first introduced by Amazon CTOWerner Vogels [38]. According to this approach, teams are responsible for full support and development of a service throughout its lifecycle
  * Each microservice may represent a single business capability that is delivered and updated in- dependently and on its own schedule
  * Discovering a bug and or adding a minor improvement do not have any impact on other services and on their release schedule (of course, as long as back- wards compatibility is preserved and a service interface remains unchanged)
  * essentially microservices are meant to be used with continuous delivery and continuous integration, making each stage of delivery pipeline automatic. By using automated continuous delivery pipelines and modern container tools, it is possible to deploy an updated version of a service to production in a matter of seconds
  * microservicesmay cooperate in order to providemore complex and elaborate functionalities. There are two approaches to establish this cooperation – orchestration [54] and choreography [69]. Orchestration requires a conductor – a central service that will send requests to other services and oversee the process by receiving responses.Choreography, on the other hand, assumes no centralisation and uses events and publish/subscribemechanisms in order to establish collaboration. These two concepts are not new to microservices, but rather are inherited from the SOA world where languages such asWS-BPEL [66] andWS-CDL [82] have long represented the major references for orchestration and choreography respectively (with vivid discussions between the two communities of supporters).
  * Prior to the advent of microservices and at the beginning of the SOA’s hype in particular, orchestration was generally more popular and widely adopted, due to its simplicity of use and easier ways to manage complexity. However, it clearly leads to service coupling and uneven distribution of responsibilities, and therefore some services have a more centralising role than others.
  * Microservices’ culture of decentralisation and the high degrees of independence represents instead the natural application scenario for the use of choreography as a means of achieving collaboration. This approach has indeed recently seen a renewed interest in connection with the broader diffusion of microservices in what can be called the second wave of services
  * In order to better grasp microservices we need to understand the impact that this architecture has on some software quality attributes.
    * Availability
      * major concern in microservices as it directly affects the success of a system
      * Given services independence, the whole system availability can be estimated in terms of the availability of the individual services that compose the system
      * Even if a single service is not available to satisfy a request, the whole system may be compromised and experience di- rect consequences
    * Reliability
      * Given the distributed nature of the microservices architecture, particular attention should be paid to the reliability of message-passing mechanisms between services and to the reliability of the services themselves
      * Building the system out of small and simple components is also one of the rules introduced in [72], which states that in order to achieve higher reliability one must find a way to manage the complexities of a large system: 
      * building things out of simple components with clean interfaces is one way to achieve this
      * The greatest threat to microservices reliability lies in the domain of integration and therefore when talking about microservices reli- ability, one should also mention integration mechanisms
      * One example of this assumption being false is using a network as an integration mechanism and assuming network reliability is one of the first fallacies of distributed computing [73]. Therefore, in this aspect, **microservices reliability is inferior to the applications that use in-memory calls**
      * It should be noted that this downside is not unique only to microservices and can be found in any distributed system. When talking about messaging reliability, it is also **useful to remember that microservices put restrictions on integration mechanisms**. More specifically, microservices use integration mechanisms in a very straightforward way - by removing all functionality that is not related to the message delivering and focusing solely on reliable message delivery
    * Maintainability
      * By nature, the microservices architecture is loosely coupled, meaning that there is a small number of links between services and services themselves being independent. This greatly contributes to the maintainability of a system by minimising the costs of modifying ser- vices, fixing errors or adding new functionality
      * Despite all efforts to make a system as maintain- able as possible, it is always possible to spoil maintainability by writing obscure and counterintu- itive code [5]. 
      * As such, another aspect of microservices that can lead to increased maintainability is the above mentioned “you build it, you run it” principle, which leads to better understanding a given service, its business capabilities and roles [29,21].
    * Performance
      * The prominent factor that negatively impacts performance in the microservices architecture is communication over a network
      * The network latency is much greater than that of memory.
      * Therefore, in terms of communication, the performance will degrade compared to applications that use in-memory call mechanisms. Restrictions that microservices put on size also indirectly contribute to this factor. In more general architectures without size-related restrictions, the ratio of in-memory calls to the total number of calls is higher than in the microservices architecture, which results in less communication over the network.Thus, the exact amount of performance degradation will also depend on the system’s interconnectedness. As such, systems with well-bounded contexts will experience less degradation due to looser coupling and fewer messages sent.
      * In any distributed system security becomes a major concern. In this sense, microservices suffer from the same security vulnerabilities as SOA [6].
    * Security
      * As microservices use REST mechanism and XML with JSON as main data-interchange formats, particular attention should be paid to providing security of the data being transferred. This means adding additional overhead to the system in terms of additional encryption functionality. 
      * Microservices promote service reuse, and as such it is natural to assume that some systems will include third-party services. Therefore, an additional challenge is to provide authenticationmechanisms with third-party services and ensure that the sent data is stored securely. 
      * In summary, microservices’ security is impacted in a rather negative manner because one has to consider and implement additional security mechanisms to provide additional security functionality mentioned above
    * Testability
      * Since all components in a microservices architecture are independent, each compo- nent can be tested in isolation, which significantly improves component testability compared to monolithic architecture. It also allows to adjust the scope of testing based on the size of changes. This means that with microservices it is possible to isolate parts of the system that changed and parts that were affected by the change and to test them independently from the rest of the system
      * Integration testing, on the other hand, can become very tricky, especially when the system that is being tested is very large, and there are too many connections between components. It is possible to test each service individually, but anomalies can emerge from collaboration of a number of services
  * in [@Fra17] wird über dieses Paper bebhauptet:
    * one of the main results of the survey is that MSA is intrinsically related and has direct impact on specific quality properties at the system level, specifically: availability, reliability, maintainability, performance, security and testability qualities

* Tomorrow:
  * The greatest strength of microservices comes from pervasive distribution: even the internal components of software are autonomous services, leading to loosely coupled systems and the other benefits previously discussed. However, from this same aspect (distribution) also comes its greatest weakness: programming distributed systems is inherently harder than monoliths.Wenow have to think about new issues.
  * Dependability
    * There are many pitfalls that we need to keep in mind when programming with microservices. In particular, preventing programming errors is hard. Consequently, building dependable systems is challenging.
    * Interfaces Since microservices are autonomous, we are free to use the most appropriate technol-ogy for the development of each microservice. A disadvantage introduced by this practice is that different technologies typically have different means of specifying contracts for the composition of services (e.g., interfaces in Java, orWSDL documents inWeb Services [20]).
    * Unfortunately, the current answer is informal documentation.
    * As an attempt to fix this problem, there are tools for the formal specification of message types for data exchange, which one can use to define service interfaces independently of specific technologies. Then, these technology-agnostic specifications can be either compiled to language-specific interfaces — e.g., compiling an interface to a Java type — or used to check for well-typedness of messages (wrt. interfaces and independently of the transport protocol).
    * However, it is still unclear how to adapt tools to implement the mechanical checking (at compile or execution time) of messages for some widespread architectural styles for microservices, such as REST [30], where interfaces are constrained to a fixed set of operations and actions are expressed on dynamic resource paths.
    * A first attempt at bridging the world of technology-agnostic interfaces based on operations and REST is presented in [61], but checking for the correctness of the binding information between the two is still left as a manual task to the programmer.
    * Behavioural Specifications and Choreographies Having formally-defined interfaces in the form of an API is not enough to guarantee the compatibility of services.
    * This is because, during execution, services may engage in sessions during which they perform message exchanges in a precise order. If two services engage in a session and start performing incompatible I/O, this can lead to various problems. Examples include: a client sending a message on a stream that was previously closed; deadlocks, when two services expect a message from one another without sending anything; or, a client trying to access an operation that is offered by a server only after a successful distributed authentication protocol with a third-party is performed.
    * Behavioural types are types that can describe the behaviour of services and can be used to check that two (or more) services have compatible actions. Session types are a prime example of behavioural types [45,46].
    * Session types have been successfully applied to many contexts already, ranging from parallel to distributed computing.
    * However, no behavioural type theory is widely adopted in practice yet. This is mainly because behavioural types restrict the kind of behaviours that programmers can write for services, limiting their applicability. An important example of a feature with space for improvement is non-determinism. In many interesting protocols, like those for distributed agreement, execution is non-deterministic and depending on what happens at runtime, the participants have to react differently
    * Behavioural interfaces are a hot topic right now and will likely play an important role in the future of microservices. We envision that they will also be useful for the development of automatic testing frameworks that check the communication behaviour of services.
    * Choreographies are high-level descriptions of the communications that we want to happen in a system in contrast with the typical methodology of defining the behaviour of each service separately.
    * Choreographies are used in some models for behavioural interfaces, but they actually originate from efforts at the W3C of defining a language that describes the global behaviour of service systems [40].
    * In Chore-ographic Programming, the programmer uses choreographies to program service systems and then a compiler is used to automatically generate compliant implementations. This yields a correctness-by-construction methodology, guaranteeing important properties such as deadlock-freedom and lack of communication errors [15,17,63].
    * A recent line of work suggests that a positive answer can be found by connecting behavioural types and choreographies to well-known logical models. A prominent example is a Curry-Howard correspondence between session types and the process model of π-calculus, given in [14] (linear logical propositions correspond to session types, and communications to proof normalization in linear logic). This result has propelled many other results, among which: a logical reconstruc-tion of behavioural types in classical linear logic that supports parametric polymorphism [83]; type theories for integrating higher-order process models with functional computation [79]; ini-tial ideas for algorithms for extracting choreographies from separate service programs [18]; a logical characterisation of choreography-based behavioural types [19]; and, explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13].
    * We can then conclude that formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems. This starting point gives us solid footing for exploring the more focused disciplines that we will need in the future, addressing problems like the description of coordination patterns among services. We envision that these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics. It is still unclear, however, how exactly these disciplines can be extended to naturally capture the practical sce-narios that we encounter in microservices.We believe that empirically investigating microservice programming will be beneficial in finding precise research directions in this regard.
  * Trust and Security
    * *Greater Surface Attack Area*: In monolithic architectures, application processes communicate via internal data structures or internal communication (for instance, socket or RMI). The attack surface is usually also constrained to a single OS. On the contrary, the microservices paradigm is characterised by applications that are broken down into services that interact with each other through APIs exposed to the network. APIs are independent of machine architectures and even programming languages. As a result, they are exposed to more potential attacks than traditional subroutines or functionalities of a large application, which only interacted with other parts of the same application.Moreover, application internals (the microservices) have now become accessible from the external world. Rephrasing, this means that microservices can in principle send the attack surface of a given application through the roof.
    * Network Complexity
    * Trust
    * Heterogeneity
    * *Heterogeneity*: The microservices paradigm brings heterogeneity (of distributed systems) to itsmaximum expression. Indeed, a microservices-based system can be characterised by: a large num-ber of autonomous entities that are not necessarily known in advance (again, trust issue); a large number of different administrative security domains, creating competition amongst providers of different services; a large number of interactions across different domains (through APIs); no common security infrastructure (different “Trusted Computing Base); and last but not least, no global system to enforce rules.
* A specific arc has been given to the narrative, which necessarily emphasises some connections and some literature, and it is possibly too severe with other sources. For example, research contributions in the domain of the actor model [43] and software agents [65] have not been emphasised enough,
