# [@Kar09] Actor frameworks for the JVM platform: a comparative analysis

* The problem of programming scalable multicore processors has renewed interest in message-passing languages and frame-works. Such languages and frameworks are typically actor-oriented, implementing some variant of the standard Actor semantics.
* The shared memory model is unnatural for developers, leading to pro-grams that are error-prone and unscalable [2]
* Either to simplify the implementation, or to improve performance, many actor-oriented frameworks compromise one or more semantic property of the standard Actor model. For example, execution efficiency may be improved by unfair scheduling, or by implementing message-passing by passing references rather than copying messages.
* A programming frameworks can be analyzed along two di-mensions: the linguistic support the framework provides for programmers, and the efficiency of executing code written using the framework. In case of the actor frameworks, lin-guistic support comes in two forms. First, by supporting the properties of the Actor model, a framework can enable scal-able concurrency which facilitates compositional program-ming. Second, by providing programming abstractions that simplify expression of communication and synchronization between actors, a framework can allow programming idioms to be expressed in succinct notation.
* As mentioned earlier, many actor-oriented frameworks compromise one or more of the semantic properties of actors. We discuss the significance of each of these properties in order to understand the impact of compromising the property from the “ease of programming” point of view (§3). We then describe some common communication and synchronization abstractions in actor frameworks (§4). Finally, we analyze the implementation mechanisms in Actor frameworks and study how the cost of providing actor properties may be mitigated (§5). Our analysis suggests that while a na¨ıve implementation of actor properties may be highly inefficient, a sophisticated implementation of actor framework on JVM may provide efficient execution without compromising es-sential actor properties.
* [The standard Actor semantics provides encapsulation, fair scheduling, location transparency (location independent naming), locality of reference, and transparent migration. These properties enable compositional design and simplify reason-ing [27], and improve performance as applications and architectures scale [28].]{.important}
* For example, because actors commu-nicate using asynchronous messages, an actor does not hold any system resources while sending and receiving a mes-sage. This is in contrast to the shared memory model where threads occupy system resources such as a system stack and possibly other locks while waiting to obtain a lock.
* Thus [actors provide failure isolation while potentially improving performance]{.important}
* Asynchronous messaging is a key source of nondetermin-ism in Actor programs: the order in which messages are processed affects the behavior of an actor. In many applica-tions, application programmers want to prune some of the nondeterminism by restricting the possible orders in which messages are processed. Two commonly used abstractions that constrain the message order are request-reply messaging and local synchronization constraints (we will discuss these abstractions in §4).
* 4 main important semantic properties of actor model discussed:
    * Encapsulation:
        * Encapsulation is one of the core principles of object ori-ented programming. Preserving encapsulation boundaries between objects facilitates reasoning about safety proper-ties such as memory safety, data race freedom, safe mod-ification of object state. For example, Java is considered a memory-safe language because it hides memory pointers behind object references that provide safe access to objects (e.g. pointer arithmetic is not allowed). Memory-safety is important for preserving object semantics: it permits access to an object’s state only using well-defined interfaces. In the context of the Actor model of programming, there are two important requirements for encapsulation: state encapsula-tion and safe messaging.
        * State Encapsulation
            * An actor cannot directly (i.e., in its own stack) access the internal state of another actor. An actor may affect the state of another actor only by sending the second actor a message.
            * In Kilim, actors have memory references to other actors’ mailboxes. Again, this violates the desired encapsulation property. Actor implementations that enforce state encap-sulation do so using indirection. Because such indirection also provides location transparency, we discuss this sepa-rately later in this section.
        * Safe Messaging
            * There is no shared state between actors. Therefore, mes-sage passing should have call-by-value semantics.
            * In Scala Actors, Kilim, JavAct and Jetlang a message carries references to its contents on shared memory platforms, thus introducing shared state be-tween the actors.
            * An alternate proposal is to add a type system based on lin-ear types to enable safe, zero-copy messaging [18]. Such a type system is not part of currently available distributions. While such a type system would be useful, the current pro-posal may be too restrictive and complex to be widely used in practice.
    * Fair scheduling 
        * The Actor model assumes a notion of fairness: a message is eventually delivered to its destination actor, unless the destination actor is permanently “disabled” (in an infinite loop or trying to do an illegal operation).
        * Another notion of fairness states that no actor can be permanently starved.
        * Note that if an actor is never scheduled, pending messages directed to it cannot be delivered. The notion of guarantee of message delivery is formulated to also imply that no actor is permanently starved.
    * Location Transparency
        * In the Actor model, the actual location of an actor does not affect its name. Actors communicate by exchanging mes-sages; each actor has its own address space which could be completely different from that of others. The actors an actor knows could be on the same core, on the same CPU, or on a different node in a network. Location transparency provides an infrastructure for programmers so that they can program without worrying about the actual physical locations. 
        * Because one actor does not know the address space of an-other actor, a desirable consequence of location transparency is state encapsulation
        * Location transparent naming also fa-cilitates runtime migration of actors to different nodes or mobility. In turn, migration can enable runtime optimiza-tions for load-balancing and fault-tolerance.
    * Mobility
        * Mobility is defined as the ability of a computation to move across different nodes. 
        * Fuggetta et al. classify mobility as either strong or weak [30]. Strong mobil-ity is defined as the ability of a system to support movement of both code and execution state. Weak mobility,on the other hand, only allows movement of code (except for the initial state, which may be transferable).
        * In actor systems, weak mobility is useful when migrating an idle actor (i.e. an actor that is blocked due to an empty mailbox), while strong mobility means that it is meaningful for an actor to migrate while it is still processing a message.
        * Because actors provide modularity of control and encapsu-lation, mobility is quite natural to the Actor model.
        * Object-oriented languages may allow mobility at the level of objects but all thread stacks executing through the object need to be made aware of this migration. Moreover, when the stack frame requires access to an object on a remote node, the execution stack needs to be moved to the remote node to complete the execution of the frame and then migrated back to the original node [31].
        * At the system level, mobility is important for load balanc-ing, fault-tolerance and reconfiguration. Previous work has shown that mobility is essential for achieving scalable per-formance, especially for dynamic, irregular applications over sparse data structures [32].
        * Actor implementations such as Kilim [18] and Scala Ac-tors [17] provide by-reference semantics for message-passing, and when required, leave the responsibility of making a copyof message contents to the programmers. We argue that such an approach creates a double jeopardy for the programmers.To begin with, they have to think in a message-passing Ac-tor model, then they need to revisit their design in order to figure out which messages actually need to be copied, and finally, they need to ensure that the contents of these messages are actually copie
    * Actor implementations such as Kilim [18] and Scala Ac-tors [17] provide by-reference semantics for message-passing, and when required, leave the responsibility of making a copyof message contents to the programmers. We argue that such an approach creates a double jeopardy for the programmers. To begin with, they have to think in a message-passing Ac-tor model, then they need to revisit their design in order to figure out which messages actually need to be copied, and finally, they need to ensure that the contents of these messages are actually copied.
    * The temptation to ignore encapsulation is stronger in the case of an Actor framework as opposed to an Actor lan-guage. For example, in order to ensure that an actor is unable to access the state of another actor directly, a lan-guage may provide an abstraction such as a mailbox address or a channel but implement it using direct references in the compiled code for efficiency. This is similar to how Java im-plements object references to abstract away pointers. In an Actor-based framework, such abstractions (or indirections) have to be resolved at runtime, something that is relatively inefficient.
    * In frameworks where each actor is mapped to a JVM thread (also called the 1:1 architecture) the Actor implementation is as fair as the un-derlying virtual machine or operating system (on many plat-forms, a JVM thread maps to a native thread). In other cases, explicit scheduling by the frameworks may be required to support fair scheduling.
* Programming abstractions
    * Request-Reply Messaging Pattern
        * Request-reply messages express the most common pattern of messaging and synchronization in actor programs. In this pattern, the sender of a message blocks waiting for the reply to arrive before it can proceed [33, 34, 35]. This RPC-like pattern is sometimes also called synchronous messaging.
        * Without a high-level abstraction for request-reply messag-ing, the programmer has to explicitly encode the following steps in their program: an actor sends the request, waits for the reply to arrive and for each incoming message, the actor checks whether the message is a reply to the request or is another message that happened to arrive between the request and the reply.
    * Local Synchronization Constraints
        * Observe that each actor operates asynchronously and mes-sage passing is also subject to arbitrary communication de-lays; therefore, the order of messages processed by an actor is nondeterministic.
        * However, sometimes an actor needs to process messages in a specific order.
        * This requires that the order in which messages are processed is restricted. Synchronization con-straints simplify the task of programming such restrictions on the order in which messages are processed. For exam-ple, they can allow the programmer to declare that an actor postpone the processing of a message until it receives some sequence of messages, or until a condition on the actor’s state is satisfied.
        * 