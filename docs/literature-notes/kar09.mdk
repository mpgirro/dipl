# [@Kar09] Actor frameworks for the JVM platform: a comparative analysis

* The problem of programming scalable multicore processors has renewed interest in message-passing languages and frame-works. Such languages and frameworks are typically actor-oriented, implementing some variant of the standard Actor semantics.
* The shared memory model is unnatural for developers, leading to pro-grams that are error-prone and unscalable [2]
* Either to simplify the implementation, or to improve performance, many actor-oriented frameworks compromise one or more semantic property of the standard Actor model. For example, execution efficiency may be improved by unfair scheduling, or by implementing message-passing by passing references rather than copying messages.
* A programming frameworks can be analyzed along two di-mensions: the linguistic support the framework provides for programmers, and the efficiency of executing code written using the framework. In case of the actor frameworks, lin-guistic support comes in two forms. First, by supporting the properties of the Actor model, a framework can enable scal-able concurrency which facilitates compositional program-ming. Second, by providing programming abstractions that simplify expression of communication and synchronization between actors, a framework can allow programming idioms to be expressed in succinct notation.
* As mentioned earlier, many actor-oriented frameworks compromise one or more of the semantic properties of actors. We discuss the significance of each of these properties in order to understand the impact of compromising the property from the “ease of programming” point of view (§3). We then describe some common communication and synchronization abstractions in actor frameworks (§4). Finally, we analyze the implementation mechanisms in Actor frameworks and study how the cost of providing actor properties may be mitigated (§5). Our analysis suggests that while a na¨ıve implementation of actor properties may be highly inefficient, a sophisticated implementation of actor framework on JVM may provide efficient execution without compromising es-sential actor properties.
* [The standard Actor semantics provides encapsulation, fair scheduling, location transparency (location independent naming), locality of reference, and transparent migration. These properties enable compositional design and simplify reason-ing [27], and improve performance as applications and architectures scale [28].]{.important}
* For example, because actors commu-nicate using asynchronous messages, an actor does not hold any system resources while sending and receiving a mes-sage. This is in contrast to the shared memory model where threads occupy system resources such as a system stack and possibly other locks while waiting to obtain a lock.
* Thus [actors provide failure isolation while potentially improving performance]{.important}
* Asynchronous messaging is a key source of nondetermin-ism in Actor programs: the order in which messages are processed affects the behavior of an actor. In many applica-tions, application programmers want to prune some of the nondeterminism by restricting the possible orders in which messages are processed. Two commonly used abstractions that constrain the message order are request-reply messaging and local synchronization constraints (we will discuss these abstractions in §4).
* 4 main important semantic properties of actor model discussed:
    * Encapsulation:
        * Encapsulation is one of the core principles of object ori-ented programming. Preserving encapsulation boundaries between objects facilitates reasoning about safety proper-ties such as memory safety, data race freedom, safe mod-ification of object state. For example, Java is considered a memory-safe language because it hides memory pointers behind object references that provide safe access to objects (e.g. pointer arithmetic is not allowed). Memory-safety is important for preserving object semantics: it permits access to an object’s state only using well-defined interfaces. In the context of the Actor model of programming, there are two important requirements for encapsulation: state encapsula-tion and safe messaging.
        * State Encapsulation
            * An actor cannot directly (i.e., in its own stack) access the internal state of another actor. An actor may affect the state of another actor only by sending the second actor a message.
            * In Kilim, actors have memory references to other actors’ mailboxes. Again, this violates the desired encapsulation property. Actor implementations that enforce state encap-sulation do so using indirection. Because such indirection also provides location transparency, we discuss this sepa-rately later in this section.
        * Safe Messaging
            * There is no shared state between actors. Therefore, mes-sage passing should have call-by-value semantics.
            * In Scala Actors, Kilim, JavAct and Jetlang a message carries references to its contents on shared memory platforms, thus introducing shared state be-tween the actors.
            * An alternate proposal is to add a type system based on lin-ear types to enable safe, zero-copy messaging [18]. Such a type system is not part of currently available distributions. While such a type system would be useful, the current pro-posal may be too restrictive and complex to be widely used in practice.
    * Fair scheduling 
        * The Actor model assumes a notion of fairness: a message is eventually delivered to its destination actor, unless the destination actor is permanently “disabled” (in an infinite loop or trying to do an illegal operation).
        * Another notion of fairness states that no actor can be permanently starved.
        * Note that if an actor is never scheduled, pending messages directed to it cannot be delivered. The notion of guarantee of message delivery is formulated to also imply that no actor is permanently starved.
        * 