# [@Bri87] Inheritance and Synchronization in Concurrent OOP

  * Knowledge sharing (or inheritance) is a mechanism intensively used in OOP. Its basic idea is the reuse of object descriptions.
  * The second advantage is the introduction of classification among objects. It is used to hierarchically (or almost hierarchically) structuring knowledge, and it makes knowledge searching more efficient [Touretzky 861.
  * Delegation [Lieberman 86b] is another strategy we discuss as well. Delegation is discussed in the framework of the Actor model of computation (Hewitt 76,Lieberman 811.
  * (parallel) semantic network languages (e.g., NETL (Fahlman 791). [dieses quelle sollte ich mir zwecks literatur vermutlich anschauen]{.quelle}
  * Only the delegation scheme is flexible enough to be free from the shared memory assumption, so we will examine and criticize it in the distributed memory context. [MS haben inherent distributed memory]{.mind}
  * Flexibility versus Efficiency: This is one of the main tradeoffs in knowledge sharing.
  * Our main comment is that this inheritance scheme using hard-wired links is not suitable for distributed memory models. [hard-wired links = in-memory calls]{.mind}
  * The delegation scheme has been proposed in the Act-1 language [Lieberman 811. An object (called an actor in this computation model [Hewitt 761 where the class concept is absent) knows about another object called a prozy.
  * The delegation scheme enjoys the uniformity of the communication protocol: the delegation to the proxy of an object is performed by message passing, not by a system primitive through the hard-wired physical link (pointer).  [= in-memory call]{.mind}
  * Thus delegation can be fully designed at the user-language level and it can be locally customized by the user easily. This scheme is independent of the assumption of shared memory andis perfectly suitable for distributed (memory and computation) models. It also allows full dynamicity and modularity.
  * In examining this scheme, two issues, namely efficiency and synchronization, must be addressed. [Efficiency in MS hÃ¤ngt von Marshalling der Messages und dem network ab -> Performance von SOA]{.mind}
  * In the delegation scheme, variable consultation as well as method activation should be performed through message passing because both can be delegated to another object (the proxy).
  * Thus we first identify message passing with function call as in most of OOP extensions of Lisp. [msg passing == REST method call == function call]{.mind}
  * Each such variable-object owns the two methods that handle two kinds of messages: one to consult the variable (get), and the other to update it (set). [vgl. CRUD methoden bei REST]{.mind}
  * However in some concurrent models such as the Actor model, message passing is asynchronous and unidirectional. There is no implicit synchronization. AS a consequence, variable access is no more atomic and could be mishandled.
  * Message Ordering Issue [???]{.mind}
  * Fairness and Recursion: In an asynchronous message passing model, the messages sent to an object 0 are ordered (in a queue) following the ordering of their arrivals to 0. It is assumed that two messages cannot arrive at the same time.
  * We notice that the latest Actor model [Agha 851 relies on atomic objects. In this model, there is no side effect.
  * There is no delegation proposed in the Actor model of [Agha 85].
  * Bild des Delegation Schemas seite 38 [so ein bild sollte ich vll auch haben, da eine gateway ist immer delegation]{.mind}
