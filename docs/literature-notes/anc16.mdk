# [@Anc16] Behavioral Types in Programming Languages

* Modern society is increasingly dependent on large-scale software sys-tems that are distributed, collaborative and communication-centered.
* Correctness and reliability of such systems depend on compatibility between components and services that are newly developed or may al-ready exist.
* Current software de-velopment technology is not well suited to producing these large-scale systems, because of the lack of high-level structuring abstractions for complex communication behavior.
* A recent trend in current research is to use behavioral type the-ory as the basis for new foundations, programming languages, and software development methods for communication-intensive distributed systems.
* Behavioral type theory encompasses concepts such as inter-faces, communication protocols, contracts, and choreography. Roughly speaking, a behavioral type describes a software entity, such as an ob-ject, a communication channel, or a Web Service, in terms of the se-quences of operations that allow for a correct interaction among the involved entities.
* Chapter 2 is devoted to the integration of behavioral types into Object-Oriented languages. Object-oriented languages are rele-vant for their widespread adoption in the current development of software, for the wealth and popularity of tools that are avail-able, and because objects nicely fit a distribution model to which behavioral types can be applied naturally. The integration can be achieved in different ways: either by enriching the languages with constructs (in particular, sessions) that call for a correspond-ing extension at the type level, or by amalgamating sessions and objects to the point that the objects themselves become the enti-ties for which a behavioral description is required, for example to specify the order in which methods must/can be invoked.
* The WSDL and UDDI standards are technologies currently en- abling the description of Web Service interfaces and the creation of Web Service repositories. Chapter 7 explores the potential of behavioral types, intended as abstract descriptions of Web Ser-vice behaviors, as natural generalizations of WSDL interfaces to realize sophisticated forms discovering, composition, and orches-tration of Web Services.
* Chapter 8 illustrates the design-by-contract methodology for the development of possibly distributed, communicating systems. Ac-cording to this methodology, behavioral types are used for de-scribing, from a vantage point of view, the topology of the com-munication network, the communications that are supposed to occur, and in which order. Such global specifications serve multi-ple purposes: they are a valuable form of abstract specification of the overall behavior of a distributed system; they can be projected for describing the local behavior of the network participants to allow the modular type checking of complex systems; they enable the generation of monitors to verify, at runtime, that the partici-pants of a heterogeneous distributed system behave as expected, even if only some or none of them have been type checked against their supposed or claimed behavior.
* Session types can be seen as a special case of typestate, in which the ordered operations are the sends and receives on communication channels.
* Delegation. Delegation, namely the act of communicating a channel as a message, works as in standard session types and it is modeled through the constructs:
* Service Oriented Computing (SOC) is based on services, intended as autonomous and heterogeneous components that can be published and discovered via standard interface languages and publish/discovery pro-tocols.Web Services is the most prominent service-oriented technology: Web Services publish their interface expressed in the Web Service De-scription Language (WSDL), they are discovered through the UDDI protocol, and they are invoked using SOAP.
* Services are often developed as combination of other existing services, by using so-called orchestration languages, such as WS-BPEL [OASIS, 2007]: executable languages which perform activities by means of local computations combined with invocations to other services.
* Session type theories make it possible to extract such behavioral descriptions (in the form of types) from the actual service code (type inference) or to check that service code conforms to a given behavioral description (type checking).
* In turn, type checking crucially relies on the notion of duality (correspondence of invokes and receives), guaran-teeing service compliance in an interaction involving multiple services, and on a sub-typing relation between session types (see compliance test-ing preorder [Bravetti and Zavattaro, 2007, 2008b]). The sub-typing relation is defined to be the coarsest one that preserves the desired termination properties, so to be as permissive as possible when typing code (we will discuss these aspects with examples in §7.3). This form of sub-typing, called semantic sub-typing, is more permissive compared to the syntactic ones commonly adopted in session types, and plays a key role in addressing the problem of service discovery.
* In order to be able to perform this kind of checks, it is necessary for services to expose in their interface also the description of their be-havior (obtained, as we mentioned, by applying the type system on the service code).
* In general, a service interface description language used in directory services like UDDI can expose both static and dynamic information about Web Services. The former deals with the signature (name and type of the parameters) of the invocable operations; the latter deals with the correct order of invocation of the provided operations in order to correctly complete a session of interaction.
* Concrete orchestrations are presented to show how services can be programmed in terms of invoca-tions of other services and as a starting point to then extract abstract orchestrations, used to express and reason about interaction with other services.
* Jolie (Java Orchestration Lan- guage Interpreter Engine) is a general-purpose programming language based on the Service-Oriented Computing paradigm [Montesi et al., 2014, development team]. It was originally presented by Montesi et al. [2007] as an orchestration language forWeb Services alternative to the standard language WS-BPEL, with the advantage of being based on formal models from the start and consequently enabling abstract rea- soning on the behavior of Jolie programs; this is in contrast with WS- BPEL, whose reference implementations are based on informal specifi- cations
* Other advantages of Jolie are that it is equipped with a friendly syntax similar to C/Java and that it integrates behavioral primitives for orchestration with architectural primitives for programming the or- ganization of a network
* the result of this integration is that these architectural primitives can be used to set up, e.g., load balancers, proxies, or monitors that can be reused independently of the orchestration behavior of the services that they compose, or even in settings where different communication technologies or protocols are used (e.g., HTTP instead of SOAP).
* Jolie is also equipped with a rather sophis-ticated fault handling mechanism [Guidi et al., 2009]: compensation handlers can be dynamically updated taking under consideration infor-mation available only at runtime.
* Moreover, if a fault occurs during a bidirectional request-response interaction, the correct interruption and compensation of both communicating processes is guaranteed.
* Despite Jolie was initially designed as a language for Web Services orchestra-tion, during its development the language has evolved to a general-purpose tool that can be applied to different scenarios, from multi-core computing to web applications [Montesi, 2013a, Montesi et al., 2014].
* As we already mentioned, using a process algebraic approach, it is possible to define how to extract the externally observable behavior (behavioral contract/session type) from the actual executable behavior of a service [Boreale and Bravetti, 2011].
* is then enough informative to enable analysis of certain properties of the actual service (when interacting with other services), including stuck freedom [Fournet et al., 2004], deadlock freedom [Castagna et al., 2009], termination (under fairness assumptions) [Bravetti and Zavattaro, 2007, 2008a,b]. In particular, such analysis is often carried out by resorting to more low-level se-mantic descriptions of service behaviors (essentially labeled transition systems) called behavioral contracts.
* One of the most important as-pects of the service contract technology is considered to be *correctness of composition*  or, more simply, compliance: given any set of services, it should be possible to prove that their composition is correct (accord-ing to the above mentioned termination properties) knowing only their contracts, i.e. in the absence of complete knowledge about the internal details of the services behavior.
* We exemplify abstract process representation by providing the de-scription of the Customer-Agency use case with abstract WS-BPEL. In order to avoid writing obscure and verbose XML code we adopt the more intuitive notation of BPELscript.
* A recent line of research advocates the development of safe distributed systems with Choreographic Programming, a programming paradigm in which developers write system implementations using choreogra-phies.
*  Implementation challenges:
  * The first challenge is supporting session communications. In gen-eral, a session may have many participating processes, which need to be able to communicate with each other at runtime.
  * Since Chor uses a service-oriented lan-guage such as Jolie, the public channel is actually implemented as an always-available service that can be used by processes in the network to create new sessions [Montesi, 2013b] (each public channel has its own service implementation).
  * The second challenge is the integration with existing paradigms. Language models for choreographies typically focus on minimality and give only a high-level description of how the code compiled from a choreography should behave. Typically, these models are inspired to the π-calculus [Sangiorgi and Walker, 2001] in order to facilitate their formal investigation.
  * However, all communications in service-oriented comput-ing happen over operations and thus this change is a necessary addition when compiled code is to be executed in a service-oriented architecture.
  * Different modifications would be needed for other paradigms; in gen-eral, they should be made with particular care, since any changes to the original theoretical models of choreographic programming risk breaking their safety properties (e.g., deadlock-freedom).
  * the third challenge is about reliability. To the best of our knowledge, all implemented choreography languages work on the as-sumption that communications will succeed (the network is “perfect”) and execution units never fail.
  * Therefore, the safety properties of chore-ographies are guaranteed only if these assumptions are not broken at runtime.