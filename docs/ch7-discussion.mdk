
# Discussion {#ch-discussion}



~ Epigraph { caption: "Theodor W. Adorno"}
Weil das was ist sich ändern kann, ist das, was ist, nicht alles.
~


In this thesis, we evaluated the programming with actors and microservices to conceive concurrent computation. As a bottom line, we now want to argue for the application of each of them and outline towards their integration as well as our concluding vision regarding future development. 

~ todo
...
~


## The Case for Actors


The actor model provides constructs for task units which allow us to focus mostly on concerns related to each unit's responsibilities. The actor runtime centralizes many additional concerns not directly related to the scope of responsibility of each individual actor. One central entity manages cross cutting concerns per system node. Many concerns are abstracted away completely. Examples are the uniform interface for local and remote communication and the discovery capability transparently hidden within the actor addresses. Other concerns, like fault tolerance, are provided with sane default behaviors and influenceable through well-defined, coherent interfaces (e.g.\ `SupervisionStrategy`{language:scala}). Theoretical limitations, like asynchronous message passing, can be loosened up by introducing additional primitives. However, additional mechanism like future-based computation and synchronous-styled `ask` pattern run at the risk of introducing potential model semantics violations. Akka, due to its library conception, specifically suffers from risks provided by the JVM ecosystem and Java/Scala language semantics. However, if used with care, we deem the actor construct very expressive once a certain learning curve regarding a reactive programming style has been mastered.

Actor are conceptually very slim computational units. Erlang is best known for its lightweight actor variant and Akka through its behavior closures too is able to provide a very efficient Actor implementation compared to Scala's original variant. 

Essentially, it is our observation that each actor system aims to keep their units more lightweighted than a program thread, such that the actors are being scheduled on a thread-pool if they are required. This allows to greatly improve performance by preventing idle Actors to consume computational resources. The runtime of Orleans even holds its Actors merely virtual, such that they are instantiated just on demand.   

However, the Actor runtime makes prediction about the performance difficult. Akka's dispatchers provide besides a fixed thread-pool size also a dynamic pool size configuration. This will elastically scale the amount of threads based on the current demand. Consequently, long turns, e.g.\ due to blocking operations, will lead to an increase of threads in the pool. Yet Java thread efficiency is related to the number of cores available on the host machine, such that a high thread-to-core ratio will have a negative impact on the overall performance. This has been experienced with Echo's web crawlers, which rely on blocking HTTP calls to retrieve remote content. Thus, deployment configuration specific to each individual node host machine, with a focus on the different options regarding thread-pool management, is recommendable in general.

Therefore, we observe that the portability of Actor system nodes is relative to the machine configurations of the old and new deployment locations, at least regarding a predictable performance behavior. Additionally, the ecosystem is also limited by the Actor system technology. As all involved tasks have to be interoperable, thus conceived through the Actor system variant, all components are limited by it. As Akka is a JVM based library, with dedicated binding for Java and Scala, portability is still good, as the JVM is available for most potential host machines. Other Actor system face essentially the same limitations. Erlang was specifically designed for Actor utilization, thus they are deeply founded in the languages concepts. Its Actors are thus at most interoperable with other BEAM-based constructs, e.g.\ such constructed using the *Elixir* language.


## The Case for Microservices


Microservice architectures also facilitate constructs aiming for a clear and easy separation of concerns into dedicated computation units. However, as all these services are individual processes spawned from distinct program images, each Microservice in general has to pay attention to many more aspects than its primary responsibility. 

Most importantly, as services cannot facilitate in-memory calls like monolithic system architectures do, their connectivity becomes an essential concern essential. All communication channel technologies required to achieve a desired interaction, but also resilience mechanisms down to more trivial matters like logging concerns have to be supported individually. Regarding communication, this can be a benefit. The paradigm allows to explicitly define communication ports, whereas Actors have to comply to the abstraction provided by the system.

However, due to the increased complexity in any case, we deem the programming model of Microservices therefore less expressive from a programmer's perspective than Actors in general. Technology stacks like Spring Cloud can greatly help in easing the effort through provided linguistic abstractions for IoC executed solutions but cannot erase the fact that each service has to merit these concerns separately, resulting in an increased accumulated performance demand. Additionally, such technologies tend to produce rather large application skeletons (despite being "micro"), as their offered linguistic constructs, e.g.\ for easing the utilization of various communication mechanisms, come at the price of requiring many additional dependencies and considerable runtime overhead of realizing the declarative programming style allowing to write sparse custom code focused on the respective service's concern

As a result, each Microservice's (custom written) code base compared to its Actor counterpart is to be assumed much larger in general, but not significantly in Echo due to IoC through Spring. However, the compiled executables of each service is merely slightly below the compiled size of the whole monolithic Actor executable. This is also reflected in the startup time. While an arbitrary OS process can be started rather quickly in general, considerable time (two-digit amount of seconds) is required before any of Echo's microservices is up and ready to be used, depending on the current load of the executing host.

Microservice generally affect the efficiency of an architecture in a positive way compared to traditional monoliths, as has been one of the primary goals for the paradigms conception. Individual replication and scaling of each service is possible on as many diverse hosts as desired, provided that a service is deployable there (technology compatibility). However, each service process always stresses the nodes performance capacity, even if it is unused.

This also affects the services portability. As services are independently replaceable, they can also be adapted to support new target ecosystems. Their basic process abstractions does not demand any specifics regarding parallelization, as it is merely optionally achievable, if multiple CPUs per host are available. Network topology is a bigger concern in principle, as such is not automatically abstractable. Dedicated discovery services are additionally required.

General performance is well predictable, when the number of service instances can be fixed, as is with Echo. No elasticity mechanism is supported, thus the required operating system processes is foreseeable. Of course, third party components, e.g.\ RabbitMQ for asynchronous messaging, may spawn additional processes themselves. However, such are also expected to do this in a foreseeable way. In general, we deem it less likely to create new services as flexible as is done with Actors, for process creation comes with a relatively high price, e.g.\ due to the memory address space.  


<!--
## Empirical Indications

~ todo
Hier kurz beschreiben welche Erkenntnisse es aus empirischer Forschung und Überlegungen es gibt, welche den einen oder anderen Ansatz befürworten. Zentral wird hier die Erkenntnis, dass sich der Microservice Ansatz dazu eignet ein bestehendes System zu refaktorisieren, um somit die concurrency (und scalability, extensibility, etc.) zu verbebssern. Hingegen denke ich nicht das ein bestehendes (monolytisches) System in eine Actor Architectur refaktorisiert werden kann. Umgekehrt gibt es Daten die belegen, dass MSA Projekte eine hohe Erfolgsaussicht haben, wenn sie refaktorisieren, aber eine hohe Schweiterwahrscheinlichkeit für Projekte "from the ground" nahelegen, dass das Concept initial zu überfordernd ist. Actors hingegen eignen sich sehr gut für eine schnelle Entwicklung von Anfang an, da das Actor system bereits sehr viele Concerns bedient  
~


~LitNote
  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refActorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (-> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
* [@Has16] "Microservices and Their Design Trade-offs: A Self-Adaptive Roadmap"
  * "Among these problems is finalising the level of granularity of a microservice too early. “Splitting too soon can make things very difficult to reason about. It will likely happen that you (the software architect) will learn in the process. [1]."
  * [@Tai17] "Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation"
* [@Dra17c] "Microservices: Migration of a Mission Critical System"
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@Fow14]
* MS können gut sein wenn man einen bestehenden Monolithem refaktorisiert und aufspaltet (Literatur benötigt!)
* literature on project success, where it says that projects transforming monolith into MSA have a high success chance, while projects starting initially with an MSA tend way more to fail
~
-->

