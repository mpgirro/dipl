
## Flow-Driven Programming

* Flow-Driven: Programming processes communicating with each other over predefined channels. (www1)

* wikipedia flow-based (FBP): https://en.wikipedia.org/wiki/Flow-based_programming
    * hier gibt es ein Kapitel "Comparison with other paradigms and methodologies", welches vergleicht mit:
        * Jackson Structured Programming (JSP) and Jackson System Development (JSD)
        * Applicative programming
        * Linda
        * Object-oriented programming
    * "Flow-based programming defines applications using the metaphor of a "data factory". It views an application not as a single, sequential process, which starts at a point in time, and then does one thing at a time until it is finished, but as a network of asynchronous processes communicating by means of streams of structured data chunks, called "information packets" (IPs)."
    * "In this view, the focus is on the application data and the transformations applied to it to produce the desired outputs. The network is defined externally to the processes, as a list of connections which is interpreted by a piece of software, usually called the "scheduler"."
    * "Generally the concepts were referred to within IBM as "Data Flow", but this term was felt to be too general, and eventually the name flow-based programming was adopted."
    * "FBP has much in common with the Linda[2] language in that it is, in Gelernter and Carriero's terminology, a "coordination language":[3] it is essentially language-independent. Indeed, given a scheduler written in a sufficiently low-level language, components written in different languages can be linked together in a single network. FBP thus lends itself to the concept of domain-specific languages or "mini-languages"." (wp-FBP)
    * "FBP exhibits "data coupling", described in the article on coupling as the loosest type of coupling between components. [The concept of loose coupling is in turn related to that of service-oriented architectures, and FBP fits a number of the criteria for such an architecture]{color:red}, albeit at a more fine-grained level than most examples of this architecture." (wp-FBP)
    * "FBP promotes high-level, functional style of specifications that simplify reasoning about system behavior. An example of this is the distributed data flow model for constructively specifying and analyzing the semantics of distributed multi-party protocols." (wp-FBP)
    * zum Vergleich mit Linda: "Many of the concepts in FBP seem to have been discovered independently in different systems over the years. Linda, mentioned above, is one such. The difference between the two techniques is illustrated by the Linda "school of piranhas" load balancing technique - in FBP, this requires an extra "load balancer" component which routes requests to the component in a list which has the smallest number of IPs waiting to be processed. Clearly FBP and Linda are closely related, and one could easily be used to simulate the other."
    * zum Vergleich mit OOP:
        * An object in OOP can be described as a semi-autonomous unit comprising both information and behaviour. [wichtig!]{.mind}
        * Objects communicate by means of "method calls", which are essentially subroutine calls, done indirectly via the class to which the receiving object belongs. The object's internal data can only be accessed by means of method calls, so this is a form of information hiding or "encapsulation".
        * Encapsulation, however, predates OOP - David Parnas wrote one of the seminal articles on it in the early 70s[19] - and is a basic concept in computing. (*D. Parnas, On the criteria to be used in decomposing systems into modules, Communications of the ACM, Vol. 5, No. 12, Dec. 1972, pp. 1053-8*)
        * Encapsulation is the very essence of an FBP component, which may be thought of as a black box, performing some conversion of its input data into its output data
        * In FBP, part of the specification of a component is the data formats and stream structures that it can accept, and those it will generate [also die REST Schnitstelle]{.mind}. This constitutes a form of design by contract. In addition, the data in an IP can only be accessed directly by the currently owning process. Encapsulation can also be implemented at the network level, by having outer processes protect inner ones.
        * A paper by C. Ellis and S. Gibbs distinguishes between active objects and passive objects.[20] Passive objects comprise information and behaviour, as stated above, but they cannot determine the timing of this behaviour. Active objects on the other hand can do this. In their article Ellis and Gibbs state that active objects have much more potential for the development of maintainable systems than do passive objects. An FBP application can be viewed as a combination of these two types of object, where FBP processes would correspond to active objects, while IPs would correspond to passive objects. (*C. Ellis and S. Gibbs, Active Objects: Realities and Possibilities, in Object-Oriented Concepts, Databases, and Applications, eds. W. Kim and F.H. Lochovsky, ACM Press, Addison-Wesley, 1989*)

* siehe quelle 2: "N. Carriero and D. Gelernter, Linda in Context, Communications of the ACM, Vol. 32, No. 4, April 1989"
* siehe quelle 3: "N. Carriero and D. Gelernter, Coordination Languages and their Significance, Communications of the ACM, Vol. 35, No. 2, February 1992"

## Logic and Constraint Programming

* Logic (Rule-based): Programming by specifying a set of facts and rules. An engine infers the answers to questions.
* Constraint: Programming by specifying a set of constraints. An engine finds the values that meet the constraints.

* Characteristics of Logic P. (www2)
  * Discipline and idea: Automatic proofs within artificial intelligence
  * Based on axioms, inference rules, and queries.
  * Program execution becomes a systematic search in a set of facts, making use of a set of inference rules

## Role-oriented Programming

* ist eine Sichtweise von OOP "by separation of concerns" (lt. der Einteilung auf Wikiedia)
* siehe https://en.wikipedia.org/wiki/Role-oriented_programming
    * "Role-oriented programming is a form of computer programming aimed at expressing things in terms that are analogous to human conceptual understanding of the World. This should make programs easier to understand and maintain"
    * "The roles typically share features, e.g., the intrinsic properties of being a person. This sharing of properties is often handled by the delegation mechanism."
    * "Roles allow objects to evolve over time, they enable independent and concurrently existing views (interfaces) of the object, explicating the different contexts of the object, and separating concerns."
    * "Roles in programming languages enable objects to have changing interfaces, as we see it in real life - things change over time, are used differently in different contexts, etc." [passt jedenfalls nicht auf MS]{.mind}
    * hat kapitel zu "Authors of role literature"
    * Programming languages with explicit support for roles:
        * JavaScript Delegation - Functions as Roles (Traits and Mixins): https://en.wikipedia.org/wiki/JavaScript#Delegative
        * SCala ROLes Language: https://github.com/max-leuthaeuser/SCROLL
        * und weitere unbekannte

# Other Concepts

## Delegation

### Delegation in JS

* siehe https://en.wikipedia.org/wiki/JavaScript#Delegative
    * JS supports implicit and explicit Delegation
    * implicite: function-based implementations of Role patterns like Traits or Mixins [deswegen Zusammenhang zum alten Konzept des Role-based Programming]{.mind}
    * explicit: Object composition and inheritence

## Distributed data flow

* siehe https://en.wikipedia.org/wiki/Distributed_data_flow
    * "Distributed data flows serve a purpose analogous to variables or method parameters in programming languages such as Java, in that they can represent state that is stored or communicated by a layer of software"
    * "Unlike variables or parameters, which represent a unit of state that resides in a single location, distributed flows are dynamic and distributed: they simultaneously appear in multiple locations within the network at the same time. As such, distributed flows are a more natural way of modeling the semantics and inner workings of certain classes of distributed systems. In particular, the distributed data flow abstraction has been used as a convenient way of expressing the high-level logical relationships between parts of distributed protocols"
    * A distributed data flow satisfies the following informal properties:
        + **Asynchronous, non-blocking, and one-way**: Each event represents a single instance of a non-blocking, one-way, asynchronous method invocation or other form of explicit or implicit message passing between two layers or software components
        + **Homogeneous, unidirectional, and uniform**: All events in the distributed flow serve the same functional and logical purpose, and are related to one another; generally, we require that they represent method calls or message exchanges between instances of the same functional layers, or instances of the same components, but perhaps on different nodes within a computer network. Furthermore, all events must flow in the same direction (i.e., one type of a layer or component always produces, and the other always consumes the events), and carry the same type of a payload. [vll etwas bzgl horizontaler Scalierung? Aber eher wenig brauchbar f√ºr MS]{.mind} 
        + **Concurrent, continuous, and distributed**: The flow usually includes all events that flow between the two layers of software, simultaneously at different locations, and over a finite or infinite period of time. Thus, in general, events in a distributed flow are distributed both in space (they occur at different nodes) and in time (they occur at different times) [sollte genau MS sein!]{.mind}
    * In addition to the above, flows can have a number of additional properties:
        + **Consistency**. A distributed flow is said to be consistent if events with the same version always have the same value, even if they occur at different locations. Consistent flows typically represent various sorts of global decisions made by the protocol or application.
        + **Monotonicity**. A distributed flow is said to be weakly monotonic if for any pair of events e_1 and e_2 that occur at the same location, if e_1 has a smaller version than e_2, then e_1 must carry a smaller value than e_2. A distributed flow is said to be strongly monotonic (or simply monotonic) if this is true even for pairs of events e_1 and e_2 that occur at different locations. Strongly monotonic flows are always consistent. They typically represent various sorts of irreversible decisions. Weakly monotonic flows may or may not be consistent.