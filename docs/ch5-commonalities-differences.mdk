
Commonalities and Differences 
=========================================================

<!-- of Actors and Microservices -->

~ Epigraph { caption: "Pamela Zave"}
The purpose of software engineering is to control complexity, not to create it.
~

~LitNote
* Diskussion: MS behandeln ebenfalls die 3 "foundational issues" die laut [@Agh85b] concurrency modelle lösen sollten
* Weiters zitiert [@Agh85b]: "It is reasonable to expect that large-scale parallel systems will be composed of independently developed and maintained modules. Such systems will be open-ended and continually undergoing change (Hewitt and de Jong 85)."
    * und "Actor languages are intended to provide linguistic support for such open systems" -> dh Actor werden als sprachfeature für das verwendet werden, was MS im prinzip sind.
~

In chapter [#ch-actor-model] and [#ch-microservice-paradigm], we introduced Actors and Microservices separately and focused on their individual concepts. Alert readers will already have spotted conceptual similarities between both approaches. This chapter brings both ideas together and discusses the similarities their respective concepts share, and the differences that distinguish them. 

## Isolation {#sec-commonalities-isolation}

### Shared and Mutable State

One fundamental characteristic of both Actors and Microservices is their notion of shared state. Summarizing chapter [#ch-actor-model], the Actor model encapsulates state exclusively within an Actor. Therefore it can only be accessed and modified by the Actor itself. Additionally, Actors provide single-threaded semantic while processing messages, i.e. only one message is processed at a time. This eliminates any need for synchronization, for a message has exclusive access to the Actors current state, and thus is free of low-level data races. The Actors state is fully isolated.

On the other hand, such reasoning cannot be done for Microservices in general. The paradigm states nothing about how state has to be handled internally. Depending on the programming paradigm used to implement the service, i.e. multiple objects could have access the same memory location. Furthermore, these state accesses could be executed concurrently, e.g. as a reaction to multiple invocations of the services interface within a short timespan. Microservices do not ensure any kind of single-threaded semantic. This requires synchronization to internal service state.

However, the Microservice paradigm dictates that shared memory *between* services is to be avoided, as are all kinds of shared resources in general. For every service runs within its own system process, avoiding shared memory implies no direct intersection between service process boundries. Typical communication channels satisfying the requirements given in section [#sec-ms-communication] also prevent any form of reference sharing to joined mutable data [citation needed? oder kann ich das als zusammenfassung von schon erklärtem verkaufen?]{.mind}. Such channels tend to provide some sort of message passing (which can also be in a synchronous fashion, e.g. REST), which is designed to transfer information between the different memory spaces of distinct processes [@Les09].

Actors are generally faced with more challenges when it comes to truely ensuring state separation, because the components can exist within the same process boundries. This theoretically allows access to the same memory locations [citation needed, irgendwo bei der OS literatur wird schon was stehen]{.mind}. Depending on the programming paradigm used for implementing the Actors, exposing shared state to others might be very simple and not apparent to the programmer. Especially the imperative style leans on mutable state, thus suffering from the need of applying extra care to preserve the model semantic. The functional paradigm tends to avoid such problems inherently, for behaviour is modeled as a function, and this function is the only mutable state, which may be modified exclusively by the Actor itself. If the Actor model is integrated into the programming language itself, such problems can be avoided by designing appropriate restrictions enforced by the language directly. However, library based Actor implementations in general cannot ensure full isolation by themselves [@Kos16]. Section [#sec-ensuring-actor-isolation] will discuss in detail the specific demands such libraries can pose to the programmer for a given Actor library.

### Information Hiding

~LitNote
* "promise behaviour via API/protocol" --> design by contract
* [@Kan12] 4 four important semantic properties of our
extension based on Actor systems: encapsulation, fairness, location transparency and mobility [16 --> Actor Frameworks for the JVM Platform: A Comparative Analysis]
* [@Bon17] "This simple fact has huge implications. It means that data can be strongly consistent only within each service but never between serv‐ ices, for which we need to rely on eventual consistency and abandon transactional semantics"
* [@Bon17] "Isolation makes it easier to scale each service, as well as allowing them to be monitored, debugged, and tested independently"
* [@Kni96] "Encapsulation is probably the only feature that is generally agreed to be an indispensable (sine qua non) characteristic of object-oriented languages. Some researchers even consider encapsulation to be the fundamental object-oriented concept and that all other object-oriented mechanisms and approaches exploit encapsulation to various ends ([9]). There also seems to be general agreement on the fact that encapsulation and sharing are incompatible: sharing tends to violate encapsulation while encapsulation tends to prevent sharing."
    * hier muss ich auch noch was zu visibility schreiben, weil ich im actor-solution kapitel schreibe das es hier schon vorgekommen ist!
* MS sind per definition, insofern sie auf shared memory konzepte verzichten, immer perfekt isoliert, durch das OS. Bei Actor müssen die verschiedenen "notions of state" beachtet werden, um eine strong state notion einzuhalten, also preserve local state and transient state, wie es in [@Kni96] beschrieben ist
* [@Kar09] Encapsulation = State Encpasulation + Safe Messaging
    * nach meiner auffassung ist das genau isolation; das sollte ich vll hier anbringen
~

~delete
Both Actor and Microservice semantics rely on a strict separation of component states. Any form of shared resource is to be prevented. This is generally easy for Microservice components due to the fact that the services are within their separate system processes, and as long as they do not arrange a shared memory section there is no direct intersection between service process boundries. Typical communication channels satisfying the requirements given in section [#sec-ms-communication] also prevent any form of reference sharing to joined mutable data [citation needed? oder kann ich das als zusammenfassung von schon erklärtem verkaufen?]{.mind}.

Actors are generally faced with more challenges in ensuring state separation, because the components can exist within the same process boundries, and have therefore access to the same memory locations [citation needed, irgendwo bei der OS literatur wird schon was stehen]{.mind}. Depending on the programming language paradigm used for implementing the Actors, exposing shared state to others might be very simple and not apparent to the user.
~

As Snyder points out, *Object Oriented Programming* (OOP) usually offers mechanisms to restrict the access to an objects state by requiring clients to issue requests for the services an object offers in order to get access to or modify the objects state [@Sny93]. These "services" - not to be confused with the *service* concept we will introduce with Microservices - are what Meyer calls well-defined interfaces, or simply routines (methods), and considers to be a necessity for encapsulation [@Mey97]. 

However, though OOP offers methods to encapsulate state within objects and prevent access to it, it r it usually remains quite easy for an object to *exposing* its state to others [citation sowas von needed]{.mind}. This can become especially problematic for object-oriented Actor implementations if the system has no way of checking or ensuring message immutability by itself. Section [#sec-ensuring-actor-isolation] describes in detail the challenges this poses for a specific Actor system.


--- 

The components of any Microservice Architecture are stricly distinct processes. The paradigm states that those refrain from allocating any kind of shared memory. Thus allown suffices that state is stricly isolated within each service. Therefore the paradigm neither does nor needs to dictate any instructions on how state has to be handled internally within each service. The memory boundries of processes are safeguarded on the operating system level [citation needed]{.mind}.

### Persistance

~LitNote
Polyglot Persistance, Event/Command Sourcing (??? brauche ich das? - vll für mehrere parallele Stores, wenn einer nachträglich online geht)
~


## Communication and Data Coupling

~LitNote
* Sync vs Async, Immutable Messages
* Point to Point, Publish/Subscribe, 
* [@Kan12]: "Safe Messaging: Message passing should have call- by-value semantics to avoid sharing state between Actors"
* [@Hoh06] "Programming Without a Call Stack--Event-driven Architectures" (bzgl async communication)
* [@Agh99] describes RPC abstraction on top of actors; and broadcast/multicast/one-to-one-out-of-many communication styles for actors
* [@Kar09] bzgl messaging: "An alternate proposal is to add a type system based on lin- ear types to enable safe, zero-copy messaging [18]. Such a type system is not part of currently available distributions"
* "loose coupling" [@Sal16]
~

## Separation of Concerns

~LitNote
* [@Weg90] "Concepts and Paradigms of Object-Oriented Programming"
    * "Splitting a large task into components is a time-honored method of managing complexity, variously referred to as "divide and conquer" and "separation of concerns"."
~

## Cohesion and Coupling

## Object-oriented Perspective

~Todo
Die Unterkapitel in Actor-Ch und Microservice-Ch rausnehmen, und stattdessen hier gemeinsam diskutieren. Data abstraction (Encapsulation and Information Hiding), Design by Contract, SOLID design principles, Substitution and Behaviour 
~

~LitNote
* [@Agh99] "Actors are similar to sequential objects in that they encapsulate data and procedures"
* [Dra17a] "Microservices: yesterday, today, and tomorrow"
    * "However, the evolution of objects into services, and the relative comparisons, has to be treated carefully since the first focus on encapsulation and information is hidden in a shared-memory scenario, while the second is built on the idea of independent deployment and message-passing."
    * "It is therefore a paradigm shift, where both the paradigms share the common idea of componentization."
~

### Single Responsibility

~LitNote
* Unix philosophy
* [@Bon16]
* [@Bon17] "This idea was later brought into the Object-Oriented Programming community by Robert C. Martin and named the Single Responsibil‐ ity Principle2 (SRP), which states that a class or component should “have only one reason to change"
* "functional separation" [@Sal16]
~

### Design by Contract

~Todo
Both have a clear interface (Actors via the messages they accept, MS via their REST interface or the AMQP msg they consume). However, both also have problems in terms of checking this. Actors only check at runtime if they "unserstand" the current message. Microservices lack tools to ensure composability at compile time (das will ich vll fürs MS-solution kapitel aufheben)
~

~Todo
Actors und Microservices können zur Compile-time idR nicht garantieren, dass die Nachrichten die sie bekommen werden auch verstehen können. Active Objects (und zu einem gewissen Grad auch Distr. Obj.) sind reizvoll weil sie diesen Markel beheben.
~

~LitNote
* Hier kann ich an Franz zitieren!
* Punt: "In Components We Trust – Programming Language Support for Weak Protection"
* Punt: "Coordination of CORBA Ob jects with Process Types"
* Punt: "Practical Expressive Types for Active Objects"
~

## Autonomy

~LitNote
* [@Bon17] 
    * "Isolation is a prerequisite for autonomy. Only when services are iso‐ lated can they be fully autonomous and make decisions independ‐ ently, act independently, and cooperate and coordinate with others to solve problems"
    * "Working with autonomous services opens up flexibility around ser‐ vice orchestration, workflow management, and collaborative behav‐ ior, as well as scalability, availability, and runtime management, at the cost of putting more thought into well-defined and composable APIs"
~



## Component Concurrency

### Threads and Processes

~LitNote
* [@Hal09] Scala Actors: Unifying thread-based and event-based programming
    * "There is an impedance mismatch between message-passing concurrency and virtual machines, such as the JVM. VMs usually map their threads to heavyweight OS processes. Without a lightweight process abstraction, users are often forced to write parts of concurrent applications in an event-driven style which obscures control flow, and increases the burden on the programmer"
    * --> Event Driven Programming Style (also so Callbacks in Java zB) sind Mist, 
* [@Agh91] "Actors as Processes: The representation that we are implementing models actors as light-weight processes and requires the presence of a kernel run-time system on each node."
* Hier kann ich die gesamte Erlang Literatur einbauen, denn die nennen ihre lightweight constructs ja auch *process*
* [@Kar09] beschreibt location transparency bei actors
* [@Swa14] "Towards composable concurrency abstractions"
    * "We classify concurrencymodels that use structured communication in terms of messages, instead of relying on shared memory, as communicating threads."
    * "Often, each thread has only private memory, ensuring that all communication is done via messages."
~

### Internal and external Concurrency

~LitNote
* Hier möchte ich einen gewissen Gedanken diskutieren, aber habe keine gute Idee in welchem Kontext (Überschrift bzw einordnung in einem anderen Kapitel) ich das am besten tun sollte. Somit ist es erstmals hier.
* Ich sollte anmerken, dass beide Ansätze per se einmal gar nicht zwingend für Concurrency sind/sein müssen (Actors sind auch ein allg. Programming model). Nur ihre **semantik** führt automatisch zu einer nebenläufigen, ggf auch automatisch zu einer parallelen, Ausführung 
~

~Mind
Die sache das actors an sich keine concurrency kennen sollte ich besser im Actor Model kapitel schon beschreiben, wenn es darum geht es mit anderen concurrency modellen zu mixen. Hier stattdessen noch darauf hinweisen, dass MS intern alles machen können was man will, und Actors dafür eben diese kombinationsmöglchkeiten anwenden müssen um halbwegs verwendbar zu sein - wenngleich man hier darauf achten muss, dass die kombinierten Modelle nicht die actor semantik gefähren
~

In chapter [#ch-actor-model] we discussed the Actor model explicitely as a *concurrency model*. Yet this claim is worth debating. In the basic semantic of an Actor we discussed, there is no notion of concurrency at all. It is a strictly linear component, that follows a clear, non-concurrent execution schema [hier sollte ich etwas zitieren, und den pseudocode von jemand anderen heranziehen]{.mind}:

```
WHILE TRUE:
    GET next message from mailbox
    process message
    repeat 
```

Nothing wihin an Actor expects a concurrent access to its state [obacht! da hab ich wo gelesen das es schon andere concurrency auch geben kann, in irgendeinem paper]{.mind}. As was discussed in detail, whilest Actor model properties are not violated, state is encapsulated within an Actor exclusively, and modifications happen only as a reaction to received messages, the processing of which is guaranteed to be atomic. An Actor itself is a non-concurrent entity *internally*. Therefore, the Actor model is also refered to, and was initially conceived as, simply a programming model [citation needed?]{.mind}, an approach to writing software components. The most basic case is a single Actor. It only knows about itself, therefore can only receive messages from itself, process them, and send messages to itself. The semantic of this behaviour is a simple loop, where no state information leaves the scope of the Actor. It results in a simple, single threaded program. 

The title of chapter [#ch-actor-model] features a famouse quote of Carl Hewitt: "*One actor is no actor. Actors come in systems*". The overall idea of - and driving reason to use - the Actor programming model is to have more than one Actor in place. The models semantic allows to send messages freely between Actors within a system. While each Actor itself is a non-concurrent entity, this exchange of (immutable) messages semantically allows Actors to be executed in a concurrent fashion by the system. 

Actors by themselfs are not concurrent, but their semantic allows them to be executed *externally* in a concurrent manner, within a system. If the Actor semantic is preserved at all time - how this can be guaranteed is up to the actual Actor system implementation - then an Actor does not have to have any awareness of any concurrent processing at all [citation needed]{.mind}. Of course, this does not mean that Actor systems are free from the concurrent problems that are introduced by any form of indeterminism, respectivly by message passing. [hier könnte ich noch irgendwas brauchbares aus dem Paper das die Concurrency Bugs behandelt zum besten geben]{.mind}   

A microservice on the other hand has the basic abstraction of a process. Any system process for itself is, from an external point of view, not especially concurrent [??]{.mind}. But within a system, these processes form, just like Actors, concurrent nature due to the semantic properties of proccesses. 

Through the basic process semantic [hier sollte ich diese semantik aufzählen: isolation, messages, fair scheduling + quelle]{.mind}, just like with Actors, any system of processes lead to a concurrent system. The services external concurrency is always either on the operating system level or the network level (or both). Yet their notion of internal concurrency is divergent from that of an Actor. Though it also receives messages of some kind via its public API, and reacts to them, the flexibility in the design of microservices allows to create services that react to multiple messages concurrently. They can have internal notion of concurrent processing. This allows a service to make a synchronouse call (and blocking wait for an answer within the routines code), without blocking as a whole. A microservice therefore can behave as a concurrently accessible resource within the system. The drawback of this degree of freedom is the set of issues any concurrent resource access inherently has. A basic example is locking. When an Actor processes a message, it is guaranteed to have unqiue access to its internal state, therefore must no handle any locking and may savely assume its state as up to date. When a microservice accesses any kind of internal resource (state), this resource might currently be locked by an internal transaction mechanism, granting read access, but not guaranteeing that the state is actually up to date. [dirty read? irgendwas allgemeines zu locking und read zitieren]{.mind} 

Programming with microservices does not, unlike Actors, free one from the many hassles of internal component concurrency problems per se. Depending on the model used, the pains of threads, locks, transactions, coroutines, etc. are still to be dealt with. But the services size - based on its scope of responsibility - is limiting the complexity of the services internal concurrency considerations relative to the overall systems [citation needed? hab ich da eine? ist ja eigentlich mein eigener beitrag]{.mind}. 

~Todo
Andere Concurrency Abstractions können schon interne concurrency in Actors einbringen (formal bricht das halt die Actor Semantik!). Verweis darauf das wir Futures bereits angedeutet haben, und das nachher gleich ein beispiel bringt.
~

### Fair scheduling

~LitNote
* [@Kan12]: Actor model defines fair scheduling that a message is eventually delivered to destination Actor except for its permanent “disability”, and no Actor can be permanently starved
* MS werden vom OS garantiert das der process drankommt, aber die verteilung von messages (zB bei MQ broker) ist sache des verwendeten kanals, daher keine globale garantie
* [@Kar09] beschreibt fair scheduling bei actors
~


## Distribution

~LitNote
* Actors und MS ist es an sich egal ob sie lokal oder verteilt ausgeführt werden, beide können dies gut abstrahieren
* [@Reh13] defines requirements on distributed Actors:
    * R1: Distributability: Non-distributed applications must be easy to be migrated to clustered set-ups.
    * R2: API-uniformity: The distribution API must be similar for intra-node as well as inter-node applications
    * R3: Compatibility: An application that works locally on one node should also work distributed in a cluster.
    * R4: Flexibility: Beside Actors that have access to specific hardware, the developer should freely decide which Actor runs on which node of the cluster.
    * R5: Configurability: Simple configuration of the clustering subsystem and the distribution layout.
* [@Kan15] (über distributed/cloud Actors)
    * "There (Actor) distinctive features make it suitable to support distributed memory parallelism, and it has been widely used in many industrial languages such as Erlang[2], Scala [3], Akka [4]"
    * "However, most related works focus on multi-core environment. Neither inter-parallelism or task parallelism can be easy applied in dynamic distributed environment, because Actors distributing over cluster may be- have indeterminable interrelationship, such as uncertain com- munication, dependency and failure"
* [@Kan12] (über distributed Actors)
    * Computers connect by network, which makes the environment distributed, disparate, mutable and unreliable
    * According to classifications of parallel programming models in process interaction, mechanisms of which make the parallel processes able to communication with each other, the most common forms of interaction are shared memory, message passing, and implicit [4]
    * In Actor model, location transparency means the actual location of an Actor does not affect its name. That is to say, if one Actor knows another, they can communicate only by names instead of specific address --> kommunikating via ActorRef instead of pointer; bei MS muss das zB für REST extra ein Service Discovery übernehmen, der dies abstrahiert; 
    * Obviously, State encapsulation is a desirable consequence of location transparency. Location transparency facilitates runtime migration of our computing elements to different nodes, which brings good mobility. Moreover, migration enables runtime optimizations for load-balance and fault-tolerance
* [@Fel90] "Language and System Support for Concurrent Programming"
    * beschreibt das Message passing ganz prinzipiell nicht davon abhängig ist, wo die beteiligten componenten sind (im gegensatz zu shared variables/memory)
~

Communication via message passing has one fundamental property: no memory is shared between the communicating components. Though we will see later, that this semantic can actually be violated due to implementational hazards used for passing messages, conceptionally it does not require that the components are within the same memory space. Thus, it does not matter weither they run on the same processor, different cores or even the same host machine [@Fel90]. In short, message passing allows for distribution. 

The Actor model intrinsically builds upon message passing to share state information between Actors. Additionally, Actors are well isolted from each other. Based on these properties, Agha recast the initial notion of Actors in the light of distributed computation [citation? die diss? oder dieses 43 year paper auch noch]{.mind}. 

~Todo
Microservices können auch message passing, aber auch synchrone. Die location transparency kommt entweder von der MOM, oder eben von einem lookup service für die REST endpoints.
~  

### Location Transparency

### Components per Execution Environment

~LitNote
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * Beschreibt ch4.4 "Actors Per Execution Environment"
    * Classic Actors and Processes (Erlang) sind auf dem "level of abstraction" wie objekte in OO, oder abstract data types in FP
    * Active Objects und Communicating Event-Loops sind auf dem level of abstraction von "components" in OO, oder modulen in FP  
~

### Mobility

~LitNote
* Laut jones Bonér folgt mobility aus location transparency
* [@Kan12] (über distributed erlang Actors)
    * Mobility is defined as the ability of processes moving from one node to another. It is classified into two types. Strong Mobility means supporting movement of both code and execution state, while weak mobility only allows movement of code
    * At the system level, mobility is important for load balancing, fault-tolerance and reconfiguration. 
    * [25] = [@Pan94] has shown that mobility is essential for achieving scalable performance.
* [@Fug98] "Understanding Code Mobility"
* [@Agh14] "Actors Programming for the Mobile Cloud"
* [@Car97] "Designing Distributed Applications with Mobile Code Paradigms"
* [@Kar09] beschreibt mobility bei actors
* [@Sal16] "The Evolution of Distributed Systems Towards Microservices Architecture"
    * Keywords: Distributed Systems; Microservices; Mobile Agents; Service Oriented Architecture
    * ad *Mobile Agent*: "An agent is composed of three parts which also take place in travelling: Data, State and Code."
~

### Distributed Object Abstraction {#sec-distributed-objects}

~LitNote
* Lokation transparency ist super und alles, wenn es richtig gemacht wird. die Verteilten Objekte machen das auch, und führen zu massiven Probleme --> hier hab ich diesen einen Artikel "A Note on Distributed Computing" oder so. An dieser stelle sollte ich diskutieren wieso Actors und MS diese Probleme nicht haben, bzw was zu beachten ist um es zu vermeiden
* [@Siv99] "The specification of distributed objects: liveness and locality"
* [@Wal96] "A Note on Distributed Computing"
~

In object-oriented programming, the overall programs state is partitioned into disjoint sets, each chunk belonging to a distinct object. As Werner pointed out, from a logical point of view, the state is as such distributed [@Weg90]. However, distributed programming has different emphasis of concerns than OOP does. And yet, both architecture styles can be integrated such that objects support pyhsical distribution. The result is called *Distributed Objects* (DO). 

The concept that has been popularized in the 1990s [citation needed]{.mind}. Objects do not have to exists within the same program boundary, but can be distributed across multiple programs and therefore host machines. For every DO a proxy object is created, which wrappes the method calls to the actual distributed object, which then does not necessarily has to be located within the same program boundry [quelle für den absatz, wiederholung von "program boundry"]{.mind}. This allows for location transparent method calls. Examples of such DOs are Java RMI or CORBA [quelle, richtig?]{.mind}. They seem to share many conceptual similarities that we are discussing here. On the one hand, the design goals of Microservices seem to aim towards the single-purpose, minimal and slim skeleton that distributed objects have compared to full-fletched monolithic applications. On the other hand, their distributed nature inherently leads toward the possibilities of transparent concurrent/parallel execution, like Actors or active objects do. 

However, the abstraction the distributed object concept provides was found to be be "leaky" due to conceptual problem [citation needed - note on distributed computing]{.mind}. The transparent method call they offer is hiding to much context do be able to handle the many faults that come with any distributed programming setup. A simple example: 

~LitNote
* [@Ber14]
    * "In a traditional RPC model (such as Java RMI, CORBA, or WCF) the programmer needs to explicitly bind the virtual reference to the service, usually via an external registry or location service."
~

~Todo
hier das beispiel mit dem 1000 methoden aufrufe für die simme von .getSize()
~

We already discussed the analogies of Actors and microservices to the notion of objects. Now, with these similarities and the fact that Actors (or active objects) and microservices each provide mechanisms for location transparent messaging too, we should discuss weither they qualify as distributed objects themselves. This would mean they face the same problems as DO too. 

#### Actors as Distributed Objects

~Todo
Nein. Hier gilt im Prinzip das selbe Argument wie bei MS. Einen anderen Actor anzusprechen ist eine dedizierte Operation, die sich vom Aufruft der API eines "normalen" Objekts unterscheidet (am Ende läuft es auf den konkreten Syntax der Actor Implementierung hinaus, aber es sollte jedenfalls so sein - Akka macht es einem aus genau diesem Grund sehr sehr schwer einen Actor direkt mittels `new` zu instanzieren - was besonders bei der Java API auffällt - und verlangt stattdessen, dass man via einer `ActorRef` kommuniziert, welche ausschließlich das Senden von Actor-Nachrichten erlaubt, und alle direkten Methodenaufrufe verhindert).
Bzgl des Simmenbeispiels würde man entweder innerhalb des Actors alle Objekte durchiterieren, oder eine Nachricht an einen anderen Actor schicken, dass dieser über alle Objekte die dort vorhanden sind iteriert. Idealerweise sollte dieser dann auch gleich mit dem Ergebnis weiterarbeiten können, sodass der aktuelle Actor nicht auf eine Antwort warten muss. Somit ist auch bei Actors der lokale und der nebenläufige (ggf verteilte) Aufruft nicht zu verwechseln
~

#### Microservices as Distributed Objects

~Todo
Nein. Beim Konzept der vert. Obj wird der Ort des Obj versteckt. Dh bei einem Methodenaufruft ist mir nicht bekannt, ob das Obj lokal oder remote liegt. Da vert. Obj die selbe API wie "normale" (= lokale Obj) haben, habe ich keinerlei Hemmungen low-level API methoden anzuwenden. Bsp: Aufsummieren einer Eigenschaft "Size" über alle meine Objekte einer Kategorie. Bei lokalen Objekte iteriere ich über alle Objekte, rufe o.getSize() auf und summiere die Werte auf. Bei vert. Obj ist mir nicht bekannt ob die Objekte lokal oder remote liegen, deshalb sieht hier die Summenbildung entsprechend gleich aus. Bei angenommen 1000 Objekten führt dies im Worst Case zu 1000 separaten RPCs.
Bei Microservices würde man eine derartige API vermeiden, denn hier ist immer klar, welche Aufrufe lokal (innerhalb des MS) sind, und welche einen RPC (also den aufruf eines anderen MS) bewirken, da man aktiv zB die REST-Schnittstellen ansprechen muss. Um beim Summenbeispiel zu bleiben würde man hier entweder über lokale Elemente iterieren, oder einen ensprechenden Endpoint einrichten, welcher die Summe über alle Elemente eines entfernten MS anfordert.

=> MS != distr. Obj.
~

#### Active Objects as Distributed Objects

We have discussed now weither Actors or Microservices qualify as abstractions of the Distributed Object concept, and came to the conclusion that the risk of being misused as DO's is moderate for both. However, section [#sec-active-objects] introduced another variant of the Actor model that is worth discussing here, for it explicitely capitalises an object-oriented abstraction, just like DO's do: Active Objects.

Section [#sec-active-objects] gave an example of the concurrent semantic the API of Active Objects provide. The method call is separated from the message execution. We demonstrated the behaviour in case of method interfaces with and without return values. Building on the previous example, we define this program (note that this switches to Scala syntax here for further demonstrations, which is no problem due to Scala's interoperability with Java):

``` {language:scala}
1  val fs: List[Fnord] = ... // list of 100 references
2  var sum = 0
3  for (f <- fs) {
4      sum += f.get()
5  }
6  println(sum)
```

The program iterates over all elements and makes a blocking call to retrieve the value. This has two fundamental issues:

1. The programs will block sequentially 100 times, once for each element.
2. If some, or in the worst case all, of the elements are not within the local scope of the program but transparently distributed, this will cause up to 100 separate remote procedure calls with as many opportunities of any fault a synchronous network call can result in.

The first issue is a result of bad coding practice. The second issue is based on the same leaky abstraction distributed objects suffer from. The `get()` method could be called without the programmer being aware that it actually offers a result value and therefore will block (though with this particular method name and usage it hopefully is unlikely). Additionally it is not clear weither the dispatched method will execute locally or remotely. The abstraction simply hides too much.

Both issues could be fixed by using the *future type* of message passing for Active Objects that has been introduced. This is done by changing the declaration of `get()` to return a `Future[Int]`{language:scala} instead. In functional languages, handling Futures can be done elegantly if they offer monadic behaviour that fits natural with functional programming styles, e.g. in Scala:

``` {language:scala}
1  Future.sequence(fs.map(_.get))
2    .map(_.sum) 
3    .onComplete {
4       case Success(res) => println(res)
5       case Failure(_)   => println("error")
6    }
```

This is an example where it is efficient to combine other abstractions of concurrent computation that integrate well with the Actor semantic. Line 1 transforms `fs:List[Fnord]`{language:scala} first into a `List[Future[Int]]`{language:scala} and then into a `Future[List[Int]]`{language:scala}. The Actor system's dispatcher can now wait until this `Future`{language:scala} completes without having to block the underlying thread. The call stack starting in line 2 is only applied upon completion, finalizing the intended result. 

We see, Active Objects have the potential to be used in the same problematic way Distributed Objects are. The methods interface defines the method dispatch semantics. If not used with utmost care, method calls can easily become simple remote procedure calls in a transparent way. This can cause bottlenecks, deadlocks, timeouts due to stacked network latencies, [...]{.mind} and having negative impacts on scalability, [...]{.mind} 

~Todo
Possibly. Worin unterscheiden sich aktive Objekte von Actors? In der API. Es wird der Methodenaufruf von der Methodenausführung getrennt. Mit anderen Worten, in der Zeile nachdem man `actObj.doSomething()` aufgerufen hat, ist diese Methode noch nicht umbedingt garantiert fertig (ja es kann gut sein, dass sie noch nicht einmal angefangen wurde auszuführen). Aktive Objekte (jedenfalls in Akka) sind intern via Actors implementiert. Während man einem Aktor jede beliebige Nachricht schicken kann, und dieser **zur Laufzeit** unterscheidet ob er diese versteht/bearbeiten kann, ist bei einem aktiven Objekt durch die Ansprache des aktiven Objekts über eine Methode via das Typsystem **zur Compiletime** sichergestellt, dass der interne Actor die Nachricht auch verarbeiten kann (daher werden aktive Objekte in Akka auch "Typed Actors" genannt). Asynchron ist ein aufruf nur, wenn die Methoden alle `void` als Rückgabewert haben. Ansonsten handelt es sich beim Methodenaufrufs eines Typed Actors um einen synchronen Aufruft (!), und im Falle einer Ortsverteilung der beiden Akteure auch wieder nur um einen RPC. Daher können aktive Objekte in die selben Probleme laufen, wie sie vert. Objekte haben. 
~

## Governance and Independent Deployment

(Partially) Centralized with Actor systems, decentralized with MS (aber was ist mit cloud management frameworks)

## Scalability

### Load balancing

* Server and Client Side LB

### Elasticity

~LitNote
* Done in MSA which Cloud Management Framework, all components must support dynamic adding and removing of components (requires Service Discovery, etc.)
* Actors can easily be created and kill by messages. A system must support elastic mechanism itself. question is from which components is this command issues? also a management framework? or is the system this detected by itself. in case of cluster, are new Actors spawned on random node, or some metric for node with most free resources?
    * interessesting are cases for Stores, because DB/Index resources need to be present, and how are they being brought up to current state --> Event sourcing
* IDEE: Ich werde elasticity nur theoretisch unterstützen. 
    * die MS sind an sich darauf vorbereitet, müsste nur eine neue abstraktionsebene hinzugefügt werden (management framework) die das regelt; event sourcing subsystem für stores fehlt
    * Actors impl unterstützt prinzipiell beliebig viele componenten, nur müsste der mechanismus selbst gebaut werden; event sourcing subsystem für das neuaufbauen von directory/index fehlt
* [@Akm90] vergleicht Actors mit CSP und erläutert, dass Actors "permits one to increase the distributivity of computation as it evolves" (= elastic) weil sie neue Actors erzeugen können. CSPs hingegen können nur andere Processe "aktiviere", und sind nicht natürlich elastisch. Wenn ich argumentieren kann das MS auf CSP logik basieren, dann ist das ein gutes Argument. Die Folge ist ja nämlich, dass MSA eine zsätzliche Abstraktion brauchen für Elastizität, nämlich Cloud Management Frameworks.
    * [@Agh85b] beschreibt, das CSP die dynamisch Actor Erzeugungs Semantik "violated", weil die "interconnetion topology of processes" statisch ist --> MS müssen das via Service Discovery Abstraction lösen (wo ebene die Discovery Services statisch sind und weiterleiten)
* "elastic scaling"
~

## Fault tolerance

~LitNote
* "failure isolation"
* [@Myt17] "Handling partial failures in distributed reactive programming"
~

### Resilience

~LitNote
"ability to heal from failure" - break free from strong coupling of synchron comm.; circuit breakers

Location transparency, elasticity = "move around in isolation"
~

### Availability

~LitNote
* Actors, siehe: [@Agh85b]
~

## Extensibility and Technology Heterogeneity {#sec-technological-heterogeneity}

Extensibility:

~LitNote
* Actors, siehe: [@Agh85b]
* gradual/separate replacement of MS
* substitution and subtyping für Actors
~

Technology Heterogeneity:

~LitNote
* [@Sub11] demonstrates how Akka can be used not only by Scala/Java binding, but other JVM languages too
* [@New15] Newmann calls it "Technology Heterogeneity"
~

## Actor Model and Process Calculi

~LitNote
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi>
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
* Wenn ich es im MS kapitel schaffe mir was zu Process Calculi zu überlegen, gibt es genügend 
* [@Kos16] vergleich Asynchronous Sequential Processes (ASP) mit Active Objects, nur mit gröberer Granularität
* [@Kos16] beschreibt das die sog. "Communicating Event-Loop Actor Model" ähnlichkeiten zu Asynchronous Sequential Processes (ASP) hat
* [@Car04] "Asynchronous and Deterministic Objects"
    * describes implementing ASP as Active Objects
    * "Relying on the active object concept, the ASP model is rather closed to, and was somehow inspired by, the notion of actors [2, 3]."
* [@Agh97] "A foundation for actor computation"
    * beschreibt ebenfalls den zusammenhang von Actors und Process Algebras (pi-calc., ect.), auch in einem historischen context.
* Punt: "Type Specications with Processes" <http://www.complang.tuwien.ac.at/franz/papers/Punt95a>
    * Hier beschreibt er wie er Process Types (was Typen von Processen eines Process Calculus sind) verwendet um das Actor model abzubilden. Dürfte sich sehr eignen!
* Punt. forschte daran wie man mit Prozess Typen (und somit in Process Calculi?) modellieren kann, das zu gewissen Zeiten nur gewissen Nachrichten akzeptiert werden. Das "become" Primitive von Actors kann ebenfalls dazu verwendet werden, um die Menge der Messages die ein Actor gerade verarbeiten kann zu verändern (also die Typen für die eben ein Verhalten definiert ist). Dh das ist im Prinzip das selbe
    * beste quelle? Punt: "State information in statically checked interfaces"    
    * Punt: "Types that reflect changes of object usability"                                             
~

In section [#sec-ms-process-calculus] we've motivated why the Microservice paradigm in general has relations to the theories of process calculi. This is especially interresting, for the Actor model and the Process calculi share a long history. Both theoretical approaches have been conceived around the same time in the 1970s. Since then, over time both... [citation]{.mind}

It is important to realize that there is one only theoretical Actor model. Though many implementations of this (the Actor Systems) exist, which vary in terms of [???]{.mind}, they are all based on the same fundamental theoretical model semantic. 
On the other hand, there is not one process calculus, but a large variaty of calculi. All are distinct in terms of component traits and communication semantic. The only really homogenous characteristic is that communication is based on message-passing, rather than on shared memory [citation]{.mind}. They share this trait of isolated state and decoupled information exchange with the Actor model.

In a classification of concurrency model, Swalens et al. summarize all abstractions avoiding shared memory and using structured message-passing instead as *communicating threads* [@Swa14]. In this chapter we've already discussed the commonalities of thread-based and process-based concurrency. [ja und jetzt weiter?...]{.mind}

## Verification

~LitNote
* [@Pan17] "Verification in the Age of Microservices"
~