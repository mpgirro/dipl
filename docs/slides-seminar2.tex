%\documentclass[handout]{beamer} % use this to disable \pause commands
\documentclass{beamer}
%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[frame number]
} 

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{pdfcomment}
\usepackage{fancyvrb}


\newcommand{\pdfnote}[1]{\marginnote{\pdfcomment[icon=note]{#1}}}

\newcommand\mydots{\hbox to 1em{.\hss.\hss.}}

\title[Your Short Title]{Concurrent Programming with\\Actors and Microservices}
\author{Maximilian Irro}
\date{Seminar f√ºr DiplomandInnen\\5.11.2018}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Uncomment these lines for an automatically generated outline.
%\begin{frame}{Outline}
%  \tableofcontents
%\end{frame}


\section{Concurrency}

% TODO hier sollte vielleicht noch ein anderer Slide vorher stehen

% ###################################################################

\begin{frame}{Forms of Concurrent Execution}

\begin{itemize}
  \pause
  \item \textbf{Pseudo-Simultaneous}: in alternation on a single CPU
  \pause
  \item \textbf{Parallel}: truely simultaneous on several CPU cores
  \pause
  \item \textbf{Distributed}: several host machines
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{Foundational Issues of Concurrent Programming}

\begin{itemize}
  \item \textbf{Expression of concurrent execution}: threads, futures, coroutines, etc.
  \item \textbf{Communication}: shared state vs. message passing
  \item \textbf{Synchronization}: semaphores, locks, STM
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{Programming Abstractions}

\begin{itemize}
  \item \textbf{Language-Construct Approach}: threads $+$ locks
  \pause
  \item \textbf{Operating System Approach}: processes $+$ pipes
  \pause
  \item \textbf{Network Approach}: processes $+$ network channel
\end{itemize}

\end{frame}

% ###################################################################

\section{Actor Model}

% ###################################################################

%\begin{frame}{Actor Model: basic model primitives}

%\begin{itemize}
%  \item Send a finite number of messages to itself and other actors.
%  \item Create a finite number of new actors.
%  \item Substitute current behavior with a \textit{replacement behavior}.
%\end{itemize}

%\end{frame}

% ###################################################################

\begin{frame}{Actor Model}

%\begin{itemize}
%  \item \textit{Actors} as basic building blocks
%  \item Self-contained, interactive and independent components that communicate via asynchronous message passing
%  \item Unique actor address (location transparency)
%  \item \textit{Mailbox} buffers messages, access is race-free.
%  \item Single-threaded semantics (isolated turn principle).
%  \item Messages are immutable
%  \item Properties allows \textit{actor system} to execute actors concurrently
%\end{itemize}

\begin{itemize}
  \item defines theoretically well-known constructs
  \item receive and process messages (asynchronous, passiv)
  \item process one message at a time
  \item encapsulate state exclusively
  \item runtime system executes actors concurrently
  \item single-threaded semantics internally: exclusive state ownership $+$ isolated message processing
\end{itemize}

\end{frame}

% ###################################################################

%\begin{frame}{Actor Systems and Variations}

%\begin{itemize}
%  \item Erlang
%  \item Akka
%  \item Orleans: mature \textit{active objects} variant
%\end{itemize}
  
%\end{frame}

% ###################################################################

\section{Microservices Paradigm}

% ###################################################################

\begin{frame}{Microservices Paradigm}

\begin{itemize}
  \item complex functionality through composition of several \textit{services}
  \item microservice: small, independent, highly cohesive and loosely coupled executable
  \item \glqq small\grqq{} size $\rightarrow$ in it's \textit{scope of responsibility}
  \item every microservices a dedicated operating system process
  \item communicate via lightweight, technology-neutral message passing channels
  \item executed by an operating system scheduler (concurrency/parallelism)
  \item Network-based communication $\rightarrow$ distribution
\end{itemize}

\end{frame}

% ###################################################################

\section{Research Questions}

% ###################################################################

\begin{frame}{Research Questions}

%\begin{itemize}
%  \item \textbf{RQ1}: Why do actors and microservices qualify for programming concurrency?
%  \item \textbf{RQ2}: How do the actor and the microservice model facilitate concurrent execution?
%  \item \textbf{RQ3}: What are the expressive capabilities of actors and microservices regarding concurrent programming concerns?
%  \item \textbf{RQ4}: How does the performance of actors and microservices compare in a multi-core environment relative to a concurrent system scenario?
%\end{itemize}

\begin{description}
  \item[RQ1] Why do actors and microservices qualify for programming concurrency?
  \item[RQ2] How do the actor and the microservice model facilitate concurrent execution?
  \item[RQ3] What are the expressive capabilities of actors and microservices regarding concurrent programming concerns?
  \item[RQ4] How does the performance of actors and microservices compare in a multi-core environment relative to a concurrent system scenario?
\end{description}

\end{frame}

% ###################################################################

\begin{frame}{RQ1: Why do actors and microservices qualify for programming concurrency?}

\begin{itemize}
  \item Encapsulate state exclusively $\rightarrow$ synchronization-free (\textbf{?})
  \item No shared state $\rightarrow$ message passing communication
  \item Temporal $+$ spacial decoupling 
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{Encapsulation (conceptual) vs. Isolation (pratical)}

\begin{itemize}
  \item Microservice: process memory boundaries
  \item Actors (on the JVM):
  \begin{itemize}
    \item Visibility $+$ Accessibility $\rightarrow$ information hiding
    \item Reference types $+$ pass-by-value $\rightarrow$ immutability
    \item Coding conventions required
  \end{itemize}
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{RQ2: How do the actor and the microservice model facilitate concurrent execution?}

\begin{columns}
  \begin{column} {0.4\textwidth} 
    \textbf{Actors}
    \begin{itemize}
      \item Concurrent execution by actor runtime
      \item History of combining actors with other \textit{compatible} concurrency abstractions (futures)
    \end{itemize}
  \end{column}
  \begin{column} {0.4\textwidth}
    \textbf{Microservices} \\
    \begin{itemize}
      \item Concurrent execution by operating system
      \item Free to use \textit{every} concurrency approach available to the technology stack internally
    \end{itemize}
  \end{column}
\end{columns}

\end{frame}

% ###################################################################

\section{Expressiveness and Capabilities}

% ###################################################################

\begin{frame}{RQ3: What are the expressive capabilities of actors and microservices regarding concurrent programming concerns?}

\begin{itemize}
  \item For specific technology stack
  \item Actor variant: Akka
  \item Microservice: Spring Boot $+$ Spring Cloud
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{RQ3: What are the expressive capabilities of actors and microservices regarding concurrent programming concerns?}


\begin{table}
  \begin{tabular}{l l l}
            & Swim & Cycle \\ \hline
    John T & 13:04 & 24:15 \\ 
    Norman P & 8:00 & 22:45 \\
    Alex K & 14:00 & 28:00\\
    Sarah H & 9:22 & 21:10 
  \end{tabular}
\end{table}

\end{frame}

% ###################################################################

\section{Foundational Issues revisited}

% ###################################################################

\begin{frame}{DELETE Foundational Issues revisited: Expression}

\begin{itemize}
  \item Akka: Actor instantiation from class $+$ runtime
  \item Microservice: Starting system process
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{DELETE Foundational Issues revisited: Synchronization}

\begin{itemize}
  \item \textbf{Exclusive State}: state encapsulation omits the need for synchronization
  \item Microservice: OS enforces memory boundaries among processes
  \item Actor: hazards of the JVM
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{DELETE Foundational Issues revisited: Communication}

\begin{itemize}
  \item Exclusive state $\rightarrow$ no shared state, \textbf{message passing} instead 
  \item Actors have an asynchronous messaging primi- tive. Additional communication abstractions build on top of this primitive, and are therefore at most semi-synchronous.
  \item Microservices are open for every technology-neutral, message passing communication channel in every interaction style
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}{DELETE Concurrent Execution}

\pdfnote{remember to say hello}

\begin{itemize}
  \item Foundation: exclusively encapsulated state $+$ message passing communication
  \item These properties result in a temporal and spacial decoupling
  \item Actor: concurrent execution through actor runtime
  \item Microservice: concurrent execution through operating system
\end{itemize}

\end{frame}

% ###################################################################

\begin{frame}[fragile]{Supplemental: Actor state isolation in Java}

\begin{verbatim}
public class Foo extends UntypedActor {
    public String bar;
    public static Props props() {
        return Props.create(Foo.class, () -> new Foo());
    }
    @Override
    public void onReceive(Object msg) { 
      /* handle msg */ 
    }
}

final ActorRef foo = system.actorOf(Foo.props());
\end{verbatim}

\end{frame}

% ###################################################################


\end{document}

