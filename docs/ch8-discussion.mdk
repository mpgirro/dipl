
Discussion {#ch-discussion}
==========

<!-- of Actors and Microservices -->


~ Epigraph { caption: "Jeannette M. Wing"}
Thinking like a computer scientist means more than being able to program a computer. It requires thinking at multiple levels of abstraction.
~

~LitNote
* [@Agh99] "Actors are similar to sequential objects in that they encapsulate data and procedures"
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
    * "However, the evolution of objects into services, and the relative comparisons, has to be treated carefully since the first focus on encapsulation and information is hidden in a shared-memory scenario, while the second is built on the idea of independent deployment and message-passing."
    * "It is therefore a paradigm shift, where both the paradigms share the common idea of componentization."
* Diskussion: MS behandeln ebenfalls die 3 "foundational issues" die laut [@Agh85b] concurrency modelle lösen sollten
* Weiters zitiert [@Agh85b]: "It is reasonable to expect that large-scale parallel systems will be composed of independently developed and maintained modules. Such systems will be open-ended and continually undergoing change (Hewitt and de Jong 85)."
    * und "Actor languages are intended to provide linguistic support for such open systems" -> dh Actor werden als sprachfeature für das verwendet werden, was MS im prinzip sind.
~

In chapter [#ch-actor-model] and [#ch-microservice-paradigm], we introduced Actors and Microservices separately and focused on their individual concepts. Alert readers will already have spotted conceptual similarities between both approaches. However, as was demonstrated in chapters [#ch-actor-impl] and [#ch-microservice-impl], different solution strategies still have to be applied due to conceptual differences. This chapter brings the ideas together and discusses the similarities their respective concepts share, and the differences that distinguish them. 

First of all however, it must be argued why it is valid to compare a concept of programming concurrency with a software architecture style for distributed systems. The argumentations is fairly simple. Expressing computation with the Actor model yields artefacts - the Actors - which are fit to be executed concurrently. Thus it historically evolved into a model of concurrent computation. 

A Microservice Architectre on the other hand is a composition of processes - the Microservices. The idea that distributed processes can be seen as concurrent constructs is known at least since 1978 from Brinch Hansen [@Han78]. It is no coincidence therefore that the Actor constructs in the Erlang programming language are being called *processes* [citation]{.mind}.

This chapter will therefore dive into the interrelations between concurrent constructs of the Actor kind and system processes flavored by the charcteristics as are dictated by the Microservice paradigm. On this basis, we will be able to discuss weither one of the two approaches is supreme to the other [will ich diesen satz wirklich?]{.mind}.  

## Encapsulation and Isolation {#sec-commonalities-isolation}

~todo
Hier die Sachen von unten als Einführung beschreiben (ohnehin nicht mehr all zu viel übrig)
~

~LitNote
* "promise behaviour via API/protocol" --> design by contract
* [@Kan12] 4 four important semantic properties of our
extension based on Actor systems: encapsulation, fairness, location transparency and mobility [16 --> Actor Frameworks for the JVM Platform: A Comparative Analysis]
* [@Bon17] "This simple fact has huge implications. It means that data can be strongly consistent only within each service but never between serv‐ ices, for which we need to rely on eventual consistency and abandon transactional semantics"
* [@Bon17] "Isolation makes it easier to scale each service, as well as allowing them to be monitored, debugged, and tested independently"
* [@Kni96] "Encapsulation is probably the only feature that is generally agreed to be an indispensable (sine qua non) characteristic of object-oriented languages. Some researchers even consider encapsulation to be the fundamental object-oriented concept and that all other object-oriented mechanisms and approaches exploit encapsulation to various ends ([9]). There also seems to be general agreement on the fact that encapsulation and sharing are incompatible: sharing tends to violate encapsulation while encapsulation tends to prevent sharing."
    * hier muss ich auch noch was zu visibility schreiben, weil ich im actor-solution kapitel schreibe das es hier schon vorgekommen ist!
* MS sind per definition, insofern sie auf shared memory konzepte verzichten, immer perfekt isoliert, durch das OS. Bei Actor müssen die verschiedenen "notions of state" beachtet werden, um eine strong state notion einzuhalten, also preserve local state and transient state, wie es in [@Kni96] beschrieben ist
* [@Kar09] Encapsulation = State Encpasulation + Safe Messaging
    * nach meiner auffassung ist das genau isolation; das sollte ich vll hier anbringen
~

Actor and Microservice semantics rely on a strict separation of component states. This arises the need to ensure that state is conceptually encapsulated within a component and practically isolated from the outside. 

The conceptual need is known from Object Oriented Programming. As Snyder points out, OOP usually offers mechanisms to restrict the access to an objects state by requiring clients to issue requests for the services an object offers in order to get access to or modify the objects state [@Sny93]. These "services" - not to be confused with the concept of a *Microservice* - are what Meyer calls well-defined interfaces, or simply routines, and considers to be a necessity for encapsulation [@Mey97]. 

Both Actors and Microservices define such well-defined interfaces in their own way. For Actors its the sum of messages it understands through its behavior. For Microservices its based on the facilitated communication channels, e.g. the REST interfaces it exposes, or the messages it consumes from a message broker (AMQP queue, Kafka, etc.). Only through these interfaces can the state of an Actor be accesses or modification to it be issued.

Ensuring that state is only accessible through the a components interface, i.e. that it is isolated from any illegal access from the components outside, is rather different for both styles due to their conceptual differences.

...

### Shared and Mutable State

One fundamental characteristic of both Actors and Microservices is their notion of shared state. Summarizing chapter [#ch-actor-model], the Actor model encapsulates state exclusively within an Actor. Therefore it can only be accessed and modified by the Actor itself. Additionally, Actors provide single-threaded semantic while processing messages, i.e. only one message is processed at a time. This eliminates any need for synchronization, for a message has exclusive access to the Actors current state, and thus is free of low-level data races. The Actors state is fully isolated.

On the other hand, such reasoning cannot be done for Microservices in general. The paradigm states nothing about how state has to be handled internally. Depending on the programming paradigm used to implement the service, i.e. multiple objects could have access the same memory location. Furthermore, these state accesses could be executed concurrently, e.g. as a reaction to multiple invocations of the services interface within a short timespan. Microservices do not ensure any kind of single-threaded semantic. This requires synchronization to internal service state.

However, the Microservice paradigm dictates that shared memory *between* services is to be avoided, as are all kinds of shared resources in general. For every service runs within its own system process, avoiding shared memory implies no direct intersection between service process boundries. Typical communication channels satisfying the requirements given in section [#sec-ms-communication] also prevent any form of reference sharing to joined mutable data [citation needed? oder kann ich das als zusammenfassung von schon erklärtem verkaufen?]{.mind}. Such channels tend to provide some sort of message passing (which can also be in a synchronous fashion, e.g. REST), which is designed to transfer information between the different memory spaces of distinct processes [@Les09].

Actors are generally faced with more challenges when it comes to truely ensuring state separation, because the components can exist within the same process boundries. This theoretically allows access to the same memory locations [citation needed, irgendwo bei der OS literatur wird schon was stehen]{.mind}. Depending on the programming paradigm used for implementing the Actors, exposing shared state to others might be very simple and not apparent to the programmer. Especially the imperative style leans on mutable state, thus suffering from the need of applying extra care to preserve the model semantic. The functional paradigm tends to avoid such problems inherently, for behaviour is modeled as a function, and this function is the only mutable state, which may be modified exclusively by the Actor itself. If the Actor model is integrated into the programming language itself, such problems can be avoided by designing appropriate restrictions enforced by the language directly. However, library based Actor implementations in general cannot ensure full isolation by themselves [@Kos16]. Section [#sec-ensuring-actor-isolation] will discuss in detail the specific demands such libraries can pose to the programmer for a given Actor library.


### Persistance {#sec-commonalities-persistance}

The encapsulation and isolation principle of Actors or Microservices has one more important implication for both concepts. For state is exclusive to a single component, each must also take exclusive care if given state is expected to be durable accross the components livetime. This property is usually refered to as *persistence* [kann ich da was zitieren?]{.mind}.

Persisting information can be implemented in many different strategies. Database systems are one well established approach. Sharing a database between two or more components would grant access to one component's persistent state to all others connceted to the same database used. This would not only provide a simple way to skip any isolation mechanisms and bypass the components interface, thus breaking the encapsulation principle. Additionally, it would also open up a form of implicit communication through shared mutable state [hierzu hab ich irgendwo literatur]{.mind}.

The consequence is, that any component must have its very own database, or persistance mechanism in general, if such is required. This restriction has to be taken care of by programmers, for neither an Actor System, nor any Microservice technique can enforce this. Unfortunatelly, this is a rather unintuitive requirement, for database systems have always been design to be accessed and used by multiple components concurrently in general. Database APIs tend to allow that multiple modules (concurrent or not) inside a single program might read from and write to the same database instance, thus it is easy easy in general for multiple Actors too.

Inside a Microservice, this is not a problem. Multiple internal modules may use a database exclusive to the service, as is with any other monolithic application. However, multiple Microservices must not leverage the same database that could be available for both of them. 

This restriction opens up another opportunity however. Monolithic applications tend to rely on as few database systems as possible, for a multitier architecture traditionally has the data access layer at the bottom, and consecutive layers are build relative to it. Thus, any new database system bringt the risk of fundamentally impacting a programs architecture. It is therefore unusual for program modules to have their own persistance layer exclusive to them. However, due to their respective natures, modules based on the Actor abstraction and systems composed of Microservices make it easy to add a persistance layer to accomodate their special requirements. 

This approach on introducing specialized database systems based on respective persistance needs, at the risk of introducing potential redundancies, is sometimes refered to as *polyglott persistance* [citation?]{.mind}.

## Communication and Message Routing

~LitNote
* [@Bac03] beschreibt verschiedene dieser mechanismen, nennt sie aber teilweise anders; trotzdem als quelle verwenden
~

Actors facilitate by definition message passing for component communication [some sources]{.mind}. For Microservices, message passing is too the joint perception for communication style  [source 1, 2, 3]{.mind}. As such, their communication capabilities still deviate.

For any sort of information exchange between two concurrent task units, there are two general modes of communication: *shared state* and *message passing*. The former relates to any form of controlled access and modification to a common memory, while the later strictly prohibits mutuable shared memory and instead relies on communication links used as I/O mechanism by the tasks [@Bac03; @Fel90]

Thus, message passing must occure through a so-called *communication channel*. Such channels transport information from a source to a destination, i.e. a *sender* is writing data to the channel, upon which a *receiver* may read it. Independent of the concrete channel technology, this implies a synchronizing the information, for the event of reading a message can intrinsically only occur *after* it has been sent. In contrast, shared state communication must explicitely define an order of accessing information [@And83].


---

We've identified various forms of information flow in the literature [@Mon14;@Gui09;@Spe90;UND WEITERE!] with varying terminologies. They can be distinguished along side two dimension: number of recipients and response style. The taxonomy given below will be used: 

~LitNote
* [@Mon14] Jolie kennt: 
    * (one-way), (request-response), (notification), (solicit-response) == async response?
* [@Gui09] hat die von Jolie
* [@Spe90] "point to point (rendez-vous) or diffusion (broadcast and multicast)""
~

~ center
|------------------|------------------------|-------------------------|
|                  | One-to-One             | One-to-Many             |
+------------------+------------------------+-------------------------+
| **Synchronous**  | Request/response       | -                       |
| -----------------| -----------------------| ------------------------|
| **Asynchronous** | Notification           | Publish/subscribe       |
|                  | Request/async response | Publish/async responses |
|------------------|------------------------|-------------------------|
{  }
~

By far the most prominent example in the literature [referenzen]{.mind} for viable Microservice communication is REST. Our major critique on this is that REST is merely a representative of synchronouse one-to-one communication, and does not cover the other [bereiche]{.red}.

---

MESSAGE ROUTING

Akka:

```{language:scala}
val router: Router = {
    val routees = List(actor1, actor2)
    Router(BroadcastRoutingLogic(), routees)
}
router.route(message, sender())
```

Alternative routing logic's are available, for example `RoundRobinRoutingLogic`{language:scala}, which distributes messages [one after another]{.red}

...

Microservices:

* REST: one-to-one
* AMQP: notification or request/async response

AMQP is not directly applicable for one-to-many communication




* MQ hat den vorteil, dass ein Worker sich dann einen Job holt, sobald er wieder frei ist (pull). Actor routers hingenen teilen die Jobs via RoundRobin aus (push), weswegen es kein begrenzung der Last gibt, dh die Mailbox eines Workers kann überlaufen 

## Separation of Concerns and Single Responsibility

Separation of Concerns:

~LitNote
* [@Weg90] "Concepts and Paradigms of Object-Oriented Programming"
    * "Splitting a large task into components is a time-honored method of managing complexity, variously referred to as "divide and conquer" and "separation of concerns"."
* SoP between behavior and deployment part of Jolie programs, siehe [@Mon14;@Gui17]
~

The strict encapsulation of state offers the opportunity to introduce multiple persistance strategies, without having an impact on the architectural layout. There is a more general concept to describe this form of modularization, called *Separation of Concerns* (SoC).

Having state strictly encapsulated, up to  

...

... both Actors and Microservices provide a good basis to facilitate a clear separation of concerns due to their strict notions of high cohesion and loose coupling. However, as with many abstractions, SoC is merely [a best practice / a goal ... and cannot be enforced or demanded in any way]{.red}. Services can be enassigned as many concerns as wished, and Actors can also receive any kind of message, making them potential targets to all sorts of requests and jobs [FURCHTBAR FORMULIERT, aber richtige botschaft]{.red} 

---

Single Responsibility:

~LitNote
* Unix philosophy
* [@Bon16]
* [@Bon17] "This idea was later brought into the Object-Oriented Programming community by Robert C. Martin and named the Single Responsibil‐ ity Principle2 (SRP), which states that a class or component should “have only one reason to change"
* "functional separation" [@Sal16]
* single responsibility ist ein gutes beispiel, wieso man exlusive datenbanken gut gebrauchen kann
~

We've found Actors to provide an easier abstraction to facilitate single responsibility, for the model primitive allowing to spawn new Actors on demand encourages the outsourcing of responsibility into dedicated Actors. A good example are the dynamically created response handler Actors for each search request that wait on an asynchronous response substituting for a `Searcher`.

Microservices on the other hand offer less incentive to encapsulate each distinct responsibility inside a dedicated task unit. Each conceived service is by design a dedicated program, thus entails all resulting challenges ranging from the obligation of maintaining an its own separate codebase up to the additional deployment considerations.

## Cohesion, Coupling and Independence

~ important 
TODO

Literatur?
~

## Notions of Concurrency

Both Actors and Microservices are the components that are being executed concurrently within their system architectures. However, both constructs have different notions of concurrency, which is a direct result of the underlying concepts. The following discusses the differences and their implications.

...

~LitNote
Je nachdem ob ich es oben schon erwähnen will, aber [@And83] definiert 3 "main issues of concurrency" (ACHTUNG wörtliches zitat):

1. "how to indicate concurrent execution"
2. "which mode of interprocess communication to use"
3. "which synchronization mechanism to use"

...

Andrews and Schneider argue that there are three main issues regarding the "design of a notation for expressing a concurrent computation" [@And83]: indication of execution, interprocess-communication and synchronization mechanism.

* Any concurrent execution has to be *indicated* in some form (And83). This can be explicit (Threads, etc.) or implicit (bezug nehmend auf Ch2)
* The kind of interprocess communication, i.e. the characteristics of the mechanism
* The approach towards synchronization

Actors as we
~

### Threads, Processes and Tasks

~LitNote
* [@Hal09] Scala Actors: Unifying thread-based and event-based programming
    * "There is an impedance mismatch between message-passing concurrency and virtual machines, such as the JVM. VMs usually map their threads to heavyweight OS processes. Without a lightweight process abstraction, users are often forced to write parts of concurrent applications in an event-driven style which obscures control flow, and increases the burden on the programmer"
    * --> Event Driven Programming Style (also so Callbacks in Java zB) sind Mist, 
* [@Agh91] "Actors as Processes: The representation that we are implementing models actors as light-weight processes and requires the presence of a kernel run-time system on each node."
* Hier kann ich die gesamte Erlang Literatur einbauen, denn die nennen ihre lightweight constructs ja auch *process*
* [@Kar09] beschreibt location transparency bei actors
* [@Swa14] "Towards composable concurrency abstractions"
    * "We classify concurrencymodels that use structured communication in terms of messages, instead of relying on shared memory, as communicating threads."
    * "Often, each thread has only private memory, ensuring that all communication is done via messages."
~

~todo
Processe sind immer "fett", durch das OS; Actors hängen davon ab wie sie umgesetzt sind: Als event-based mit callbacks, mit einem threadpool anstatt jedem Actor seinen eigenen, weil threads ebenfalls fett sind (bei der JVM jeder thread ein process); in Erlang auch "process", was aber light-weight thread speziell durch die BEAM VM
~

Akka Actors are executed on threads, sharing such from 

This is not a requirement. Originally, Scala Actors supported two distinct kinds of defining Actors: the thread-based Actors, similar to the Akka variant, and event-based Actors, a more light-weight but also more limited implementation based on the idea of method callbacks [@Hal09].

Microservices run in their own process. Such are relatively heavyweight




### Concurrency of Components

The Isolated Turn Principle essentially define Actors as single-threaded entities. Only in combination with asynchronous message passing as dictated by the model allows for a concurrent execution of the components. As such, an Actor has no notion of any concurrency at all in general.

As was demonstrated, additional concurrency abstractions may be introduced into Actors, as long as those do not break model semantic. Futures were given as one option. Such abstract a value which will be available at some point in time eventually. Basically they introduce a notion of semi-blocking behaviour [irgendwo hab ich hierfür ein zitat!]{.mind}. Either the value is available when trying to access it, or blocking is the consequence until it is. A third way of handling Futures is possible, which directly defines consecutive computation on the value without blocking, but once it becomes available. In any case however, they pose the risk of accidentially introducing data races. As a safer alternative, Actors can use delegation to child Actors to provide concurrent processing, without jeopardising safe encapsulation as do Futures.

Microservices on the other hand are concurrent distributed processes. There notion of concurrency may therefore deviate from Actor, for they internally do not have to respect something like the Isolated Turn Principle. Though a service also receives messages via its public API and reacts to them, the flexibility in the design allows to create task units that react to multiple messages concurrently, e.g. to make a synchronouse call and blocking wait for a reply within the routines code, without blocking the whole task unit. The drawback of this degree of freedom is the set of issues any internal concurrent resource access inherently has. A basic example is locking. When an Actor processes a message, it is guaranteed to have unqiue access to its internal state, therefore must no handle any locks and can savely assume its state as up to date. When a Microservice accesses any kind of internal resource (state), this resource might currently be locked by an internal transaction mechanism, granting read access, but not guaranteeing that the state is actually up to date. [dirty read? irgendwas allgemeines zu locking und read zitieren]{.mind} 

Programming with Microservices does not, unlike Actors, free one from the many hassles of low-level concurrency concerns per se. Depending on the model used, locking and synchronization as demonstrated in the concurrency in Java case study might have to be dealt with. However, the services size - based on its scope of responsibility - is limiting the complexity of the services internal concurrency considerations relative to the overall systems [citation needed? hab ich da eine? ist ja eigentlich mein eigener beitrag]{.mind}. As a result, linguistic approaches to SOC migth try to avoid this completely by applying an idea resembling the C processes case study. The `concurrent`{color:blue} primitive for Jolie services execution modality for example dispatch dedicated processes for concurrently executing the service behavior in response to messages [@Mon16b]. This has close resemblance to the delegation messaging pattern used by Actors.

### Fair scheduling

Actors and Microservices represent concurrent building blocks of equal status in their respective architectiures. Due to our uniform view on concurrent execution, that is regardless of quasi-simultanious on a single processor, truely parallel on multiple CPUs and distributed among host machines, it is important to reason about the chances to make even progress [@Bus90]. This property is called *fairness* and is closely related to the liveness of concurrent programs and systems.

Actors are entities inside an Actor System. As such, their scheduling is the responsibility of this system, viz. its execution strategy. As passiv components, Actors have no proactive sense, i.e. they only react to events (received messages). Actor Systems assure that each message is delivered to and process by an Actor eventually. Therefore each Actor must be scheduled regularly by the system to guarantee that it cannot permanently starve [@Kan12;@Kar09].

This has one major benefit. If an Actor's mailbox is empty, it is therefore not necessary for the system to invoke it, for there is nothing to do for it. This way, an Actor system can greatly reduce processing resource consumption [citation?]{.mind}.

For Microservices on the other hand, scheduling itself is a nonconcern. Any MSA is a composition of concurrent distributed processes, and as such their scheduling is delegated to the operating system(s) these processes are running on. The OS's *scheduling policy* is therefore what effects the liveness of any process [@Bac03]. There is one drawback to the lack of scheduling influence in MSA's however. The architecture cannot influence the resource consumption based on a services actual demand. An operating system will always allocate resources towards a process, and thus any task unit will always stress its hosts processing power on a regular basis, at least to a small amount. This is true even when the service is neither requested nor has active behavior of its own to execute. Such process activations are then simply a waste of energy [hab ich da was zu energy consumption?]{.mind}.

## Distribution

~LitNote
* Actors und MS ist es an sich egal ob sie lokal oder verteilt ausgeführt werden, beide können dies gut abstrahieren
* [@Reh13] defines requirements on distributed Actors:
    * R1: Distributability: Non-distributed applications must be easy to be migrated to clustered set-ups.
    * R2: API-uniformity: The distribution API must be similar for intra-node as well as inter-node applications
    * R3: Compatibility: An application that works locally on one node should also work distributed in a cluster.
    * R4: Flexibility: Beside Actors that have access to specific hardware, the developer should freely decide which Actor runs on which node of the cluster.
    * R5: Configurability: Simple configuration of the clustering subsystem and the distribution layout.
* [@Kan15] (über distributed/cloud Actors)
    * "There (Actor) distinctive features make it suitable to support distributed memory parallelism, and it has been widely used in many industrial languages such as Erlang[2], Scala [3], Akka [4]"
    * "However, most related works focus on multi-core environment. Neither inter-parallelism or task parallelism can be easy applied in dynamic distributed environment, because Actors distributing over cluster may be- have indeterminable interrelationship, such as uncertain com- munication, dependency and failure"
* [@Kan12] (über distributed Actors)
    * Computers connect by network, which makes the environment distributed, disparate, mutable and unreliable
    * According to classifications of parallel programming models in process interaction, mechanisms of which make the parallel processes able to communication with each other, the most common forms of interaction are shared memory, message passing, and implicit [4]
    * In Actor model, location transparency means the actual location of an Actor does not affect its name. That is to say, if one Actor knows another, they can communicate only by names instead of specific address --> kommunikating via ActorRef instead of pointer; bei MS muss das zB für REST extra ein Service Discovery übernehmen, der dies abstrahiert; 
    * Obviously, State encapsulation is a desirable consequence of location transparency. Location transparency facilitates runtime migration of our computing elements to different nodes, which brings good mobility. Moreover, migration enables runtime optimizations for load-balance and fault-tolerance
* [@Fel90] "Language and System Support for Concurrent Programming"
    * beschreibt das Message passing ganz prinzipiell nicht davon abhängig ist, wo die beteiligten componenten sind (im gegensatz zu shared variables/memory)
~

Distribution is decoupled execution in space [citation - Boner]{.mind}. As we've already motivated, any space-decoupled concurrent execution is inherently parallel. In the same context it was stated that relatively local parallelism is called intra-node parallelism, while actually distributed parallelism is called inter-node.

---

Communication via message passing has one fundamental property: no memory is shared between the communicating components. Though we will see later, that this semantic can actually be violated due to implementational hazards used for passing messages, conceptionally it does not require that the components are within the same memory space. Thus, it does not matter weither they run on the same processor, different cores or even the same host machine [@Fel90]. In short, message passing allows for distribution. 

The Actor model intrinsically builds upon message passing to share state information between Actors. Additionally, Actors are well isolted from each other. Based on these properties, Agha recast the initial notion of Actors in the light of distributed computation [citation? die diss? oder dieses 43 year paper auch noch]{.mind}. 

~Todo
Microservices können auch message passing, aber auch synchrone. Die location transparency kommt entweder von der MOM, oder eben von einem lookup service für die REST endpoints.
~  

### Location Transparency and Mobility


...

Microservices allow for arbitrary communication channels, as long as those conform to the paradigm. Pipes have been stated a a viable example. However, as we've pointed out, such are limited to the memory boundries of a single OS [soll ich da was zitieren? hab ich eh schon 1000 erklärt]{.mind}. Channels operating on network level intrinsically distributed communication mechanisms, which facilitate message passing [@Bar97] and provide a uniform interface for remote as well as local communication [@Spe90].

...

Mobility means changing topologies (brauche was aus dem ich das zitieren kann). Location transparency offers the possibility for topologies of components to change. Such moving is called *mobility*.

---

Mobility:

~LitNote
* Laut jones Bonér folgt mobility aus location transparency
* [@Kan12] (über distributed erlang Actors)
    * Mobility is defined as the ability of processes moving from one node to another. It is classified into two types. Strong Mobility means supporting movement of both code and execution state, while weak mobility only allows movement of code
    * At the system level, mobility is important for load balancing, fault-tolerance and reconfiguration. 
    * [25] = [@Pan94] has shown that mobility is essential for achieving scalable performance.
* [@Fug98] "Understanding Code Mobility"
* [@Agh14] "Actors Programming for the Mobile Cloud"
* [@Car97] "Designing Distributed Applications with Mobile Code Paradigms"
* [@Kar09] beschreibt mobility bei actors
* [@Sal16] "The Evolution of Distributed Systems Towards Microservices Architecture"
    * Keywords: Distributed Systems; Microservices; Mobile Agents; Service Oriented Architecture
    * ad *Mobile Agent*: "An agent is composed of three parts which also take place in travelling: Data, State and Code."
* MS service discovery:
    * see [@Mon16a] for example solutions/implementations/technologies 
* MS: "Location of MS may not be statically known at design time" [@Mon16a]
~

Mobility:

~LitNote
* [@Gui09] "Reasoning About a Service-oriented Programming Paradigm
    * Slave service mobility andMaster service mobility
~

### Resemblance to Distributed Objects {#sec-distributed-objects}

~LitNote
* Lokation transparency ist super und alles, wenn es richtig gemacht wird. die Verteilten Objekte machen das auch, und führen zu massiven Probleme --> hier hab ich diesen einen Artikel "A Note on Distributed Computing" oder so. An dieser stelle sollte ich diskutieren wieso Actors und MS diese Probleme nicht haben, bzw was zu beachten ist um es zu vermeiden
* [@Siv99] "The specification of distributed objects: liveness and locality"
* [@Wal96] "A Note on Distributed Computing"
* chapter 2.8 in [@Bac03]
~

In object-oriented programming, the overall programs state is partitioned into disjoint sets, each chunk belonging to a distinct object. As Werner pointed out, from a logical point of view, the state is as such distributed [@Weg90]. However, distributed programming has different emphasis of concerns than OOP does. And yet, both architecture styles can be integrated such that objects support pyhsical distribution. The result is called *Distributed Objects* (DO). 

The concept that has been popularized in the 1990s [citation needed]{.mind}. Objects do not have to exists within the same program boundary, but can be distributed across multiple programs and therefore host machines. As such, DO's can be viewed from a process-oriented perspective. We refere to Barrio and Fuente [@Bar97] for a formal definition on modelling objects as processes.  

In terms of programming interface, for every DO a proxy object is created on the client side, which wrappes the method calls to the actual distributed object, which then does not necessarily has to be located within the same program boundry [quelle für den absatz, wiederholung von "program boundry"]{.mind}. This allows for location transparent method calls. Examples of such DOs are Java RMI or CORBA [quelle, richtig?]{.mind}. They seem to share many conceptual similarities that we are discussing here. On the one hand, the design goals of Microservices seem to aim towards the single-purpose, minimal and slim skeleton that distributed objects have compared to full-fletched monolithic applications. On the other hand, their distributed nature inherently leads toward the possibilities of transparent concurrent/parallel execution, like Actors or active objects do. 

However, the abstraction the distributed object concept provides was found to be be "leaky" due to conceptual problem [citation needed - note on distributed computing]{.mind}. The transparent method call they offer is hiding to much context do be able to handle the many faults that come with any distributed programming setup. A simple example: 

~LitNote
* [@Ber14]
    * "In a traditional RPC model (such as Java RMI, CORBA, or WCF) the programmer needs to explicitly bind the virtual reference to the service, usually via an external registry or location service."
~

~Todo
hier das beispiel mit dem 1000 methoden aufrufe für die simme von .getSize()
~

We already discussed the analogies of Actors and microservices to the notion of objects. Now, with these similarities and the fact that Actors (or active objects) and microservices each provide mechanisms for location transparent messaging too, we should discuss weither they qualify as distributed objects themselves. This would mean they face the same problems as DO too. 

#### Actors as Distributed Objects

As with Distributed Object, the Actor model has the potential to address distributed components transparently. Actors use the concept of addresses, which substitute for local interfaces, just like DO proxies. As such, they might allow for different interfaces however. The Erlang programming language famously introduced the style `address ! message` to send a message of arbitrary form to an Actor itentified by a known address [vll was zitieren]{.mind}. Of course, Erlang does not implement object-orientation, and thus accessing state and message passing are strictly separate constructs by design.

However, other Actor systems have adopted this style, e.g. as was done in Scala. There the type system opens up the opportunity to use a punctuation-free syntax to invoke methodson object which take only a single argument, offering an infix notation style[^fn-punctuation-free-call]. Despite an object-oriented context, this allows to use different syntactic constructs for referencing ordinary objects, and addressing Actors, if merely by convention. 

[^fn-punctuation-free-call]: The expression `address ! message`{language:scala} is therefore merely syntactic sugar for `address.!(message)`{language:scala}.

The truely fundamental difference now between addressing an Actor and a Distributed Object is within the dispatch semantic. Actors rely on asynchronous message passing as defined by the basic model primitives. Any asynchronous messaging is decoupled in time [cite Boner]{.mind}. It does not introduce the expectation of an immediate response as could be with a synchronous-styled dispatch, which is essentially what method calls with a return value abstract. Thus, message passing is more loosely coupled than request/reply methods.

Therefore, especially in object-oriented contexts where Actors are implemented as ordinary objects, special care has to be taken in order to avoid any chance to accidentially introduce such tighter coupled public methods. Additionally, Actor systems may intentionally provide higher-level constructs to abstract synchronous communication ontop of asynchronous messaging.

In there principles however, we deem that Actors avoid the problematic abstraction of Distributed Objects. 

#### Microservices as Distributed Objects

The method call on a DO proxy object makes it transparent for clients weither a locally available or remote server object is addressed. Within the Microservice paradigm, there is no such abstraction in general. Service-internal interaction within its modules use the standard paradigms of the technology used to implement the service, e.g. calling an object's method, or referencing a function. To issue any external request (despite expecting a reply or not) a respective communication interface has to be issued. Such is dedicated to the communication channel, e.g. a HTTP library or message queue API. Thus, any external interaction should be recognisable to the programmer in general. 

Of course, due to the freedom of the Microservice paradigm, it is possible for any service to utilize a technology that is again abstracting the difference between internal and external interactions transparently. It is in the responsibility of the programmer to select [???-adjektiv]{.mind} frameworks and issue appropriate design desicions. 

An additional argument is the granularity of service interfaces. While objects may provide very fine grained interfaces in general, e.g. to access each of its state variables separately, service tend to have more course grained interfaces. In a Microservices context it is more likely that messages between services do not issue very fine grained operations on the receiving service in general, but instead aggregate more course grained operations relative to the interface granularity. Thus, [???]{.mind}

Therefore, we deem it unlikely for Microservices to suffer from the leaking Distributed Object abstraction.

#### Active Objects as Distributed Objects

We have discussed now weither Actors or Microservices qualify as abstractions of the Distributed Object concept, and came to the conclusion that the risk of being misused as DO's is moderate for both. However, section [#sec-active-objects] introduced another variant of the Actor model that is worth discussing here, for it explicitely capitalises an object-oriented abstraction, just like DO's do: Active Objects.

Section [#sec-active-objects] gave an example of the concurrent semantic the API of Active Objects provide. The method call is separated from the message execution. We demonstrated the behaviour in case of method interfaces with and without return values. Building on the previous example, we define this program:

``` {language:scala}
val fs: List[Fnord] = ... // list of 100 references
var sum = 0
for (f <- fs) {
    sum += f.get()
}
print(sum)
```

The code snippet iterates over all elements and makes a blocking call to retrieve the value. This has two fundamental issues:

1. The programs will block sequentially 100 times, once for each element.
2. If some, or in the worst case all, of the elements are not within the same local boundries but transparently distributed, this will cause up to 100 separate remote procedure calls with as many opportunities of any fault a synchronous network call can result in.

The first issue is a result of bad coding practice. The second issue is based on the same leaky abstraction distributed objects suffer from. The `get()` method could be called without the programmer being aware that it actually offers a result value and therefore will block (though with this particular method name and usage it hopefully is unlikely). Additionally it is not clear weither the dispatched method will execute locally or remotely. The abstraction simply hides too much.

Both issues could be fixed by using the *future type* of message passing for Active Objects that has been introduced. This is done by changing the declaration of `get()` to return a `Future[Int]`{language:scala} instead. In functional languages, handling Futures can be done elegantly if they offer monadic behaviour that fits natural with functional programming styles, e.g. in Scala:

``` {language:scala}
1  Future.sequence(fs.map(_.get))
2    .map(_.sum) 
3    .onComplete {
4       case Success(res) => print(res)
5       case Failure(_)   => print("error")
6    }
```

This is an example where it is efficient to combine other abstractions of concurrent computation that integrate well with the Actor semantic. Line 1 transforms `fs:List[Fnord]`{language:scala} first into a `List[Future[Int]]`{language:scala} and then into a `Future[List[Int]]`{language:scala}. The Actor system's dispatcher can now wait until this `Future`{language:scala} completes without having to block the underlying thread. The call stack starting in line 2 is only applied upon completion, finalizing the intended result. 

However, this argumentation only holds under certain assumptions. As we already mentioned, different Actor Systems have different capabilities. In section [#sec-active-objects] we've stated that class `Fnord`{language:scala} extends some arbitrary `ActiveObject`{language:scala} class, but did not discuss the implications the used implementation would have on the correct behaviour. Assuming `Fnord`{language:scala} is changed to use the concrete Active Object abstraction Akka provides (called `TypedActor`{language:java} for it offers type safty for message passing), the desired non-blocking behaviour actually depends on the `Future`{language:java} used for wrapping the `Int`{language:java} result. Akka supports asynchronous dispatch only for the `scala.concurrent.Future`{language:java} trait. If class `Fnord`{language:java} uses its Java friendly `akka.dispatch.Futures`{language:java} interface, the intended behaviour is guaranteed. However, the standard `java.util.concurrent.Future`{language:java} interface would result in undesired blocking behaviour [@AkkaFuture].

We see, in general Active Objects have the potential to be used in the same problematic way Distributed Objects are. The methods interface defines the method dispatch semantics. If not used with utmost care, method calls can easily become simple remote procedure calls in a transparent way. This can cause bottlenecks, deadlocks, timeouts due to stacked network latencies, [...]{.mind} and having negative impacts on scalability, [...]{.mind} 

However, the one major benefit of Active as well as Distributed Objects compared to classic Actors and Microservices is their type safety. It is statically known weither a server will be able to understand a request, and respectivly a client may only dispatch messages which are guaranteed to be acceptable [kann ich da was zitieren?]{.mind}. 

### Components per Execution Environment

~LitNote
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * Beschreibt ch4.4 "Actors Per Execution Environment"
    * Classic Actors and Processes (Erlang) sind auf dem "level of abstraction" wie objekte in OO, oder abstract data types in FP
    * Active Objects und Communicating Event-Loops sind auf dem level of abstraction von "components" in OO, oder modulen in FP  
~


## Interoperability and Technology Heterogeneity {#sec-technological-heterogeneity}

Extensibility:

~LitNote
* Actors, siehe: [@Agh85b]
* gradual/separate replacement of MS
* substitution and subtyping für Actors
* MS: "new versions can be gradually introduced into a system" [@Mon16a]
* [@Lis88] "Promises: linguistic support for efficient asynchronous procedure calls in distributed systems"
    * describe the concept of Promise for "heterogeneous computing in which programs written in different programming languages, and running under different operating systems on different hardware, can use one another as components over a network"
~

Technology Heterogeneity:

~LitNote
* [@Sub11] demonstrates how Akka can be used not only by Scala/Java binding, but other JVM languages too
* [@New15] Newmann calls it "Technology Heterogeneity"
~

## Governance, Deployment and Autonomy

~Todo
(Partially) Centralized with Actor systems, decentralized with MS (aber was ist mit cloud management frameworks)
~

~Todo
Independent deployment
~

Autonomy:

~LitNote
* [@Bon17] 
    * "Isolation is a prerequisite for autonomy. Only when services are iso‐ lated can they be fully autonomous and make decisions independ‐ ently, act independently, and cooperate and coordinate with others to solve problems"
    * "Working with autonomous services opens up flexibility around ser‐ vice orchestration, workflow management, and collaborative behav‐ ior, as well as scalability, availability, and runtime management, at the cost of putting more thought into well-defined and composable APIs"
* MS: "components can be deployed separately" [@Mon16a]
~

## Scalability 

Scalability:

~LitNote
* "Scaling a microservice architecture does not imply a duplication of all its components" [@Mon16a]
* [@Xu16]:
    * "Among many dimensions of scalability, horizontal scaling plays a crucial role in cloud computing, which means replicating multiple identical copies of the processes of the application behind a load balancer"
~

~Todo
Server and Client Side Load balancing
~

## Dynamic Reconfiguration

[TODO: hier muss ich ein paar Referenzen einstreuen?!]{.red}

Dynamic reconfiguration relates to a change of system topology at runtime, such that task units may be added, removed or relocated divergent from the static initialization configuration [kann ich hier etwas zitieren?]{.red}. Actor support this inherently through the primitive allowing Actors to spawn new Actors. It was demonstrated with the dynamically created response handlers `H` spawned by Searchers. The loose couplying of Microservices too provide support for chaning topologies in principle, e.g. by utilizing service registries and asynchronouse messages through intermediate message queues.

A general Location transparency is a prerequisite for dynamic reconfiguration is localtion transparency. Both Actors as well as Microservices have sophisticaed solutions for it. Two additional properties, *mobility* and *elasticity*, are made possible as a result of location transparency. Mobility referes to the relocation of components between nodes at runtime [zitat?]{.red}. Elasticity is a form of scalability that summarizes the ability of a system to scale the amount of components dynamically depending on the current demand [zitat?]{.red}.

The requirements in chapter [#ch-scenario] explicitely state that neither mobility nor elasticity are concerns for Echo. However, the general approach would be largely identical, therefore we present a short outline. Stateless task units can be easily created and terminated on demand (elasticity), which also doubles as mobility, for they do not have state to relocate. The stateful Stores are another concern. In general, when such units are (re-)created, it is not safe to assume that their persistent state (database, reverse index) is up to date, and therefore has to be updated regarding all outstanding modifications to it. *Event sourcing* is a general concept that is convenient, that is all modifying commands to a store would be persisted in a so-called *event log*, such that a new or reactivated Store can request [die noch ausstehenden befehle]{.red}. This would require additional technology for the event log, e.g. Kafka[^fn-kafka] which is a widely adopted distributed publish/subscribe streaming system offering persistence. With it, Store units would have to persist a counter or reference to their last received event separately still. Conceptually, such system would be introduced as a new archiecture component for providing asynchronous one-to-many communication:

* Message Broker (B)
  : [TODO a (possibibly persistant) message distribution channel]{.red}

For example, when the state of a Store needs to be modified, instead of performing the update operation directly, a Store instead sends a respective message to be brokered to all Stores of the respective kind, e.g pushed `D` &rarr; `B` from which it gets pulled $\{\textsf{D}_{1}\cdots\textsf{D}_{n}\}$ &larr; `B` by all DirectoryStores, even the sender, such that each performs the state update.

[^fn-kafka]: <https://kafka.apache.org> 

In general, we deem the concerns related to dynamic reconfiguration more easily met with Actors, for it is a core concept through one of the basic model primitives. Microservices themselves have no general notion of other services beyond interaction, thus it requires an additional layer to manage changeing topologies. Such tools are subsumed in the category of *could management frameworks*. This fundamental difference in the inherent notion of static versus dynamic changes in topology are a major concern when it comes to integrating Actors and Microservice task units, which will be discussed in &#167; [#sec-actor-ms-integration].


---

...

... Actors können erzeugt werden, referenzen können wie normale nachrichten verschickt werden (also dyn reconf.)

.. MS können sich bei discovery service registrieren, die ihre ref. stabil halten, und ihnen selber erlaub sich zu bewegen. message broker tun auch was

~important
Die beiden ansätze vielleicht kurz in den jeweiligen Impl. kapiteln erklären, und hier nur zusammenfassen. Actors haben eh ch "Clustering and Mobility" und MS "Service discovery"
~

Elasticity:
 
~LitNote
* Done in MSA which Cloud Management Framework, all components must support dynamic adding and removing of components (requires Service Discovery, etc.)
* Actors can easily be created and kill by messages. A system must support elastic mechanism itself. question is from which components is this command issues? also a management framework? or is the system this detected by itself. in case of cluster, are new Actors spawned on random node, or some metric for node with most free resources?
    * interessesting are cases for Stores, because DB/Index resources need to be present, and how are they being brought up to current state --> Event sourcing
* IDEE: Ich werde elasticity nur theoretisch unterstützen. 
    * die MS sind an sich darauf vorbereitet, müsste nur eine neue abstraktionsebene hinzugefügt werden (management framework) die das regelt; event sourcing subsystem für stores fehlt
    * Actors impl unterstützt prinzipiell beliebig viele componenten, nur müsste der mechanismus selbst gebaut werden; event sourcing subsystem für das neuaufbauen von directory/index fehlt
* [@Akm90] vergleicht Actors mit CSP und erläutert, dass Actors "permits one to increase the distributivity of computation as it evolves" (= elastic) weil sie neue Actors erzeugen können. CSPs hingegen können nur andere Processe "aktiviere", und sind nicht natürlich elastisch. Wenn ich argumentieren kann das MS auf CSP logik basieren, dann ist das ein gutes Argument. Die Folge ist ja nämlich, dass MSA eine zsätzliche Abstraktion brauchen für Elastizität, nämlich Cloud Management Frameworks.
    * [@Agh85b] beschreibt, das CSP die dynamisch Actor Erzeugungs Semantik "violated", weil die "interconnetion topology of processes" statisch ist --> MS müssen das via Service Discovery Abstraction lösen (wo ebene die Discovery Services statisch sind und weiterleiten)
* "elastic scaling"
~




## Fault tolerance, Resilience and Availability

Fault tolerance:

~LitNote
* "failure isolation"
* [@Myt17] "Handling partial failures in distributed reactive programming"
~

Resilience:

~LitNote
* "ability to heal from failure" - break free from strong coupling of synchron comm.; circuit breakers
* Location transparency, elasticity = "move around in isolation"
* independent failure of components
~

Availability:

~LitNote
* Actors, siehe: [@Agh85b]
~


## Actor Model and Process Calculi

~LitNote
* <https://en.wikipedia.org/wiki/Process_calculus>
* Können MS mit CSP als theoretische Grundlage ihrer Concurrency modelliert werden. Denn später kann ich die Vorteile von Actors gegenüber MS besonders bezüglich Elasticity und Discovery mit anderer Literatur beschreiben. Ich muss die CSP Argumentation nur schon hier einführen. 
* siehe <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
    * scheint weniger CSP, als CCS und pi-calculus zu sein
* *Nancy Lynch and Michael Fischer. On describing the behavior of distributed systems in Semantics of Concurrent Computation. Springer-Verlag. 1979.*
* *Nissim Francez, C.A.R. Hoare, Daniel Lehmann, and Willem de Roever. Semantics of nondetermiism, concurrency, and communication Journal of Computer and System Sciences. December 1979.*
* Für ganz allgemeinen Blabla: *He Jifeng and C.A.R. Hoare. Linking Theories of Concurrency United Nations University International Institute for Software Technology UNU-IIST Report No. 328. July, 2005*
* Asynchronous Sequential Processes (ASP) --> "D. Caromel, L. Henrio, and B. P. Serpette. Asynchronous sequential processes. Inf. Comput., 207(4):459–495, Apr. 2009"
    * [@Kos16] vergleich diese mit Active Objects, nur mit gröberer Granularität
* [@Spe90] The main features CSP are:
    * conlmutrication management by means of input and output commands and the use of channels,
    * the exploitation of parallelism by means of the parallel command, and
    * nondeterminism management by guarded commands.
~

Among the theories of formulating concurrent computation is found a family called *process calculi* or *process algebra*. Such define formal models composed of so-called *processes* which are communicating within the laws and conditions layed out by their theory. Baeten [@Bae05] defines *process* as any kind of *behavior* of a *discrete event system*, such that it is observable through discrete actions. These actions can include interaction with other discrete event systems. Those then have to react to these interactions, and therefore he terms all interacting systems as *reactive systems*, which is the base for parallel and distributed computing. Thus, an approach towards concurrency theory is the path of a process algebra.

Some of these calculi gained considerable prominence, for example Milner's CCS (__C__alculus of __C__ommunicating __S__ystems) [@Mil80] for having been the initial work in this domain, while Hoare's CSP (__C__ommunicating __S__equential __P__rocesses) [@Hoa78] were the first to introduce message passing instead of global variables for process communication. For our considerations, the &pi;-calculus [@Mil92], also by Milner, merits special attention, for it has a notion of process networks, including mobility and dynamic reconfiguration [@Bae05;@Mon97]. 

...

In fact, some more practical approaches to expressing interacting processes, which were also found to be well suited for expressing Microservices, have their theoretic foundation in a process calculus. The Jolie language for example is based on a calculus dedicated to service-orientated computing called *SOCK* [@Gui06], which is in turn inspired by CCS and the &pi;-calculus. This is especially interresting, for the Actor model and process calculi share a long history. Hewitt and Milner published their initial works on the Actor model and CCS in the same year, respectivly 1973. Since then...

...

A most basic argument towards the linkage is the definition of a process in the calculi context given above. It explicitly referes to a notion of behavior, respectively discrete actions. 

... Actor have the intrinsic own notion of behavior together with the models Isolated Turn Principle suffices

...For Microservices we explicitely distinquished between the *engine* and the *behavior*, where the later referes to the "service" an engine offers. Each offered is from a global viewpoint a discrete operation whenever consumed [komisch formuliert, und ka was ich dazu zitieren soll]{.mind}.


...

It is important to realize that there is only one theoretical Actor model with many different implementations (Actor Systems) varying in terms of [???]{.important}, all of which are still founding on one common theoretical model. On the other hand however, there is not one process calculus as a single foundational theory, but a large variaty of calculi instead. All are distinct in some way or another in terms of process traits and communication semantic. Thus, only a specific calculus can be compared to the Actor model at a time in general. Such has been done throughout the literature many times [hier gleich einen haufen zitate?]{.important}. 

... For example...We've found that especially ASP (__A__synchronous __S__equential __P__rocesses) have been discussed in the light of Active Objects [@Kos16].

... Especially the ASP (__A__synchronous __S__equential __P__rocesses) have many similarities with Active Objects as well as another special variant of Actors of the so-called *Communicating Event-Loop* model [@Kos16;@Car04, Car04 könnte ich mir sonst als REF generll ersparen!].

...

...Some calculi have been known to show such similarity to Actors that interoperability has been described in the literature. For example, Montanari and Talcott [@Mon97] demonstrate the coorporation of Actors and agents of the &pi;-calculus.

...

In a classification of concurrency model, Swalens et al. summarize all abstractions avoiding shared memory and using structured message-passing instead as *communicating threads* [@Swa14]. [ja und jetzt...?]{.important}

...

...We refere to [XYZ]{.important} for a detailed introduction on process calculi in general.

...

~LitNote
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi>
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
* Wenn ich es im MS kapitel schaffe mir was zu Process Calculi zu überlegen, gibt es genügend 
* [@Kos16] vergleich Asynchronous Sequential Processes (ASP) mit Active Objects, nur mit gröberer Granularität
* [@Kos16] beschreibt das die sog. "Communicating Event-Loop Actor Model" ähnlichkeiten zu Asynchronous Sequential Processes (ASP) hat
* [@Car04] "Asynchronous and Deterministic Objects"
    * describes implementing ASP as Active Objects
    * "Relying on the active object concept, the ASP model is rather closed to, and was somehow inspired by, the notion of actors [2, 3]."
* [@Agh97] "A foundation for actor computation"
    * beschreibt ebenfalls den zusammenhang von Actors und Process Algebras (pi-calc., ect.), auch in einem historischen context.
* Punt: "Type Specications with Processes" <http://www.complang.tuwien.ac.at/franz/papers/Punt95a>
    * Hier beschreibt er wie er Process Types (was Typen von Processen eines Process Calculus sind) verwendet um das Actor model abzubilden. Dürfte sich sehr eignen!
* Punt. forschte daran wie man mit Prozess Typen (und somit in Process Calculi?) modellieren kann, das zu gewissen Zeiten nur gewissen Nachrichten akzeptiert werden. Das "become" Primitive von Actors kann ebenfalls dazu verwendet werden, um die Menge der Messages die ein Actor gerade verarbeiten kann zu verändern (also die Typen für die eben ein Verhalten definiert ist). Dh das ist im Prinzip das selbe
    * beste quelle? Punt: "State information in statically checked interfaces"    
    * Punt: "Types that reflect changes of object usability"                                             
~

## Design by Contract

~LitNote
* [@Kan12]: "Safe Messaging: Message passing should have call- by-value semantics to avoid sharing state between Actors"
* [@Hoh06] "Programming Without a Call Stack--Event-driven Architectures" (bzgl async communication)
* [@Agh99] describes RPC abstraction on top of actors; and broadcast/multicast/one-to-one-out-of-many communication styles for actors
* [@Kar09] bzgl messaging: "An alternate proposal is to add a type system based on lin- ear types to enable safe, zero-copy messaging [18]. Such a type system is not part of currently available distributions"
* "loose coupling" [@Sal16]
* bzgl REST:
    * see [@Mon16b], section 7, "RESTful services"
* new versions can be gradually introduced into a system [@Mon16a]
* [@Siv99] "The specification of distributed objects: liveness and locality"
    * "The design-by-contract philosophy of software design partitions responsibility for correctness between the caller of a method and the callee. It is the obligation of the caller to establish the proconditions before the method is invoked and it is the obligation of the callee, given these preconditions, to ensure the postconditions when the method terminates"
    * ad pre/postconditions: "Certain subtleties, however, arise tin teir use in dtstributed systems. For example, sunce there may be many concurrent threads of execution, the caller of a method cannot unilaterally guarantee that the required preconditions hold when the method begins executing. Thus phenomenon, termed the precondition paradox, has been neglected by many specification methodologies."
* [@Min17] Jolie has static type checking
~

So far, we've covered concerns both Actors and Microservices in one way or another provide profound practical support for. From here on, we briefly endeavor subjects both concepts offer rather basic capabilities at best yet, although there is potential for sophisticated solutions in theory. Two such concerns we are briefly discussing is static contract analysis [anderes wort? enforcement, restriction] in general, and behavioral types in particular [soll ich da was zitieren?]{.mind}

Already discussed have been capabilities and notions regarding concerns like isolation, decoupling, location transparency, mobility and independent deployment in the respective contexts of Actors and Microservices. All of these facilitate dynamic change in system topology, that is *dynamic reconfiguration* [@Agh90, QUELLE FÜR MS BENÖTIGT!]. One the one hand, new components can simply be added and announced via respective contextual mechanisms. On the other hand, existing components can be replaced, that is *substituted* by others (subtypes). However, any evoltion within such systems must not break the interface compatibility between components, or otherwise the system will break. This raises the question for interface compatibility, and particularly an automated checking for it.

An interface can be generally seens as a contract... [TODO: input, output, etc. pp...]{.important}

~Todo
[@Maz16] "A notable example is the Eiffel programming language [9], incorporating solid principles of OOP within a programming framework coordinated by the idea of design- by-contract, which aims at correctness-by-construction"
~

The *Liskov Substitution Principle* [@Hut16, ODER ORIG SRC?] states that `S` is a subtype of `T` if an incarnation of `T` can be safely replace by any incarnation of `S`, i.e. `S` respects the contract promised by `T`. Thus a component, that is an Actor or Microservice, can be substituted by another if the new component abides the contract of the old, such that the system retains its behavior [@Hut16]. 

### Contract Verification

~LitNote
* [@Pan17] "Verification in the Age of Microservices"
~

Component substitution in Actor Systems can take the most basic form of behavior replacement. As we've pointed out, this primitive does not affect an Actor's address, therefore the instance defined by the new behavior transparently replaces the old. As a result, a new Actor might receive the same kinds of messages as did its predecessor, but fail to provide an appropriate reaction to such through the new behavior. 

In general, reasoning in Actor Systems is hard due to this intrinsic property of Actors to interprete any message at runtime through its behavior, i.e. acceptance and rejection, as well as the resulting effects are dynamic [sollte ich was zitieren - stimmt das überhaupt so wie ich das hier behaupte?!]{.mind}. [Although we've seen approaches like *Akka Typed* to restrict the interfaces of Actors, such are still in an early stage of development and research.]{.important}

...

The same requirement holds for Microservices. Replacing the engine of any service component requires that the service behavior must comply to the substitution principle. When it comes to verifing this, the freedom of the Microservice paradigm to allow heterogenous technologies among services becomes a hindrance.   

Different technologies (programming languages and framework) and communication mechanisms (e.g. REST or AMQP) have different means of support for expressing contracts. There is no guarantee that any kind of compatibility checking tool is even available, yet compatible with a verification toolchain [@Dra17a]. 

An attempt towards a solution can be the utilization of a neutral tool with regard to language and technologies. For example, Apache Thrift [@Sle07] provides an independent format to formulize data types and interface specifications, and then generate static code in various supported languages to be used for implementing communication ports. Such can subsequently serve for applying static type checking regarding well-defined interfaces, however without incorporating channel protocols [@Dra17a].

Of course, this is not possible for dynamically typed languages. For MSAs are often implemented with a mixture of static and dynamic programming languages, the common denominator fallback is often basic informal documentaion in natural language [@Dra17a]. 

~Todo
können irgendwie Preconditions, postconditions, invariants spezifiziert werden?
~

*Invariants*, [dinge die immer halten müssen]{.mind}, are another concern. [TODO explored e.g. in Eiffel, etc]{.mind}

In the intrinsic context of distributed systems, concepts for verification build so far on post facto analysis approaches, e.g. via randomization testing or error log analysis. The later turned out to be promising for asserting liveness of services. For safety properties, Panda et al. [@Pan17] for example proposed a Microservice-specific invariance model called `ucheck` that is capable of detecting violations at runtime, but at the cost of limiting the communication channels within the service architecture to request/reply-styled remote procedure calls.

~ important
Diese ganze Invariant Geschichte könnte ich einfach weglassen. Vor allem ist das eine Paper dazu auch nicht gut...
~

...


Microservices evolved from *Service Oriented Architectures* (SOA), and are thus part of the general *Service Oriented Computing* (SOC) paradigm. In SOA, web services publish(ed) their interface description in a standardized format and discoverable way. Most prominently used is the WSDL (__W__eb __S__ervices __D__escription __L__anguage) format [@Anc16]. However, Microservices tend to [dont do this because it is too complicated, and people like to write simple JSON interfaces instead -- irgendwo hab ich das mal so ähnlich gelesen]{.important}

...

Dedicated programming languages for service-oriented programming like Jolie open up the possibility to check contracts through their clear notion of ["service interfaces"]{.mind}. Thus static type checking, at least among the components written in Jolie, is applicable without breaking with the requirement of open and well defined interfaces [kann ich da was zitieren?]{.mind}.

...

...If such are based in process calculi, already formal definitions, a foundation for formal reasoning is present. Scholars already have endeavored [choreographic programming, blablablablabla etc pp.]{.important} 

...

### Behavioral Types

Guidi and Montesi [@Gui09] define three kinds of interfaces: functional (distinguished by a name, input and output types), work-flow (requireing a valid sequence of interaction) and semantic (offering semantic information about functionality through some onthology). The previous section discussed contracts of the functional kinds, which are rather simple for the only information used to check them is weither the input and output types are compatible. This can be done in general with respect to the substitution principle [citation?]{.mind}.

Actor and Microservice Systems require its components to be interoperable in order to ensure reliability and correctness. The mere compatibility of formally defined interfaces in not incorporating sufficient information in general in order to be able to ensure this for communication-centered concurrent and distributed system components. Message exchange has an influence on internal task unit state, thus a precise message order can be required [@Anc16;@Dra17a]. This is not considered in functional types. However, the mentioned work-flow kind incorporates this into a notion of typization. Such types are generally subsumized as *behavioral types* [@Anc16]. 

...

Active Objects primarily address the problem of contracts for Actors. Their object abstraction provides static inferfaces, such that a compiler can ensure message compatibility [citation?]{.mind}. The changing of behaviour is reflected as a change of the objects internal state. However, as we've seen, Actors may in general alter their behaviour such that they do not always accept the same kinds of messages, i.e. a only a certain sequence of messages is then valid. Intuitively this is somewhat contrary to the static notion of objects the AO abstraction facilitates, for it would mean that their offered methods are not a static set, but may change dynamically depending on their internal state. In theory, it is however possible to alter the type annotation, that is the proxy object, on the client side of an Active Object dynamically, such that method restrictions may occur while method compatibility can still be ensured through a compiler [@Pun01b]. In object-orientation, this characteristic in usually refered to as *nonuniform method availability* [@Hut16]. 

There is a generalization of describing valid method invocation order for objects. Two kinds of notions have been established in the literature. One focusing on introducing very formally defined theoretical models, e.g. based on process calculi, into typization, as do for example *process types* [@Pun95a;@Hut16], and another based on less formally defined ideas summarized as *typestate*. The nonuniform method availability that was just described is a special variant of typestate refered to as *session types* [@Anc16].

...


Due to the nature of Actors and Microservices, these concepts intrinsically allow to define nonuniform interfaces.

...

Behavior type theory concepts seem to be not widely applied in practice yet. Dragoni et al. [@Dra17a] argue that this is because they restrain applicability of services, which is undesired by programmers. 


...

... Behavior types have the potential to prevent safety and liveness issues regarding concurrent execution [@Hut16]

...


~LitNote
* distributed objects as processes, define a behaviour 
    * see [@Bar97]
~

...

~Todo
Eigentlich möchte ich hier auch was zu Actors schreiben. Denn zwar zeigt Akka Typed, dass man static type safe messaging (mit entsprechenden einschränkungen) haben kann, aber laut der Akka doku kann man das den state eines behaviour nicht zur compile time sicherstellen. dort schreibe ich "Actor addresses and behaviors are associated at runtime. This is a fundamentally dynamic property of the theoretical Actor model". 

Allerdings könnten das vll Active Objects? Denn da Franz hat dazu was geschrieben! Das könnte ich dann hier einbauen.
~


...

However, all these approaches towards component contracts still take rather basic information into account. 

... only pre- and postconditions, and to a certain degree invariants.

...

Within the context of Actors, scientific exploration of static constraints on Actor behaviors replacements regarding method availability [hier will ich ein anderes wort, weil "method" nicht wirklich klar ist bzgl Actors]{.mind} has already been done [@Hut16]. The type-bounded behaviors of *Akka Typed* are an experimental approach towards this concept.

...

*Akka Typed* demonstrates how a certain degree of static type safety can be introduced through the Actor addresses. However, it takes a rather rigid approach, by simply defining a most basic supertype of all messages through a type parameter, and forbidding the behavior to change such that messages of this type could not be understood anymore.

...

WSDL was mentions as an interface description format. However, it merely expresses static information, and does not incorporate work-flow details [@Mon16b]. More sophisticated standards provide the expression towards behaviors contracts, e.g. WS-BPEL (__W__eb __S__ervice - __B__usiness __P__rocess __E__xecution __L__anguage) [@Anc16]. They build upon idea from formal concepts like process calculi, especially CCS and the &pi;-calculus [@Dra17a]. As with WSDL, such have been utilized in the SOA context, but seem to be yet rather neglected in the Microservice domain. We presume this is due to the same complexity and [workload? besseres wort]{.mind} reasons as for WSDL. Once again, we argue for programming language based solutions to overcome thus. In fact, a primary design goal of Jolie was to build upon and extend WSDL interface descriptions and WS-BPEL orchestration, while fixing some of their formal semantics ambiguities [@Anc16;@Mon14].

An alternative approach towards verifying composition is to migrate from the single component focus regarding behavior (orchestration) to a global viewpoint. High-level definitions called *choreographies* are used to coordinate otherwise autonomous components [@Anc16]. The choreography itself is a syntactic specification of the communication among parties within a system. Based on these specifications, component implementations are then generated such that they are correct-by-construction. This facilitates a paradigm called *Choreographic Programming*. It is still in its early stages, but we've found promising work towards an integration into the Microservice context [@Dra17a;@Mon13].

For a more detailed overview of behavioral contracts we refere the interrested reader to Hüttel et al. [@Hut16] and Ancona et al. [@Anc16].

## Performance Evaluation

~red
delete this section, but maybe incorporate some of the stuff somewhere else?
~

~LitNote
* [@Gri17] "Performance Evaluation Of Massively Distributed Microservices Based Applications"
* [@Ros16] "Profiling actor utilization and communication in Akka"
~


Software Quality Attributes:

~LitNote
SOA qual. attr.

* Performance
* Scalability
* Availability
* Modifiability
* Development distributability (???)
* Deployability
* Portability (Mobility?)
~

Internal Quality Metrics:

~LitNote
Coupling metrics, cohesion metrics, granularity metrics, complexity metrics, autonomy metrics, reusability metrics
~
