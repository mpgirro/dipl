
Discussion
==========

<!-- of Actors and Microservices -->

~ Epigraph { caption: "Pamela Zave"}
The purpose of software engineering is to control complexity, not to create it.
~

~LitNote
* [@Agh99] "Actors are similar to sequential objects in that they encapsulate data and procedures"
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
    * "However, the evolution of objects into services, and the relative comparisons, has to be treated carefully since the first focus on encapsulation and information is hidden in a shared-memory scenario, while the second is built on the idea of independent deployment and message-passing."
    * "It is therefore a paradigm shift, where both the paradigms share the common idea of componentization."
* Diskussion: MS behandeln ebenfalls die 3 "foundational issues" die laut [@Agh85b] concurrency modelle lösen sollten
* Weiters zitiert [@Agh85b]: "It is reasonable to expect that large-scale parallel systems will be composed of independently developed and maintained modules. Such systems will be open-ended and continually undergoing change (Hewitt and de Jong 85)."
    * und "Actor languages are intended to provide linguistic support for such open systems" -> dh Actor werden als sprachfeature für das verwendet werden, was MS im prinzip sind.
~

In chapter [#ch-actor-model] and [#ch-microservice-paradigm], we introduced Actors and Microservices separately and focused on their individual concepts. Alert readers will already have spotted conceptual similarities between both approaches. However, as was demonstrated in chapters [#ch-actor-impl] and [#ch-microservice-impl], different solution strategies still have to be applied due to conceptual differences. This chapter brings the ideas together and discusses the similarities their respective concepts share, and the differences that distinguish them. 

First of all however, it must be argued why it is valid to compare a concept of programming concurrency with a software architecture style for distributed systems. The argumentations is fairly simple. Expressing computation with the Actor model yields artefacts - the Actors - which are fit to be executed concurrently. Thus it historically evolved into a model of concurrent computation. 

A Microservice Architectre on the other hand is a composition of processes - the Microservices. The idea that distributed processes can be seen as concurrent constructs is known at least since 1978 from Brinch Hansen [@Han78]. It is no coincidence therefore that the Actor constructs in the Erlang programming language are being called *processes* [citation]{.mind}.

This chapter will therefore dive into the interrelations between concurrent constructs of the Actor kind and system processes flavored by the charcteristics as are dictated by the Microservice paradigm. On this basis, we will be able to discuss weither one of the two approaches is supreme to the other [will ich diesen satz wirklich?]{.mind}.  

## Encapsulation and Isolation {#sec-commonalities-isolation}

~todo
Hier die Sachen von unten als Einführung beschreiben (ohnehin nicht mehr all zu viel übrig)
~

~LitNote
* "promise behaviour via API/protocol" --> design by contract
* [@Kan12] 4 four important semantic properties of our
extension based on Actor systems: encapsulation, fairness, location transparency and mobility [16 --> Actor Frameworks for the JVM Platform: A Comparative Analysis]
* [@Bon17] "This simple fact has huge implications. It means that data can be strongly consistent only within each service but never between serv‐ ices, for which we need to rely on eventual consistency and abandon transactional semantics"
* [@Bon17] "Isolation makes it easier to scale each service, as well as allowing them to be monitored, debugged, and tested independently"
* [@Kni96] "Encapsulation is probably the only feature that is generally agreed to be an indispensable (sine qua non) characteristic of object-oriented languages. Some researchers even consider encapsulation to be the fundamental object-oriented concept and that all other object-oriented mechanisms and approaches exploit encapsulation to various ends ([9]). There also seems to be general agreement on the fact that encapsulation and sharing are incompatible: sharing tends to violate encapsulation while encapsulation tends to prevent sharing."
    * hier muss ich auch noch was zu visibility schreiben, weil ich im actor-solution kapitel schreibe das es hier schon vorgekommen ist!
* MS sind per definition, insofern sie auf shared memory konzepte verzichten, immer perfekt isoliert, durch das OS. Bei Actor müssen die verschiedenen "notions of state" beachtet werden, um eine strong state notion einzuhalten, also preserve local state and transient state, wie es in [@Kni96] beschrieben ist
* [@Kar09] Encapsulation = State Encpasulation + Safe Messaging
    * nach meiner auffassung ist das genau isolation; das sollte ich vll hier anbringen
~

Actor and Microservice semantics rely on a strict separation of component states. This arises the need to ensure that state is conceptually encapsulated within a component and practically isolated from the outside. 

The conceptual need is known from Object Oriented Programming. As Snyder points out, OOP usually offers mechanisms to restrict the access to an objects state by requiring clients to issue requests for the services an object offers in order to get access to or modify the objects state [@Sny93]. These "services" - not to be confused with the concept of a *Microservice* - are what Meyer calls well-defined interfaces, or simply routines, and considers to be a necessity for encapsulation [@Mey97]. 

Both Actors and Microservices define such well-defined interfaces in their own way. For Actors its the sum of messages it understands through its behavior. For Microservices its based on the facilitated communication channels, e.g. the REST interfaces it exposes, or the messages it consumes from a message broker (AMQP queue, Kafka, etc.). Only through these interfaces can the state of an Actor be accesses or modification to it be issued.

Ensuring that state is only accessible through the a components interface, i.e. that it is isolated from any illegal access from the components outside, is rather different for both styles due to their conceptual differences.

...

### Shared and Mutable State

One fundamental characteristic of both Actors and Microservices is their notion of shared state. Summarizing chapter [#ch-actor-model], the Actor model encapsulates state exclusively within an Actor. Therefore it can only be accessed and modified by the Actor itself. Additionally, Actors provide single-threaded semantic while processing messages, i.e. only one message is processed at a time. This eliminates any need for synchronization, for a message has exclusive access to the Actors current state, and thus is free of low-level data races. The Actors state is fully isolated.

On the other hand, such reasoning cannot be done for Microservices in general. The paradigm states nothing about how state has to be handled internally. Depending on the programming paradigm used to implement the service, i.e. multiple objects could have access the same memory location. Furthermore, these state accesses could be executed concurrently, e.g. as a reaction to multiple invocations of the services interface within a short timespan. Microservices do not ensure any kind of single-threaded semantic. This requires synchronization to internal service state.

However, the Microservice paradigm dictates that shared memory *between* services is to be avoided, as are all kinds of shared resources in general. For every service runs within its own system process, avoiding shared memory implies no direct intersection between service process boundries. Typical communication channels satisfying the requirements given in section [#sec-ms-communication] also prevent any form of reference sharing to joined mutable data [citation needed? oder kann ich das als zusammenfassung von schon erklärtem verkaufen?]{.mind}. Such channels tend to provide some sort of message passing (which can also be in a synchronous fashion, e.g. REST), which is designed to transfer information between the different memory spaces of distinct processes [@Les09].

Actors are generally faced with more challenges when it comes to truely ensuring state separation, because the components can exist within the same process boundries. This theoretically allows access to the same memory locations [citation needed, irgendwo bei der OS literatur wird schon was stehen]{.mind}. Depending on the programming paradigm used for implementing the Actors, exposing shared state to others might be very simple and not apparent to the programmer. Especially the imperative style leans on mutable state, thus suffering from the need of applying extra care to preserve the model semantic. The functional paradigm tends to avoid such problems inherently, for behaviour is modeled as a function, and this function is the only mutable state, which may be modified exclusively by the Actor itself. If the Actor model is integrated into the programming language itself, such problems can be avoided by designing appropriate restrictions enforced by the language directly. However, library based Actor implementations in general cannot ensure full isolation by themselves [@Kos16]. Section [#sec-ensuring-actor-isolation] will discuss in detail the specific demands such libraries can pose to the programmer for a given Actor library.


### Persistance {#sec-commonalities-persistance}

The encapsulation and isolation principle of Actors or Microservices has one more important implication for both concepts. For state is exclusive to a single component, each must also take exclusive care if given state is expected to be durable accross the components livetime. This property is usually refered to as *persistence* [kann ich da was zitieren?]{.mind}.

Persisting information can be implemented in many different strategies. Database systems are one well established approach. Sharing a database between two or more components would grant access to one component's persistent state to all others connceted to the same database used. This would not only provide a simple way to skip any isolation mechanisms and bypass the components interface, thus breaking the encapsulation principle. Additionally, it would also open up a form of implicit communication through shared mutable state [hierzu hab ich irgendwo literatur]{.mind}.

The consequence is, that any component must have its very own database, or persistance mechanism in general, if such is required. This restriction has to be taken care of by programmers, for neither an Actor System, nor any Microservice technique can enforce this. Unfortunatelly, this is a rather unintuitive requirement, for database systems have always been design to be accessed and used by multiple components concurrently in general. Database APIs tend to allow that multiple modules (concurrent or not) inside a single program might read from and write to the same database instance, thus it is easy easy in general for multiple Actors too.

Inside a Microservice, this is not a problem. Multiple internal modules may use a database exclusive to the service, as is with any other monolithic application. However, multiple Microservices must not leverage the same database that could be available for both of them. 

This restriction opens up another opportunity however. Monolithic applications tend to rely on as few database systems as possible, for a multitier architecture traditionally has the data access layer at the bottom, and consecutive layers are build relative to it. Thus, any new database system bringt the risk of fundamentally impacting a programs architecture. It is therefore unusual for program modules to have their own persistance layer exclusive to them. However, due to their respective natures, modules based on the Actor abstraction and systems composed of Microservices make it easy to add a persistance layer to accomodate their special requirements. 

This approach on introducing specialized database systems based on respective persistance needs, at the risk of introducing potential redundancies, is sometimes refered to as *polyglott persistance* [citation?]{.mind}.

## Communication

~LitNote
* [@Bac03] beschreibt verschiedene dieser mechanismen, nennt sie aber teilweise anders; trotzdem als quelle verwenden
~

Actors facilitate by definition message passing for component communication [some sources]{.mind}. For Microservices, message passing is too the joint perception for communication style  [source 1, 2, 3]{.mind}. As such, their communication capabilities still deviate.

For any sort of information exchange between two concurrent task units, there are two general modes of communication: *shared state* and *message passing*. The former relates to any form of controlled access and modification to a common memory, while the later strictly prohibits mutuable shared memory and instead relies on communication links used as I/O mechanism by the tasks [@Bac03; @Fel90]

Thus, message passing must occure through a so-called *communication channel*. Such channels transport information from a source to a destination, i.e. a *sender* is writing data to the channel, upon which a *receiver* may read it. Independent of the concrete channel technology, this implies a synchronizing the information, for the event of reading a message can intrinsically only occur *after* it has been sent. In contrast, shared state communication must explicitely define an order of accessing information [@And83].


---

We've identified various forms of information flow in the literature [citation, multiple!]{.mind}

~LitNote
* [@Mon14] Jolie kennt: 
    * (one-way), (request-response), (notification), (solicit-response) == async response?
* [@Gui09] hat die von Jolie
* [@Spe90] "point to point (rendez-vous) or diffusion (broadcast and multicast)""
~

~ center
|------------------|------------------------|-------------------------|
|                  | One-to-One             | One-to-Many             |
+------------------+------------------------+-------------------------+
| **Synchronous**  | Request/response       | -                       |
| -----------------| -----------------------| ------------------------|
| **Asynchronous** | Notification           | Publish/subscribe       |
|                  | Request/async response | Publish/async responses |
|------------------|------------------------|-------------------------|
{  }
~

The by far most prominent example in the literature [referenzen]{.mind} for viable Microservice communication is REST. However, it is merely a representative of the synchronouse one-to-one style. Other [TODO...]{.mind}


## Separation of Concerns and Single Responsibility

Separation of Concerns:

~LitNote
* [@Weg90] "Concepts and Paradigms of Object-Oriented Programming"
    * "Splitting a large task into components is a time-honored method of managing complexity, variously referred to as "divide and conquer" and "separation of concerns"."
~

The strict encapsulation of state offers the opportunity to introduce multiple persistance strategies, without having an impact on the architectural layout. There is a more general concept to describe this form of modularization, called *Separation of Concerns* (SoC).

Having state strictly encapsulated, up to  

---

Single Responsibility:

~LitNote
* Unix philosophy
* [@Bon16]
* [@Bon17] "This idea was later brought into the Object-Oriented Programming community by Robert C. Martin and named the Single Responsibil‐ ity Principle2 (SRP), which states that a class or component should “have only one reason to change"
* "functional separation" [@Sal16]
* single responsibility ist ein gutes beispiel, wieso man exlusive datenbanken gut gebrauchen kann
~

## Cohesion and Coupling

~ important 
TODO

Literatur?
~

## Notions of Concurrency

Both Actors and Microservices are the components that are being executed concurrently within their system architectures. However, both constructs have different notions of concurrency, which is a direct result of the underlying concepts. The following discusses the differences and their implications.

...

~LitNote
Je nachdem ob ich es oben schon erwähnen will, aber [@And83] definiert 3 "main issues of concurrency" (ACHTUNG wörtliches zitat):

1. "how to indicate concurrent execution"
2. "which mode of interprocess communication to use"
3. "which synchronization mechanism to use"

...

Andrews and Schneider argue that there are three main issues regarding the "design of a notation for expressing a concurrent computation" [@And83]: indication of execution, interprocess-communication and synchronization mechanism.

* Any concurrent execution has to be *indicated* in some form (And83). This can be explicit (Threads, etc.) or implicit (bezug nehmend auf Ch2)
* The kind of interprocess communication, i.e. the characteristics of the mechanism
* The approach towards synchronization

Actors as we
~

### Threads, Processes and Tasks

~LitNote
* [@Hal09] Scala Actors: Unifying thread-based and event-based programming
    * "There is an impedance mismatch between message-passing concurrency and virtual machines, such as the JVM. VMs usually map their threads to heavyweight OS processes. Without a lightweight process abstraction, users are often forced to write parts of concurrent applications in an event-driven style which obscures control flow, and increases the burden on the programmer"
    * --> Event Driven Programming Style (also so Callbacks in Java zB) sind Mist, 
* [@Agh91] "Actors as Processes: The representation that we are implementing models actors as light-weight processes and requires the presence of a kernel run-time system on each node."
* Hier kann ich die gesamte Erlang Literatur einbauen, denn die nennen ihre lightweight constructs ja auch *process*
* [@Kar09] beschreibt location transparency bei actors
* [@Swa14] "Towards composable concurrency abstractions"
    * "We classify concurrencymodels that use structured communication in terms of messages, instead of relying on shared memory, as communicating threads."
    * "Often, each thread has only private memory, ensuring that all communication is done via messages."
~

~todo
Processe sind immer "fett", durch das OS; Actors hängen davon ab wie sie umgesetzt sind: Als event-based mit callbacks, mit einem threadpool anstatt jedem Actor seinen eigenen, weil threads ebenfalls fett sind (bei der JVM jeder thread ein process); in Erlang auch "process", was aber light-weight thread speziell durch die BEAM VM
~

Akka Actors are executed on threads, sharing such from 

This is not a requirement. Originally, Scala Actors supported two distinct kinds of defining Actors: the thread-based Actors, similar to the Akka variant, and event-based Actors, a more light-weight but also more limited implementation based on the idea of method callbacks [@Hal09].

Microservices run in their own process. Such are relatively heavyweight




### Concurrency of Components

Actors and Microservices have significantly different notions of concurrency. The Isolated Turn Principle essentially define Actors as single-threaded entities. Only in combination with asynchronous message passing as dictated by the model allows for a concurrent execution of the components. As such, an Actor has no notion of any concurrency at all in general.

However, chapter [#ch-actor-model] discussed the possibility of combining Actors with other abstractions of concurrent computation, as long as these do not break the model semantic. Futures were given as one option. Such abstract a value which will be available at some point in time eventually. Basically they introduce a notion of semi-blocking behaviour [irgendwo hab ich hierfür ein zitat!]{.mind}. Either the value is available when trying to access it, or blocking is the consequence until it is. A third way of handling Futures is possible, which directly defines consecutive computation on the value without blocking, but once it becomes available. 

Thus, Futures have the potential to introduce a notion of concurrent computation inside an Actor. This poses to be problematic though, for it easily allows to violate the Isolated Turn Principle. Section [#sec-actor-solution-concurrency] provides a more detailed discussion in the context of a specific Actor System.

Microservices on the other hand do not face such challenges. They have the basic abstraction of a process. Composed into a system, they form concurrent entities due to their concurrent execution through the operating system, potentially on distributed hardware. Thus, from an external perspective, a service is concurrent on the OS or the network level (or both). 

Their notion of internal concurrency is divergent from Actors however. Though a service also receives messages of some kind via its public API and reacts to them, the flexibility in the design the Microservices paradigm offers, allows to create services that react to multiple messages concurrently. There is no restriction as the Isolated Turn Principle, thus a service may freely have a notion of internal concurrency. A concurrently written service allows e.g. to make a synchronouse call and blocking wait for a reply within the routines code, without blocking as a whole. It can therefore can behave as a concurrently accessible resource within the system. The drawback of this degree of freedom is the set of issues any concurrent resource access inherently has. A basic example is locking. When an Actor processes a message, it is guaranteed to have unqiue access to its internal state, therefore must no handle any locks and can savely assume its state as up to date. When a microservice accesses any kind of internal resource (state), this resource might currently be locked by an internal transaction mechanism, granting read access, but not guaranteeing that the state is actually up to date. [dirty read? irgendwas allgemeines zu locking und read zitieren]{.mind} 

Programming with Microservices does not, unlike Actors, free one from the many hassles of low-level concurrency concerns per se. Depending on the model used, the pains of threads, locks, transactions, coroutines, etc. are still to be dealt with. Howeverm the services size - based on its scope of responsibility - is limiting the complexity of the services internal concurrency considerations relative to the overall systems [citation needed? hab ich da eine? ist ja eigentlich mein eigener beitrag]{.mind}

~ important
Modeling any kind of timing is not a problem within an MS, for it can always simply spawn a threads or something for that. Actors need specialized solutions, as was demonstrated in section [#sec-actor-timeouts].
~ 

### Fair scheduling

~LitNote
* [@Kan12]: Actor model defines fair scheduling that a message is eventually delivered to destination Actor except for its permanent “disability”, and no Actor can be permanently starved
* MS werden vom OS garantiert das der process drankommt, aber die verteilung von messages (zB bei MQ broker) ist sache des verwendeten kanals, daher keine globale garantie
* [@Kar09] beschreibt fair scheduling bei actors
~

Actors are entities inside an Actor System. As such, their scheduling falls to this system. In depends on the execution strategy pursued by the system... [TODO]{.mind}

Actors are passiv components in the sense that they only react to events, i.e. received messages. If an Actor's mailbox is empty, it is not necessary for the system to invoke it, for there is nothing to do for it. This way, an Actor system can greatly reduce processing resource consumption [citation?]{.mind}.

~Todo
Dieses einsparen von rechenleistung bei Actors, dass geht bei Orleans so weit, dass die meisten actors sowieso nur virtuell sind, daher per default zwar offiziell existieren (virtuel), aber keinerlei resourcen brauchen.
~

~Todo
es gibt eine gnaz allgemeine definition von [@Kan12]. ansonsten: Thread vs Event based Actors, VM scheduling wo es teil der sprache ist (Erlang), wie macht das zB Akka und Kilim?
~

For Microservices on the other hand, scheduling is a nonconcern. Any MSA is by definition a composition of system processes, and as such their scheduling is delegated to the operating system(s) these processes are running on. Operating systems tend to pursue a [???]{.mind} scheduling strategy [hab ich hier irgendwas das ich zitieren kann?].

There is one drawback to the lack of scheduling concern in MSA's however. The architecture cannot influence the resource consumption based on a services actual demand. An operating system will always allocate resources towards a process, and thus any service will always stress its hosts processing power on a regular basis, at least to a small amount. This is true even when the service is neither requested nor has active behavior of its own to execute. Such process activations are a simple waste of energy [hab ich da was zu energy consumption?]{.mind}.

~todo
Scheduling von processen in chapter 4.6 von [@Bac03]
~

## Distribution

~LitNote
* Actors und MS ist es an sich egal ob sie lokal oder verteilt ausgeführt werden, beide können dies gut abstrahieren
* [@Reh13] defines requirements on distributed Actors:
    * R1: Distributability: Non-distributed applications must be easy to be migrated to clustered set-ups.
    * R2: API-uniformity: The distribution API must be similar for intra-node as well as inter-node applications
    * R3: Compatibility: An application that works locally on one node should also work distributed in a cluster.
    * R4: Flexibility: Beside Actors that have access to specific hardware, the developer should freely decide which Actor runs on which node of the cluster.
    * R5: Configurability: Simple configuration of the clustering subsystem and the distribution layout.
* [@Kan15] (über distributed/cloud Actors)
    * "There (Actor) distinctive features make it suitable to support distributed memory parallelism, and it has been widely used in many industrial languages such as Erlang[2], Scala [3], Akka [4]"
    * "However, most related works focus on multi-core environment. Neither inter-parallelism or task parallelism can be easy applied in dynamic distributed environment, because Actors distributing over cluster may be- have indeterminable interrelationship, such as uncertain com- munication, dependency and failure"
* [@Kan12] (über distributed Actors)
    * Computers connect by network, which makes the environment distributed, disparate, mutable and unreliable
    * According to classifications of parallel programming models in process interaction, mechanisms of which make the parallel processes able to communication with each other, the most common forms of interaction are shared memory, message passing, and implicit [4]
    * In Actor model, location transparency means the actual location of an Actor does not affect its name. That is to say, if one Actor knows another, they can communicate only by names instead of specific address --> kommunikating via ActorRef instead of pointer; bei MS muss das zB für REST extra ein Service Discovery übernehmen, der dies abstrahiert; 
    * Obviously, State encapsulation is a desirable consequence of location transparency. Location transparency facilitates runtime migration of our computing elements to different nodes, which brings good mobility. Moreover, migration enables runtime optimizations for load-balance and fault-tolerance
* [@Fel90] "Language and System Support for Concurrent Programming"
    * beschreibt das Message passing ganz prinzipiell nicht davon abhängig ist, wo die beteiligten componenten sind (im gegensatz zu shared variables/memory)
~

Distribution is decoupled execution in space [citation - Boner]{.mind}. As we've already motivated, any space-decoupled concurrent execution is inherently parallel. In the same context it was stated that relatively local parallelism is called intra-node parallelism, while actually distributed parallelism is called inter-node.

---

Communication via message passing has one fundamental property: no memory is shared between the communicating components. Though we will see later, that this semantic can actually be violated due to implementational hazards used for passing messages, conceptionally it does not require that the components are within the same memory space. Thus, it does not matter weither they run on the same processor, different cores or even the same host machine [@Fel90]. In short, message passing allows for distribution. 

The Actor model intrinsically builds upon message passing to share state information between Actors. Additionally, Actors are well isolted from each other. Based on these properties, Agha recast the initial notion of Actors in the light of distributed computation [citation? die diss? oder dieses 43 year paper auch noch]{.mind}. 

~Todo
Microservices können auch message passing, aber auch synchrone. Die location transparency kommt entweder von der MOM, oder eben von einem lookup service für die REST endpoints.
~  

### Location Transparency and Mobility


...

Microservices allow for arbitrary communication channels, as long as those conform to the paradigm. Pipes have been stated a a viable example. However, as we've pointed out, such are limited to the memory boundries of a single OS [soll ich da was zitieren? hab ich eh schon 1000 erklärt]{.mind}. Channels operating on network level intrinsically distributed communication mechanisms, which facilitate message passing [@Bar97] and provide a uniform interface for remote as well as local communication [@Spe90].

...

Mobility means changing topologies (brauche was aus dem ich das zitieren kann). Location transparency offers the possibility for topologies of components to change. Such moving is called *mobility*.

---

Mobility:

~LitNote
* Laut jones Bonér folgt mobility aus location transparency
* [@Kan12] (über distributed erlang Actors)
    * Mobility is defined as the ability of processes moving from one node to another. It is classified into two types. Strong Mobility means supporting movement of both code and execution state, while weak mobility only allows movement of code
    * At the system level, mobility is important for load balancing, fault-tolerance and reconfiguration. 
    * [25] = [@Pan94] has shown that mobility is essential for achieving scalable performance.
* [@Fug98] "Understanding Code Mobility"
* [@Agh14] "Actors Programming for the Mobile Cloud"
* [@Car97] "Designing Distributed Applications with Mobile Code Paradigms"
* [@Kar09] beschreibt mobility bei actors
* [@Sal16] "The Evolution of Distributed Systems Towards Microservices Architecture"
    * Keywords: Distributed Systems; Microservices; Mobile Agents; Service Oriented Architecture
    * ad *Mobile Agent*: "An agent is composed of three parts which also take place in travelling: Data, State and Code."
* MS service discovery:
    * see [@Mon16a] for example solutions/implementations/technologies 
* MS: "Location of MS may not be statically known at design time" [@Mon16a]
~

Mobility:

~LitNote
* [@Gui09] "Reasoning About a Service-oriented Programming Paradigm
    * Slave service mobility andMaster service mobility
~

### Distributed Object Abstraction {#sec-distributed-objects}

~LitNote
* Lokation transparency ist super und alles, wenn es richtig gemacht wird. die Verteilten Objekte machen das auch, und führen zu massiven Probleme --> hier hab ich diesen einen Artikel "A Note on Distributed Computing" oder so. An dieser stelle sollte ich diskutieren wieso Actors und MS diese Probleme nicht haben, bzw was zu beachten ist um es zu vermeiden
* [@Siv99] "The specification of distributed objects: liveness and locality"
* [@Wal96] "A Note on Distributed Computing"
* chapter 2.8 in [@Bac03]
~

In object-oriented programming, the overall programs state is partitioned into disjoint sets, each chunk belonging to a distinct object. As Werner pointed out, from a logical point of view, the state is as such distributed [@Weg90]. However, distributed programming has different emphasis of concerns than OOP does. And yet, both architecture styles can be integrated such that objects support pyhsical distribution. The result is called *Distributed Objects* (DO). 

The concept that has been popularized in the 1990s [citation needed]{.mind}. Objects do not have to exists within the same program boundary, but can be distributed across multiple programs and therefore host machines. As such, DO's can be viewed from a process-oriented perspective. We refere to Barrio and Fuente [@Bar97] for a formal definition on modelling objects as processes.  

In terms of programming interface, for every DO a proxy object is created on the client side, which wrappes the method calls to the actual distributed object, which then does not necessarily has to be located within the same program boundry [quelle für den absatz, wiederholung von "program boundry"]{.mind}. This allows for location transparent method calls. Examples of such DOs are Java RMI or CORBA [quelle, richtig?]{.mind}. They seem to share many conceptual similarities that we are discussing here. On the one hand, the design goals of Microservices seem to aim towards the single-purpose, minimal and slim skeleton that distributed objects have compared to full-fletched monolithic applications. On the other hand, their distributed nature inherently leads toward the possibilities of transparent concurrent/parallel execution, like Actors or active objects do. 

However, the abstraction the distributed object concept provides was found to be be "leaky" due to conceptual problem [citation needed - note on distributed computing]{.mind}. The transparent method call they offer is hiding to much context do be able to handle the many faults that come with any distributed programming setup. A simple example: 

~LitNote
* [@Ber14]
    * "In a traditional RPC model (such as Java RMI, CORBA, or WCF) the programmer needs to explicitly bind the virtual reference to the service, usually via an external registry or location service."
~

~Todo
hier das beispiel mit dem 1000 methoden aufrufe für die simme von .getSize()
~

We already discussed the analogies of Actors and microservices to the notion of objects. Now, with these similarities and the fact that Actors (or active objects) and microservices each provide mechanisms for location transparent messaging too, we should discuss weither they qualify as distributed objects themselves. This would mean they face the same problems as DO too. 

#### Actors as Distributed Objects

As with Distributed Object, the Actor model has the potential to address distributed components transparently. Actors use the concept of addresses, which substitute for local interfaces, just like DO proxies. As such, they might allow for different interfaces however. The Erlang programming language famously introduced the style `address ! message` to send a message of arbitrary form to an Actor itentified by a known address [vll was zitieren]{.mind}. Of course, Erlang does not implement object-orientation, and thus accessing state and message passing are strictly separate constructs by design.

However, other Actor systems have adopted this style, e.g. as was done in Scala. There the type system opens up the opportunity to use a punctuation-free syntax to invoke methodson object which take only a single argument, offering an infix notation style[^fn-punctuation-free-call]. Despite an object-oriented context, this allows to use different syntactic constructs for referencing ordinary objects, and addressing Actors, if merely by convention. 

[^fn-punctuation-free-call]: The expression `address ! message`{language:scala} is therefore simply syntactic sugar for `address.!(message)`{language:scala}.

The truely fundamental difference now between addressing an Actor and a Distributed Object is within the dispatch semantic. Actors rely on asynchronous message passing as defined by the basic model primitives. Any asynchronous messaging is decoupled in time [cite Boner]{.mind}. It does not introduce the expectation of an immediate response as could be with a synchronous-styled dispatch, which is essentially what method calls with a return value abstract. Thus, message passing is more loosely coupled than request/reply methods.

Therefore, especially in object-oriented contexts where Actors are implemented as ordinary objects, special care has to be taken in order to avoid any chance to accidentially introduce such tighter coupled public methods. Additionally, Actor systems may intentionally provide higher-level constructs to abstract synchronous communication ontop of asynchronous messaging. Chaper [#ch-actor-solution] will discuss in detail the challenges and approaches in designing Actor interface to prevent problematic abstractions, on the example of a specific Actor System.

In there principles however, we deem that Actors avoid the problematic abstraction of Distributed Objects. 

#### Microservices as Distributed Objects

The method call on a DO proxy object makes it transparent for clients weither a locally available or remote server object is addressed. Within the Microservice paradigm, there is no such abstraction in general. Service-internal interaction within its modules use the standard paradigms of the technology used to implement the service, e.g. calling an object's method, or referencing a function. To issue any external request (despite expecting a reply or not) a respective communication interface has to be issued. Such is dedicated to the communication channel, e.g. a HTTP library or message queue API. Thus, any external interaction should be recognisable to the programmer in general. 

Of course, due to the freedom of the Microservice paradigm, it is possible for any service to utilize a technology that is again abstracting the difference between internal and external interactions transparently. It is in the responsibility of the programmer to select [???-adjektiv]{.mind} frameworks and issue appropriate design desicions. 

An additional argument is the granularity of service interfaces. While objects may provide very fine grained interfaces in general, e.g. to access each of its state variables separately, service tend to have more course grained interfaces. In a Microservices context it is more likely that messages between services do not issue very fine grained operations on the receiving service in general, but instead aggregate more course grained operations relative to the interface granularity. Thus, [???]{.mind}

Therefore, we deem it unlikely for Microservices to suffer from the leaking Distributed Object abstraction.

#### Active Objects as Distributed Objects

We have discussed now weither Actors or Microservices qualify as abstractions of the Distributed Object concept, and came to the conclusion that the risk of being misused as DO's is moderate for both. However, section [#sec-active-objects] introduced another variant of the Actor model that is worth discussing here, for it explicitely capitalises an object-oriented abstraction, just like DO's do: Active Objects.

Section [#sec-active-objects] gave an example of the concurrent semantic the API of Active Objects provide. The method call is separated from the message execution. We demonstrated the behaviour in case of method interfaces with and without return values. Building on the previous example, we define this program:

``` {language:scala}
val fs: List[Fnord] = ... // list of 100 references
var sum = 0
for (f <- fs) {
    sum += f.get()
}
print(sum)
```

The code snippet iterates over all elements and makes a blocking call to retrieve the value. This has two fundamental issues:

1. The programs will block sequentially 100 times, once for each element.
2. If some, or in the worst case all, of the elements are not within the same local boundries but transparently distributed, this will cause up to 100 separate remote procedure calls with as many opportunities of any fault a synchronous network call can result in.

The first issue is a result of bad coding practice. The second issue is based on the same leaky abstraction distributed objects suffer from. The `get()` method could be called without the programmer being aware that it actually offers a result value and therefore will block (though with this particular method name and usage it hopefully is unlikely). Additionally it is not clear weither the dispatched method will execute locally or remotely. The abstraction simply hides too much.

Both issues could be fixed by using the *future type* of message passing for Active Objects that has been introduced. This is done by changing the declaration of `get()` to return a `Future[Int]`{language:scala} instead. In functional languages, handling Futures can be done elegantly if they offer monadic behaviour that fits natural with functional programming styles, e.g. in Scala:

``` {language:scala}
1  Future.sequence(fs.map(_.get))
2    .map(_.sum) 
3    .onComplete {
4       case Success(res) => print(res)
5       case Failure(_)   => print("error")
6    }
```

This is an example where it is efficient to combine other abstractions of concurrent computation that integrate well with the Actor semantic. Line 1 transforms `fs:List[Fnord]`{language:scala} first into a `List[Future[Int]]`{language:scala} and then into a `Future[List[Int]]`{language:scala}. The Actor system's dispatcher can now wait until this `Future`{language:scala} completes without having to block the underlying thread. The call stack starting in line 2 is only applied upon completion, finalizing the intended result. 

However, this argumentation only holds under certain assumptions. As we already mentioned, different Actor Systems have different capabilities. In section [#sec-active-objects] we've stated that class `Fnord`{language:scala} extends some arbitrary `ActiveObject`{language:scala} class, but did not discuss the implications the used implementation would have on the correct behaviour. Assuming `Fnord`{language:scala} is changed to use the concrete Active Object abstraction Akka provides (called `TypedActor`{language:java} for it offers type safty for message passing), the desired non-blocking behaviour actually depends on the `Future`{language:java} used for wrapping the `Int`{language:java} result. Akka supports asynchronous dispatch only for the `scala.concurrent.Future`{language:java} trait. If class `Fnord`{language:java} uses its Java friendly `akka.dispatch.Futures`{language:java} interface, the intended behaviour is guaranteed. However, the standard `java.util.concurrent.Future`{language:java} interface would result in undesired blocking behaviour [@AkkaFuture]. When refering to futures from now on, we will always assume the prior ones (depending on the Akka API binding used).

We see, in general Active Objects have the potential to be used in the same problematic way Distributed Objects are. The methods interface defines the method dispatch semantics. If not used with utmost care, method calls can easily become simple remote procedure calls in a transparent way. This can cause bottlenecks, deadlocks, timeouts due to stacked network latencies, [...]{.mind} and having negative impacts on scalability, [...]{.mind} 

However, the one major benefit of Active as well as Distributed Objects compared to classic Actors and Microservices is their type safety. It is statically known weither a server will be able to understand a request, and respectivly a client may only dispatch messages which are guaranteed to be acceptable [kann ich da was zitieren?]{.mind}. 

### Components per Execution Environment

~LitNote
* [@Kos16] "43 Years of Actors: a Taxonomy of Actor Models and Their Key Properties"
    * Beschreibt ch4.4 "Actors Per Execution Environment"
    * Classic Actors and Processes (Erlang) sind auf dem "level of abstraction" wie objekte in OO, oder abstract data types in FP
    * Active Objects und Communicating Event-Loops sind auf dem level of abstraction von "components" in OO, oder modulen in FP  
~


## Extensibility and Technology Heterogeneity {#sec-technological-heterogeneity}

Extensibility:

~LitNote
* Actors, siehe: [@Agh85b]
* gradual/separate replacement of MS
* substitution and subtyping für Actors
* MS: "new versions can be gradually introduced into a system" [@Mon16a]
* [@Lis88] "Promises: linguistic support for efficient asynchronous procedure calls in distributed systems"
    * describe the concept of Promise for "heterogeneous computing in which programs written in different programming languages, and running under different operating systems on different hardware, can use one another as components over a network"
~

Technology Heterogeneity:

~LitNote
* [@Sub11] demonstrates how Akka can be used not only by Scala/Java binding, but other JVM languages too
* [@New15] Newmann calls it "Technology Heterogeneity"
~

## Governance, Deployment and Autonomy

~Todo
(Partially) Centralized with Actor systems, decentralized with MS (aber was ist mit cloud management frameworks)
~

~Todo
Independent deployment
~

Autonomy:

~LitNote
* [@Bon17] 
    * "Isolation is a prerequisite for autonomy. Only when services are iso‐ lated can they be fully autonomous and make decisions independ‐ ently, act independently, and cooperate and coordinate with others to solve problems"
    * "Working with autonomous services opens up flexibility around ser‐ vice orchestration, workflow management, and collaborative behav‐ ior, as well as scalability, availability, and runtime management, at the cost of putting more thought into well-defined and composable APIs"
* MS: "components can be deployed separately" [@Mon16a]
~

## Scalability and Elasticity

Scalability:

~LitNote
* "Scaling a microservice architecture does not imply a duplication of all its components" [@Mon16a]
~

~Todo
Server and Client Side Load balancing
~

Elasticity:
 
~LitNote
* Done in MSA which Cloud Management Framework, all components must support dynamic adding and removing of components (requires Service Discovery, etc.)
* Actors can easily be created and kill by messages. A system must support elastic mechanism itself. question is from which components is this command issues? also a management framework? or is the system this detected by itself. in case of cluster, are new Actors spawned on random node, or some metric for node with most free resources?
    * interessesting are cases for Stores, because DB/Index resources need to be present, and how are they being brought up to current state --> Event sourcing
* IDEE: Ich werde elasticity nur theoretisch unterstützen. 
    * die MS sind an sich darauf vorbereitet, müsste nur eine neue abstraktionsebene hinzugefügt werden (management framework) die das regelt; event sourcing subsystem für stores fehlt
    * Actors impl unterstützt prinzipiell beliebig viele componenten, nur müsste der mechanismus selbst gebaut werden; event sourcing subsystem für das neuaufbauen von directory/index fehlt
* [@Akm90] vergleicht Actors mit CSP und erläutert, dass Actors "permits one to increase the distributivity of computation as it evolves" (= elastic) weil sie neue Actors erzeugen können. CSPs hingegen können nur andere Processe "aktiviere", und sind nicht natürlich elastisch. Wenn ich argumentieren kann das MS auf CSP logik basieren, dann ist das ein gutes Argument. Die Folge ist ja nämlich, dass MSA eine zsätzliche Abstraktion brauchen für Elastizität, nämlich Cloud Management Frameworks.
    * [@Agh85b] beschreibt, das CSP die dynamisch Actor Erzeugungs Semantik "violated", weil die "interconnetion topology of processes" statisch ist --> MS müssen das via Service Discovery Abstraction lösen (wo ebene die Discovery Services statisch sind und weiterleiten)
* "elastic scaling"
~

## Fault tolerance, Resilience and Availability

Fault tolerance:

~LitNote
* "failure isolation"
* [@Myt17] "Handling partial failures in distributed reactive programming"
~

Resilience:

~LitNote
* "ability to heal from failure" - break free from strong coupling of synchron comm.; circuit breakers
* Location transparency, elasticity = "move around in isolation"
* independent failure of components
~

Availability:

~LitNote
* Actors, siehe: [@Agh85b]
~


## Actor Model and Process Calculi

~LitNote
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi>
* <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
* Wenn ich es im MS kapitel schaffe mir was zu Process Calculi zu überlegen, gibt es genügend 
* [@Kos16] vergleich Asynchronous Sequential Processes (ASP) mit Active Objects, nur mit gröberer Granularität
* [@Kos16] beschreibt das die sog. "Communicating Event-Loop Actor Model" ähnlichkeiten zu Asynchronous Sequential Processes (ASP) hat
* [@Car04] "Asynchronous and Deterministic Objects"
    * describes implementing ASP as Active Objects
    * "Relying on the active object concept, the ASP model is rather closed to, and was somehow inspired by, the notion of actors [2, 3]."
* [@Agh97] "A foundation for actor computation"
    * beschreibt ebenfalls den zusammenhang von Actors und Process Algebras (pi-calc., ect.), auch in einem historischen context.
* Punt: "Type Specications with Processes" <http://www.complang.tuwien.ac.at/franz/papers/Punt95a>
    * Hier beschreibt er wie er Process Types (was Typen von Processen eines Process Calculus sind) verwendet um das Actor model abzubilden. Dürfte sich sehr eignen!
* Punt. forschte daran wie man mit Prozess Typen (und somit in Process Calculi?) modellieren kann, das zu gewissen Zeiten nur gewissen Nachrichten akzeptiert werden. Das "become" Primitive von Actors kann ebenfalls dazu verwendet werden, um die Menge der Messages die ein Actor gerade verarbeiten kann zu verändern (also die Typen für die eben ein Verhalten definiert ist). Dh das ist im Prinzip das selbe
    * beste quelle? Punt: "State information in statically checked interfaces"    
    * Punt: "Types that reflect changes of object usability"                                             
~

In section [#sec-ms-process-calculus] we've motivated why the Microservice paradigm in general has relations to the theories of process calculi. This is especially interresting, for the Actor model and the Process calculi share a long history. Both theoretical approaches have been conceived around the same time in the 1970s. Since then, over time both... [citation]{.mind}

It is important to realize that there is one only theoretical Actor model. Though many implementations of this (the Actor Systems) exist, which vary in terms of [???]{.mind}, they are all based on the same fundamental theoretical model semantic. 
On the other hand, there is not one process calculus, but a large variaty of calculi. All are distinct in terms of component traits and communication semantic. The only really homogenous characteristic is that communication is based on message-passing, rather than on shared memory [citation]{.mind}. They share this trait of isolated state and decoupled information exchange with the Actor model.

In a classification of concurrency model, Swalens et al. summarize all abstractions avoiding shared memory and using structured message-passing instead as *communicating threads* [@Swa14]. In this chapter we've already discussed the commonalities of thread-based and process-based concurrency. [ja und jetzt weiter?...]{.mind}

## Design by Contract

~LitNote
* [@Kan12]: "Safe Messaging: Message passing should have call- by-value semantics to avoid sharing state between Actors"
* [@Hoh06] "Programming Without a Call Stack--Event-driven Architectures" (bzgl async communication)
* [@Agh99] describes RPC abstraction on top of actors; and broadcast/multicast/one-to-one-out-of-many communication styles for actors
* [@Kar09] bzgl messaging: "An alternate proposal is to add a type system based on lin- ear types to enable safe, zero-copy messaging [18]. Such a type system is not part of currently available distributions"
* "loose coupling" [@Sal16]
* bzgl REST:
    * see [@Mon16b], section 7, "RESTful services"
* new versions can be gradually introduced into a system [@Mon16a]
* [@Siv99] "The specification of distributed objects: liveness and locality"
    * "The design-by-contract philosophy of software design partitions responsibility for correctness between the caller of a method and the callee. It is the obligation of the caller to establish the proconditions before the method is invoked and it is the obligation of the callee, given these preconditions, to ensure the postconditions when the method terminates"
    * ad pre/postconditions: "Certain subtleties, however, arise tin teir use in dtstributed systems. For example, sunce there may be many concurrent threads of execution, the caller of a method cannot unilaterally guarantee that the required preconditions hold when the method begins executing. Thus phenomenon, termed the precondition paradox, has been neglected by many specification methodologies."
~

So far, we've covered concerns both Actors and Microservices provide respective approaches for [hä?]{.mind}. However, there are subjects with yet little to no support in either context. One such concern we've found is static contract analysis [anderes wort? enforcement, restriction] in general, and behavioral types in particular [soll ich da was zitieren?]{.mind}

We've already discussed capabilities and notions regarding concerns like isolation, decoupling, location transparency, mobility and independent deployment in the respective contexts of Actors and Microservices. All of these facilitate dynamic change in system topology, that is *dynamic reconfiguration* [@Agh90, QUELLE FÜR MS BENÖTIGT!]. One the one hand, new components can simply be added and announced via respective contextual mechanisms. On the other hand, existing components can be replaced, that is *substituted* by others (subtypes). However, any evoltion within such systems must not break the interface compatibility between components, or otherwise the [system will break...gscheiter formulieren und was zitieren]{.mind}. 

An interface can be generally seens as a contract... [TODO: input, output, etc. pp...]{.important}

The *Liskov Substitution Principle* [@Hut16, ODER ORIG SRC?] states that S is a subtype of T if an incarnation of T can be safely replace by any incarnation of S, i.e. S respects the contract promised by T. Thus a component, that is an Actor or Microservice, can be substituted by another if the new component abides the contract of the old, such that the system retains its behavior [@Hut16]. 

### Contract Verification

~LitNote
* [@Pan17] "Verification in the Age of Microservices"
~

Component substitution in Actor Systems can take the most basic form of behavior replacement. As we've pointed out, this primitive does not affect an Actor's address, therefore the instance defined by the new behavior transparently replaces the old. As a result, a new Actor might receive the same kinds of messages as did its predecessor, but fail to provide an appropriate reaction to such through the new behavior. 

In general, reasoning in Actor Systems is hard due to this intrinsic property of Actors to interprete any message at runtime through its behavior, i.e. acceptance and rejection, as well as the resulting effects are dynamic [sollte ich was zitieren - stimmt das überhaupt so wie ich das hier behaupte?!]{.mind}. [Although we've seen approaches like *Akka Typed* to restrict the interfaces of Actors, such are still in an early stage of development and research.]{.important}

...

The same requirement holds for Microservices. Replacing the engine of any service component requires that the service behavior must comply to the substitution principle. When it comes to verifing this, the freedom of the Microservice paradigm to allow heterogenous technologies among services becomes a hindrance.   

Different technologies (programming languages and framework) and communication mechanisms (e.g. REST or AMQP) have different means of support for expressing contracts. There is no guarantee that any kind of compatibility checking tool is even available, yet compatible with a verification toolchain [@Dra17a]. 

An attempt towards a solution can be the utilization of a neutral tool with regard to language and technologies. For example, Apache Thrift [@Sle07] provides an independent format to formulize data types and interface specifications, and then generate static code in various supported languages to be used for implementing communication ports. Such can subsequently serve for applying static type checking regarding well-defined interfaces, however without incorporating channel protocols [@Dra17a].

Of course, this is not possible for dynamically typed languages. For MSAs are often implemented with a mixture of static and dynamic programming languages, the common denominator fallback is often basic informal documentaion in natural language [@Dra17a]. 

~Todo
können irgendwie Preconditions, postconditions, invariants spezifiziert werden?
~

*Invariants*, [dinge die immer halten müssen]{.mind}, are another concern. [TODO explored e.g. in Eiffel, etc]{.mind}

In the intrinsic context of distributed systems, concepts for verification build so far on post facto analysis approaches, e.g. via randomization testing or error log analysis. For example, Panda et al. [@Pan17] propose a Microservice-specific invariance model called `ucheck` that is capable of detecting violations at runtime, but at the cost of limiting the communication channels within the service architecture to request/reply-styled remote procedure calls.

~ important
Diese ganze Invariant Geschichte könnte ich einfach weglassen. Vor allem ist das eine Paper dazu auch nicht gut...
~

...


Microservices evolved from *Service Oriented Architectures* (SOA), and are thus part of the general *Service Oriented Computing* (SOC) paradigm. In SOA, web services publish(ed) their interface description in a standardized format and discoverable way. Most prominently used is the WSDL (**W**eb **S**ervices **D**escription **L**anguage) format [@Anc16]. However, Microservices tend to [dont do this because it is too complicated, and people like to write simple JSON interfaces instead -- irgendwo hab ich das mal so ähnlich gelesen]{.important}

...

Dedicated programming languages for service-oriented programming like Jolie open up the possibility to check contracts through their clear notion of ["service interfaces"]{.mind}. Thus static type checking, at least among the components written in Jolie, is applicable without breaking with the requirement of open and well defined interfaces [kann ich da was zitieren?]{.mind}.

...

...If such are based in process calculi, already formal definitions, a foundation for formal reasoning is present. Scholars already have endeavored [choreographic programming, blablablablabla etc pp.]{.important} 

...

### Behavioral Types

Guidi and Montesi [@Gui09] define three kinds of interfaces: functional (distinguished by a name, input and output types), work-flow (requireing a valid sequence of interaction) and semantic (offering semantic information about functionality through some onthology). The previous section discussed contracts of the functional kinds, which are rather simple for the only information used to check them is weither the input and output types are compatible. This can be done in general with respect to the substitution principle [citation?]{.mind}.

Actor and Microservice Systems require its components to be interoperable in order to ensure reliability and correctness. The mere compatibility of formally defined interfaces in not incorporating sufficient information in general in order to be able to ensure this for communication-centered concurrent and distributed system components. Message exchange has an influence on internal task unit state, thus a precise message order can be required [@Anc16;@Dra17a]. This is not considered in functional types. However, the mentioned work-flow kind incorporates this into a notion of typization. Such types are generally subsumized as *behavioral types* [@Anc16]. 

...

Active Objects primarily address the problem of contracts for Actors. Their object abstraction provides static inferfaces, such that a compiler can ensure message compatibility [citation?]{.mind}. The changing of behaviour is reflected as a change of the objects internal state. However, as we've seen, Actors may in general alter their behaviour such that they do not always accept the same kinds of messages, i.e. a only a certain sequence of messages is then valid. Intuitively this is somewhat contrary to the static notion of objects the AO abstraction facilitates, for it would mean that their offered methods are not a static set, but may change dynamically depending on their internal state. In theory, it is however possible to alter the type annotation, that is the proxy object, on the client side of an Active Object dynamically, such that method restrictions may occur while method compatibility can still be ensured through a compiler [@Pun01b]. In object-orientation, this characteristic in usually refered to as *nonuniform method availability* [@Hut16]. 



There is a generalization of describing [???]{.important} for objects. Two kinds of notions have been established in the literature. One focusing on introducing process calculi like types into objects, thus sometimes refered to as *process types* [@Pun95a;@Hut16, REF3] ...[stimmt das?!]{.important}, and another based on *typestate*, which summarizes all kinds of typization depending on internal state. The nonuniform method availability that was just described is a special variant of typestate refered to as *session types* [@Anc16].

...


Due to the nature of Actors and Microservices, these concepts intrinsically allow to define nonuniform interfaces.

...

Behavior type theory concepts seem to be not widely applied in practice yet. Dragoni et al. [@Dra17a] argue that this is because they restrain applicability of services, which is undesired by programmers. 


...


~LitNote
* distributed objects as processes, define a behaviour 
    * see [@Bar97]
~

...

~Todo
Eigentlich möchte ich hier auch was zu Actors schreiben. Denn zwar zeigt Akka Typed, dass man static type safe messaging (mit entsprechenden einschränkungen) haben kann, aber laut der Akka doku kann man das den state eines behaviour nicht zur compile time sicherstellen. dort schreibe ich "Actor addresses and behaviors are associated at runtime. This is a fundamentally dynamic property of the theoretical Actor model". 

Allerdings könnten das vll Active Objects? Denn da Franz hat dazu was geschrieben! Das könnte ich dann hier einbauen.
~


...

However, all these approaches towards component contracts still take rather basic information into account. 

... only pre- and postconditions, and to a certain degree invariants.

...

Within the context of Actors, scientific exploration of static constraints on Actor behaviors replacements regarding method availability [hier will ich ein anderes wort, weil "method" nicht wirklich klar ist bzgl Actors]{.mind} has already been done [@Hut16]. The type-bounded behaviors of *Akka Typed* are an experimental approach towards this concept.

...

*Akka Typed* demonstrates how a certain degree of static type safety can be introduced through the Actor addresses. However, it takes a rather rigid approach, by simply defining a most basic supertype of all messages through a type parameter, and forbidding the behavior to change such that messages of this type could not be understood anymore.

...

WSDL was mentions as an interface description format. However, it merely expresses static information, and does not incorporate work-flow details. More sophisticated standards provide the expression towards behaviors contracts, e.g. WS-BPEL (**W**eb **S**ervice - **B**usiness **P**rocess **E**xecution **L**anguage) [@Anc16]. They build upon idea from formal concepts like process calculi, especially CCS [schon irgednwo erklärt?!]{.important} and the &pi;-calculus [@Dra17a]. As with WSDL, such have been utilized in the SOA context, but seem to be yet rather neglected in the Microservice domain. We presume this is due to the same complexity and [workload? besseres wort]{.mind} reasons as for WSDL. Once again, we argue for programming language based solutions to overcome thus. In fact, a primary design goal of Jolie was to build upon and extend WSDL interface descriptions and WS-BPEL orchestration, while fixing some of their formal semantics ambiguities [@Anc16;@Mon14].

An alternative approach towards verifying composition is to migrate from the single component focus regarding behavior (orchestration) to a global viewpoint. High-level definitions called *choreographies* are used to coordinate otherwise autonomous components [@Anc16]. The choreography itself is a syntactic specification of the communication among parties within a system. Based on these specifications, component implementations are then generated such that they are correct-by-construction. This facilitates a paradigm called *Choreographic Programming*. It is still in its early stages, but we've found promising work towards an integration into the Microservice context [@Dra17a;@Mon13].

For a more detailed overview of behavioral contracts we refere the interrested reader to Hüttel et al. [@Hut16] and Ancona et al. [@Anc16].

## Evaluation

~LitNote
* [@Gri17] "Performance Evaluation Of Massively Distributed Microservices Based Applications"
* [@Ros16] "Profiling actor utilization and communication in Akka"
~


### Software Quality Attributes

~LitNote
SOA qual. attr.

* Performance
* Scalability
* Availability
* Modifiability
* Development distributability (???)
* Deployability
* Portability (Mobility?)
~

### Quality Metrics

#### Internal Quality Metrics

~LitNote
Coupling metrics, cohesion metrics, granularity metrics, complexity metrics, autonomy metrics, reusability metrics
~

#### External Quality Metrics

### Performance Measurement

