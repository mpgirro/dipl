[INCLUDE=style/template]

Title        : A crack in the monolith
Subtitle     : Do su ciently concurrent programming languages need microservice architectures?
Author       : Maximilian Irro
Title Footer : 2017
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : thesis
Bib style    : alpha
Cite All     : False

Package      : mathptmx

.LitNote { background-color: yellow }

[TITLE]

[TOC]

<!--
# Danksagung

* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.


-->

# Introduction

## Motivation

## Scope of this Thesis

## Methodology used

## Road Map

# Microservice Architectures

~ LitNote
* <https://martinfowler.com/articles/microservices.html>

* keywords for microservices challenges from [@AAE16]:
  * Communication/Integration (API, REST, sockets, TCP, gateway, circuit breakers, load balancer, proxy)
  * Service discovery (API gateways, etc)
  * Performance ( QoS, performance, SLA, speed, simulation)
  * Fault-tolerance
  * Security
  * Tracing and Logging
  * Application Performance Monitoring
  * Deployment operations
~

## Componentization via Services (geklaut von M.Fowler)

~ TODO
Kapitel vll eher "Evolution of the Components" nennen? Das Service deren Weiterentwicklung sind?
~

## Smart endpoints and dumb pipes (geklaut von M.Fowler)

## API gateways, circuit breakers and discovery

Case study: Hysterix library

Case study: Akka provides a circuit breaker implementation [@MW16]

## Concurrency considerations

~ LitNote
* Microservices sind ja per Design Concurrent, da eigene Programme (Service = Component). Und wenn man MS skaliert (mehrere Instanten gleichzeitig startet) dann ist diese Component auch parallel. Also falls man auf mehreren Maschinen deployed
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@FL17]
~

## Summary

# Concurrency, Distributed Programming and Scalability

## Summary

# Concurrency Concepts


## Actor-based Concurrency

## Dataflow Programming

## Communicating sequential processes

<https://en.wikipedia.org/wiki/Communicating_sequential_processes>

## Summary

# Object Oriented Design Principles vs. Microservice Architectures

* bzgl OOP: siehe <https://sanaulla.info/2008/06/26/cohesion-and-coupling-two-oo-design-principles/>

## Summary

# Concurrency Concepts, Distributed Programming and Microservice Architectures


## Implicit Concurrency through (Framekworks|Inversion of Control)

~ TODO
Über Concurrency die einem zB Spring Framework gibt
~

## MSA and the Unix Philosophy

> Text streams are to Unix tools as messages are to objects in an object-oriented setting

quelle: "Rule of Composition: Design programs to be connected with other programs." <http://catb.org/esr/writings/taoup/html/ch01s06.html#id2877684> (müsste bereits eine ordentliche Literaturreferenz existieren): [Raymond, Eric S. (2003), "1.6.3 Rule of Composition: Design programs to be connected with other programs", The Art of Unix Programming, Addison-Wesley, pp. 15–16, ISBN 978-0-13-142901-7.]

## Summary

# TODO

## Concurrent by Design Objects

> OrcO: Concurrency First Approach on Objects


## Concurrency and Parallelism in Microservice Architectures

MSA per design Concurrent

Wenn Service richtig geschrieben, kann ich diese Scalieren indem von jedem Service entsprechend mehr Instanzen laufen (Parallel). Benötigt natürlich API Gateway um Aufgaben zu verteilen, was aber über den Scope dieser Arbeit hinaus geht.

Dh. MSA sowohl Concurrent wie auch Parallel. MSA lösen also wieder nur Konzepte die auch ProgLang lösen (traditionell eher concurrent als parallel, aber das ist eine Sache der Sprachen).

-> Ergo nur deswegen MSA, weil Sprachen diese Konzepte nicht gut genug umsetzen

-> Tatsächlich ist in traditionellen Sprachen Concurrency noch eher umsetzbar, tatsächlich parallele Ausführung von Teilen (zB Actor == MicroService) sehr schwer, schon gar keine Verteilung im Netzwerk.
  -> könnten hier VMs aushelfen
  -> nennt man das Location-Transparency

## Summary

# Recommendations


# Discussion


# Outlook


# Conclusion

[BIB]

