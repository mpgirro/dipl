[INCLUDE=style/template]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
Title        : Concurrent Programming Languages and Microservice Architectures
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2017
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : thesis
Bib style    : alpha
Cite All     : False

Package      : mathptmx

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             %\epigraphfontsize{\small\itshape}&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <hr />&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { background-color: yellow }

@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : webpaginated.css
  Script*       : webpaginated.js
}
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }



~ Begin HtmlOnly
[TITLE]
~ Begin SidePanel
[TOC]
~ End SidePanel
~ End HtmlOnly
<!-- We open an HTML class here, which we'll need to close at the end -->
~ Begin MainPanel

<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->


# Danksagung { -; toc:clear; }

TODO

<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

# Kurzfassung { -; toc:clear; }

~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~

# Introduction

~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

## Methodology used

## Road Map

# Microservice Architectures

~ Epigraph { caption: "Higgs Boson (2012 -- present)" }
Don't give up on your dreams, keep on sleeping.
~

~ LitNote
* <https://martinfowler.com/articles/microservices.html>

* keywords for microservices challenges from [@AAE16]:
  * Communication/Integration (API, REST, sockets, TCP, gateway, circuit breakers, load balancer, proxy)
  * Service discovery (API gateways, etc)
  * Performance ( QoS, performance, SLA, speed, simulation)
  * Fault-tolerance
  * Security
  * Tracing and Logging
  * Application Performance Monitoring
  * Deployment operations
~

## Componentization via Services (geklaut von M.Fowler)

~ TODO
Kapitel vll eher "Evolution of the Components" nennen? Das Service deren Weiterentwicklung sind?
~

## Smart endpoints and dumb pipes (geklaut von M.Fowler)

## API gateways, circuit breakers and discovery

Case study: Hysterix library

Case study: Akka provides a circuit breaker implementation [@MW16]

## Concurrency considerations

~ LitNote
* Microservices sind ja per Design Concurrent, da eigene Programme (Service = Component). Und wenn man MS skaliert (mehrere Instanten gleichzeitig startet) dann ist diese Component auch parallel. Also falls man auf mehreren Maschinen deployed
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@FL17]
~

## Development, Debugging and Maintenance

~ Epigraph { caption: "Filipe Fortes" }
Debugging is like being the detective in a crime movie where you're also the murderer.
~


## Summary

# Concurrency, Distributed Programming and Scalability

## Summary

# Concurrency Concepts


## Actor-based Concurrency

## Dataflow Programming

## Communicating sequential processes

<https://en.wikipedia.org/wiki/Communicating_sequential_processes>

## Summary

# Object Oriented Design Principles vs. Microservice Architectures

* bzgl OOP: siehe <https://sanaulla.info/2008/06/26/cohesion-and-coupling-two-oo-design-principles/>

## Summary

# Concurrency Concepts, Distributed Programming and Microservice Architectures


## Implicit Concurrency through (Framekworks|Inversion of Control)

~ TODO
Über Concurrency die einem zB Spring Framework gibt
~

## MSA and the Unix Philosophy

> Text streams are to Unix tools as messages are to objects in an object-oriented setting

quelle: "Rule of Composition: Design programs to be connected with other programs." <http://catb.org/esr/writings/taoup/html/ch01s06.html#id2877684> (müsste bereits eine ordentliche Literaturreferenz existieren): [Raymond, Eric S. (2003), "1.6.3 Rule of Composition: Design programs to be connected with other programs", The Art of Unix Programming, Addison-Wesley, pp. 15–16, ISBN 978-0-13-142901-7.]

## Summary

# TODO

## Concurrent by Design Objects

> OrcO: Concurrency First Approach on Objects


## Concurrency and Parallelism in Microservice Architectures

MSA per design Concurrent

Wenn Service richtig geschrieben, kann ich diese Scalieren indem von jedem Service entsprechend mehr Instanzen laufen (Parallel). Benötigt natürlich API Gateway um Aufgaben zu verteilen, was aber über den Scope dieser Arbeit hinaus geht.

Dh. MSA sowohl Concurrent wie auch Parallel. MSA lösen also wieder nur Konzepte die auch ProgLang lösen (traditionell eher concurrent als parallel, aber das ist eine Sache der Sprachen).

-> Ergo nur deswegen MSA, weil Sprachen diese Konzepte nicht gut genug umsetzen

-> Tatsächlich ist in traditionellen Sprachen Concurrency noch eher umsetzbar, tatsächlich parallele Ausführung von Teilen (zB Actor == MicroService) sehr schwer, schon gar keine Verteilung im Netzwerk.
  -> könnten hier VMs aushelfen
  -> nennt man das Location-Transparency

## Summary

# Recommendations


# Discussion


# Outlook

~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

# Conclusion

[BIB]

<!-- TODO glossar, nomenclature, index -->

<!-- We need to close the HTML class we opened right at the top -->
~ End MainPanel
