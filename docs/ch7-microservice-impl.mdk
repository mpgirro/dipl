
Microservice-based Implementation {#ch-microservice-impl}
=================================


~ Epigraph { caption: "Terry Winograd"}
The main activity of programming is not the origination of new independent programs, but in the integration, modification, and explanation of existing ones.
~


This chapter covers a Microservice Architecture approach used to implement the concurrent system outlined in chapter [#ch-scenario]. We will focus our discussion on concerns specific to the Microservice paradigm for meeting the system requirements.

## Service Technology Stack

Dedicated languages for the Service Oriented Programming paradigm seem to be a good choice. However, such are as of yet still at an early stage. Among them, Jolie seems to be the most matured, but it also misses an ecosystem and tool support we are looking for compared to Akka. Therefore we refrained from used it to implement Echo. 

Instead, Microservices are composed using a more traditional technology stack. Java serves as the programming language

Java + Spring Boot Stack for all Services

## Isolation and Persistence

~LitNote
* State + Behaviour, Database (Postgres/Lucene) owning, Spring Thread Pool for DB access
* One DB per MS (e.g. PostgreSQL for directory/catalog) and lucene for index
* PostgreSQL accessed by multiple threads concurrently *within* the MS
~

## Communication Channels

REST, AMQP

Synchronous and Asynchronous Communication

Communication Channels and Service Interfaces

...

...RabbitMQ known from [@Dra17c] (Dustdar/Dragoni paper!)

...

Any form of communication has to happen via an inter-process communication mechanism. Some choices for such mechanism include messaging via a form of network interface like REST (__RE__presentational __S__tate __T__ransfer) or AMQP (__A__dvanced __M__essage __Q__ueue __P__rotocol) 


Channels for distributed communication are more likely to provide options to apply some data operation of their own, which would stress the third requirement on microservice communication channels. [citation needed - außer ich argumentiere hier mehr anstatt einfach zu behaupten, zB über spaces wie XVSM]{.mind} 

~Todo
howto Point to Point, Publish/Subscribe, REST and other lightweight stuff, async kafka (but offers only pub/sub), the case for AMQP/RabbitMQ for async jobs (leightweight, open protocol = polyglot, not like JMS) --> use PubSub/Kafka for DataStores (all stores need to update the data records) and MQ/AMQP for Workers (each job needs to be done by one worker)
~

~LitNote
* beschreiben das MS mehrere total verschiedene interfaces haben können (REST, AMQP)
~

Microservices in general do not face difficulties for realizing different communication styles. Synchronous or asynchronous dispatch has only to be supported by the communication channel used. As was discussed, such channels only have to suffice the ... [bedingingen]{.mind}

---

Synchronous communication is easily implemented using REST principles - that is state transportation between to endpoints using HTTP methods - which complies to the requirements on communication channels for the Microservice paradigm. It is relatively lightweight, immutable and completely open to be used by all kinds of endpoints, therefore as such technologically independent. Due to the nature of the HTTP protocol, REST calls favour a synchronous scenario. Although, it is up to the actual HTTP client technology (library, etc.) used to provide an interface to handle dispatched method calls. The most easy form is the abstraction of simple remote procedure calls, but also more asynchronous Future-based variants are possible (e.g. with the Apache HTTP client library [reference]{.mind})

In general,the full span of an RPC never leaves the scope of a Microservice - unlike with Actors where it can be delegated to an on demand spawned child - and therefore it is completely handled by the initiating service. The dispatch of a new dedicated service is too expensive, and folding the result route is hard with HTTP [wie soll ich den absatz zitieren? oder anders formulieren?]{.mind}. Thus, a service needs to cope with the fact that it blocks internally for each REST call it dispatches. However, due to the freedom the MS paradigm offers, this is usually easy to handle. Using internal service concurrency, the service can be prevented by blocking as a whole, by instead dedicating one of its threads of control handle each RPC. Thus, a service should be able to handle multiple connections at the same time.

In any case, if using REST or some other mechanism, such RPC styled requests always lead to a more tight coupling in contrast to an asynchronous messaging style. The later is also an option for service communication. For message delivery a so-called *message oriented middleware* (MOM) has to be applied. Many options for such are available. However, such messaging technologies often pose as whole middlewares, offering many features usually undesired by the Microservice principles [da muss ich irgendwas zitieren. umbedingt]{.mind}. Special care has to be applied when seleting a technology. 

*Echo:MS* is relying n RabbitMQ [citation]{.mind}

[TODO kann auch für async eingesetzt werden, google REST callbacks]{.mind}

## Data Coupling

~LitNote
No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
~    

From the strict notion of isolation the Microservice paradigm provides follows a high form of cohesion. It is generally agreed upon that cohesion and coupling are contrary. By implications, high cohesion leads to lower coupling [zitieren, da gibts mehrere stellen bei den OOP sachen irgendwo]{.mind}. 

The abstinence from mutable shared memory and the emphasise on open, well defined communication protocols adds to the loosening of coupling. Any open protocol offers good technological heterogenity, as we discussed in section [#sec-technological-heterogeneity]. This requires data to be transmitted in a serialized form, that is readyable by all endpoints [citation needed]{.mind}.

REST-based communication is a good example. Data is transmitted using HTTP, therefore basically plain text. To formalize (de-)serialization, usually an open format is used ontop, e.g. XML, JSON or YAML [citation needed]{.mind}.

Message passing through MOMs is also...

The combination of no shared memory and well-defined serialized data exchange frees Microservice Architectures from the risk of accidentially sharing references to state that introduces the risk of 

~Todo
Im Prinzip verhindert das auch alle formen von Aliasing, was am Franz gefällt, und ich kann darüber auch bei Actors vll etwas schreiben? Nur brauche ich dazu eine Literaturquelle
~   

## Load balancing    

~LitNote
* to be done manually in API gateway, or via MQ, cliend side LB (Ribbon) or server side LB (zB Zuul - was ich (noch?) nicht habe)
~

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * see: load balancing
~

## Service discovery

~LitNote
* Was kann ich hier **allgemein** dazu sagen?; Entkopplung von fixen Adressen (Location Transparency)
* requires Discovery mechanism of clients, Consol (alternativ ZooKeeper, Eureka, etc) 
~

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * see: service discovery
    * "This is typically done with a service discovery tool, either a separate service such as Consul [9],"
~

## Clustering

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * see: clustering 
~

## Fault Tolerance

~LitNote
Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 
~

## Resilience

## Scalability

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * "to enable full scalability. i.e., automation, orchestration, service discovery, load balancing, and clustering"
~

## Mobility

~LitNote
* follows from isolation and location transparency
~

## Elasticity

~LitNote
* benötigt ein (oder in Kombination mehrere) sog. Cloud Management Framework(s)
* Last muss gemessen werden
* MS müssen damit umgehen können dynamisch dem system hinzugefügt oder entfernt zu werden
    * problemlos bei stateless MS workern, insofern isolation + location transparency gegeben ist
    * problematisch bei stateful Actors, konkret bei den stores, weil der state (also DB/Index) auf den aktuellen stand gebracht werden muss --> wie? Event sourcing zB
~

## Deployment (!)

~LitNote
depending on specific need, some sort of cloud management framework (or a combination of more) is required. multiple instances easy with container technology (e.g. Docker), but no guarantee for singleton usage
~

## Availability



## Extensibility

~LitNote
* [@Mon16a]: "New versions of components can be gradually intro- duced in a system, by deploying them side to side with previous versions. This advantage can be incorporated in Continuous Integration"
~

## Configuration, logging, etc

## Performance measurement of Microservices