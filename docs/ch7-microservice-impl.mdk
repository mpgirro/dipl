
Microservice-based Implementation {#ch-microservice-impl}
=================================


~ Epigraph { caption: "Ian Robinson"}
Be of the web, not behind the web.
~


This chapter covers a microservice architecture approach used to implement the concurrent system outlined in Chapter [#ch-scenario]. We will focus our discussion on concerns specific to the Microservice paradigm for meeting the system requirements.


## Service Technology Stack


Service-oriented programming languages seem to be a good choice. Though some are theoretically matured, from a practical point they are as of yet still at an early, prototypical stage. Jolie for example still misses an ecosystem and tool support we are looking for compared to Akka. Therefore, we refrained from using it to implement Echo. 

Instead, microservices are composed using a more traditional technology stack. Java serves as the programming language. Services are based on the *Spring* [@PivotalSpring] framework collection, most notably its *Spring Boot* module for application fundamentals. Additionally, the *Spring Cloud* module collection integrates the Netflix open source stack, which has proven very effective for microservice development in industrial applications [@Car17]. 

Spring is based around the concept of *inversion of control* (IoC). There, programmers can focus on implementing so-called *concerns* of arbitrary nature regarding the application. The actual execution logic of the concerns, i.e.\ the scheduling on a thread-pool, is left to the IoC container. This approach is usually referred to as *dependency injection* [@Wal07]. Conceptually, IoC has a certain resemblance to the execution of actors by an actor system runtime [@Hal06].

As was done with the Actor implementation, attention will be paid to the linguistic support provided by the framework regarding an easy expression of service requirements.


~ todo
mehr?
~


## Internal Service Concurrency


The Paradigm does not dictate any restriction on internal service structure. A service is free to be a concurrent unit internally, and to utilize any concurrency mechanism it sees fit (including actos). 

Echo's services are conceived through the Spring framework and utilize the concurrent programming structure that is provided through its IoC container. Spring uses thread-pools on which concerns, e.g.\ so-called *service*-objects (not to be confused with the microservice itself), are scheduled when an object's method is invoked. This kind of scheduling has resemblance to the event-based semantics of actor systems [@Hal06]. Additionally, software transactions provide synchronization. The programming style used to express transactions is declarative. The `@Transactional` annotation on service-object's methods encloses the method into a transaction. Additionally, the STM is extend to database transactions transparently [@Wal07].

~ todo
mehr?
~


<!-- TODO delete?
## (Data Coupling)

[DIESES UNTERKAPITEL EINFACH WEGLASSEN?]{.red}

~LitNote
No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
~    

From the strict notion of isolation the Microservice paradigm provides follows a high form of cohesion. It is generally agreed upon that cohesion and coupling are contrary. By implications, high cohesion leads to lower coupling [zitieren, da gibts mehrere stellen bei den OOP sachen irgendwo]{.mind}. 

The abstinence from mutable shared memory and the emphasise on open, well defined communication protocols adds to the loosening of coupling. Any open protocol offers good technological heterogenity, as we discussed in section [#sec-technological-heterogeneity]. This requires data to be transmitted in a serialized form, that is readyable by all endpoints [citation needed]{.mind}.

REST-based communication is a good example. Data is transmitted using HTTP, therefore basically plain text. To formalize (de-)serialization, usually an open format is used ontop, e.g.\ XML, JSON or YAML [citation needed]{.mind}.

Message passing through MOMs is also...

The combination of no shared memory and well-defined serialized data exchange frees Microservice Architectures from the risk of accidentially sharing references to state that introduces the risk of 

~Todo
Im Prinzip verhindert das auch alle formen von Aliasing, was am Franz gefällt, und ich kann darüber auch bei Actors vll etwas schreiben? Nur brauche ich dazu eine Literaturquelle
~   
-->


## Isolation and Persistence


Each microservices is by definition instantiated as a system level process. The isolation of services is founded on the strict memory boundaries enforced by the operating system. By convention laid out by the paradigm, services refrain from implementing shared memory sections among them. Synchronization is therefore never required among components. Databases are used for persisting state. By another convention, each service owns its databases exclusively [@Dra17a]. Sharing a persistence mechanism conceptionally relates to sharing state, which introduces an implicit form of shared state communication.

Access to the database is usually supported by the database management systems in a concurrent way. As with actors, concurrent connections increase throughput significantly. The *Spring Data* module offers a good interface as well as a transparent abstraction to interact with the database in a concurrent way [@Wal07]. 

Internally, the IoC container of Spring executes the database interactions on a thread-pool as well, as with most other concerns.

~ todo
Bisi mager das Unterkapitel. Kann ich hier irgendwie "meine eigene Leistung" hervorheben?
~


## Communication Mechanisms


[hab ich diesen blabla nicht schon bei der theory]{.red}

Communication has to happen via an inter-process communication mechanism. Various kinds of interfaces are possible. While communication for actors happens in a uniform way, microservices are in general faced with more challenges. The freedom in the design of services does not dictate any specific communication interface. The only restriction regarding interaction is omitting shared memory between services. Solely relying on message passing mechanism makes services cohesive and loosely coupled.

We've found scholars to give REST (__Re__presentational __S__tate __T__ransfer) as prime (and often sole) example of valid communication channels throughout the literature. However, the author has experienced it to be practical only in certain situations. As REST builds upon synchronous HTTP, it is a good solution for synchronous requirements. Echo uses it for all direct user interaction issued through the Web interface, i.e.\ Catalog exploration (`G` &rightleftarrows; `D`) and running search queries on the index (`G` &rightleftarrows; `S` &rightleftarrows; `I`).

As even Fowler & Lewis [@Fow14] in their original microservice definition point out, other mechanism are applicable as well, as long as they are lightweight and do not apply logic of their own. The information aggregation flow that is building and refreshing the Stores is more predestined for an asynchronous workflow, since no immediate reaction has to occur as a result to accepted message. Therefore, a message queue-like mechanism is desired. JMS (__J__ava __M__essage __S__ervice) [@Cou05] is a prominent example among JVM technologies. However, JMS is also limited *to* the JVM, which contradicts the open and well-defined interface principle of microservices. 

A technology heterogenous message queue standard is required. AMQP (__A__dvanced __M__essage __Q__ueue __P__rotocol) [@AMQP] is an open specification for asynchronous messaging. While JMS only defined the interfaces, AMQP also defines the message format. The advantage is that different implementations are possible and these may be interchanged freely. Various AMQP compatible technologies, so-called *providers*, do exist. Echo is utilizing *RabbitMQ* [@PivotalRabbitMQ], a messaging system has been shown to integrate well in MSAs [@Dra17c]. Message queues conceptually introduce new components into the architecture:

* Message Queues (Q)
  : are (distributed) point-to-point communication channels offering message delivery from a sender to a qualified receiver (possibly unknown to the sender) decoupled in time and space [@Cou05]. 

<!--
~ Figure { #fig-ms-channels; caption: "Microservice communication channels"; width:50%; float:left; margin-right: 1ex; }
![img-ms-channels]
~

[img-ms-channels]: graphics/ms-channels.[pdf,svg,png] "Image about Microservice communication channels" { width: 85%; vertical-align:middle; padding-bottom:1em; }
-->

The queue becomes an intermediate for all asynchronous messages. Senders push messages to the queue, and receivers subsequently pull those messages from the queue. For example, we do not send a message directly from a Web Crawler to a Parser (`W` &rarr; `P`), where the active component is only `W`. Instead, we push it `W` &rarr; `Q` and at some later point the Parser pulls it `P` &larr; `Q`. The active components are therefore `W` and `P`. The queue is merely invoked by other components and performs routing logic internally.

In general, a service can have several different interfaces, based on heterogenous technologies. As a result, this allows the service to provide the *same* functionality on *different* interfaces. In fact, all the messages that Echo's services are consuming from the AMQP queue can also be sent directly to the services via HTTP. All services offer respective REST interfaces. The additional option to invoke service functionality turned out especially useful for testing and debugging purposes. This suggests that it is valuable to maintain different interfaces for production as well as maintenance operations. 


### Programming Abstractions {#src-ms-programming-abstractions}


Linguistic support is provided by Spring in a *declarative programming* style for many communication strategies and mechanisms [@Wal07]. This is particularly interesting as it is not intrinsic to Java's imperative programming concept. However, it can be introduced through *annotations*, such that the framework can apply appropriate behavior. In contrast to annotation processors, where annotations are read by the compiler to influence the compilation process (e.g.\ to generate class implementations), Spring uses *reflection* at runtime, such that deployment configuration may still be applied without requiring recompilation, but at the cost of runtime overhead and the lack of static compatibility checking. 

For example, the information flow `S` &rightleftarrows; `I` is required to be synchronous, thus Echo applies REST communication. Spring provides a binding for *Feign* [@OpenFeign], a library dedicated to annotation-based decorations for Java interfaces, such that clients can consume RESTful endpoints using a dynamic interface implementation. In the examples, such is expressed in `S`  by:

```{language:java}
@FeignClient(name = "index")
public interface IndexClient {
    @GetMapping("/query")
    List<Result> query(@RequestParam("q") String q;
}
```

Calling the `query`{language:java} method on an implementation instance for `IndexClient`{language:java} dispatches the REST call in a blocking fashion, and only then returns with the result. Mapping HTTP body content of the response to domain objects is done transparently (given appropriate XML or JSON serializer are configured with the IoC container), thus any domain object may be used for the method result type.

The request is received by `I` which declares an appropriate endpoint using a similar annotation driven implementation approach: 

```{language:java}
@RestController
public class IndexResource {
    @GetMapping("/query")
    public List<Result> query(@RequestParam("q") String q) {
        // query index for phrase q
    }
}
```

This approach models a remote procedure call between the two components. Calling `query("test")`{language:java} of an `IndexClient`{language:java} in `I` is received by `IndexResource`{language:java} in `S` as a call to its `query(String)`{language:java} method with argument `"test"`{language:java}. The method invocation on the client-side is given through the service's programmer, while on the server-side it is done by the service's inversion of control container when a respective request on its transparently exposed REST interface is registered.

Message queue interaction can be expressed in a similar fashion through dedicated annotations for AMQP insertion and consumption. 


### Circuit Breaker


~LitNote
* Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 
* [@Mon16a] "Circuit Breakers, Discovery, and API Gateways in Microservices"
    * "Akka provides a circuit breaker implementation that supports basic configuration parameters, such as call time- out, failure threshold and reset threshold"
    * "Hystrix is much more flexible and is currently one of the reference so- lutions: it supports rolling statistics, fallback mechanisms, resource control, and control over the states and transitions of circuit breakers"
* [@Car17] "Spring Microservices in Action"
* [@NetflixHysterix]
* [@Fow14, p.12] "Microservices: a definition of this new architectural term"
  * "Synchronous calls considered harmful: ...."
~

~ todo
Circuit breaker sind die am öftesten in der Literatur beschriebene Fault tolerance / Resilience Methode for Microservices. Daher dient eine kurze Illustration an dieser Stelle als Grundlage für die spätere Evaluierung im Vergleich zur Actor fault tolerance. Vor allem bietet Spring auch eine gute linguistische Abstraktionen an, welche auf dem REST Beispiel von oben aufbaut und dieses erweitert.
~

~ todo
Bsp bzgl. Hysterix welches das Feign Bsp oben erweitert
~


### Discovery


Whenever direct communication is required however, the actual address of a recipient has to be known. However, depending on the deployment scenario, this may not be statically available information. Thus, Microservice Architectures applies the concept of *service discovery* known from SOA [@Cou05]. A dedicated service component, the so-called *registry*, is tasked with providing binding information about other services. Only the connection to a registry has to be predefined statically and must be ensured at runtime. Microservices need to register with the registry service, such that they may be discovered by others [@Mon16a]. This service is introduced as a new component into the architecture:

* Discovery Registry (D)
  : ~ todo
    kurze Beschreibung hier einfügen
    ~

The `name` argument of the `@FeignClient` annotation in the example given before relates to the designation that the required units will have registered as. Thus, REST through Feign automatically integrates discovery mechanisms. Examples for service registry technologies are *Consul* [@HashicorpConsul], a standalone registry service solution, and *Eureka* [@NetflixEureka], a module part of Spring Cloud to add registry capabilities to custom applications. Echo supports Consul, but uses a dedicated service based on Eureka by default, as we've found Consul to be very resource consuming in comparison. Eureka however tends to require extensive time for initial discovery and shows this behavior also rarely on refreshes. In the call chain `G` &rarr; `S` &rarr; `I` this can trigger the circuit breaker before discovery is finished, and leads to longer response times for the web interface in any case.

Using discovery mechanism can impact response times of services. If a called service requires to make a request itself before being able to provide an answer (e.g.\ when performing a search query), it can become necessary to lookup the address of the requires service instead. Thus, an additional RPC for registry lookup could be required up to the amount of involved services, i.e.\ `G` &rightleftarrows; `D` to lookup `S`, and `S` &rightleftarrows; `D` to lookup `I`. This dampens the liveness of the initial request flow. 

In contrast, message queue semantic has the major benefit of a sender being able to dispatch a message to the queue without having to know the address of a receiver. This provides a high degree of decoupling as well as a notion of location transparency of sender and receiver. Therefore, no service discovery technology is required when message queue channels are utilized if the queue address is known statically. Otherwise the discovery mechanism could be used too, in order to retrieve it dynamically. 

To ensure that the information in the registry are correct and up to date, a common feature of such services is the conduction of *health checks*, i.e.\ checking if their registrees are actually up and alive [@Dra17c]. 


### Load Balancing {#sec-ms-load-balancing}


The idea of distributing work (*load*) between multiple instances of the same task unit, such that the resources of all instances are optimally utilized and no single unit is overloaded, in order to maximize throughput and minimize response time of the overall system is called *load balancing* (LB) [@Ben90].

There are two directions towards load balancing: server-side and client-side. The former approach requires a supervising entity to distribute work between receiving services, while the later has the sending services distribute the work among its known receivers themselves [@Cou05]. 

Echo's Microservices use *Ribbon* [@NetflixRibbon] for client-side load balancing, which is supported by Spring Cloud. The main reason for preferring Eureka over Consul for service discovery is that Ribbon is able integrate with it, such that a client does not dispatch a message directly to an address obtained from the registry, but instead to a static name that recipients use to register with the discovery service. Ribbon can then balance individual requests directly on the client-side across server instances, as it cooperates with Eureka to maintain a set of valid instances of the respective static name [@Car17]. This name is in fact the `name` argument to the `@FeignClient` annotation of the declarative REST interface, as Ribbon is transparently integrating into Feign upon respective configuration.

In contrast, with server-side load balancing, the recipient selection is not done on the client-side, but by a dedicated balancing server. Spring Could also offers a module for conceiving such as well, called *Zuul* [@NetflixZuul]. Therefore, this approach requires to add a new balancing component to the system architecture:

* Load Balancer (L)
  : [TODO]{.red} are centralized services dedicated to distribute messages between a set of equal instances...

~ todo
noch einen schönen Abschluss(ab)satz
~


## Deployment {#sec-ms-deployment}


~ todo
Hier soll dargelegt werden, wie Microservices eigentlich in die Welt gebracht werden, und welche Herausforderungen dies mit sich bringt.
~

~ todo
Dieses Unterkapitel ist noch sehr unvollständig.
~

~LitNote
* depending on specific need, some sort of cloud management framework (or a combination of more) is required. multiple instances easy with container technology (e.g.\ Docker), but no guarantee for singleton usage
* [@New15] "Building Microservices"
~

As was already mentioned, approaching Microservices at the moment is focused on a deployment view. It is not important *how* services are being implemented, as long as they are composed correctly. Note that this is however not the theoretical notion of *correctness* such that it could be asserted by applying proof techniques, e.g.\ by showing safety and liveness properties, or interface type compatibility, but a mere practical understanding of "executing and interlinking services such that the system works" [andere bezeichnung?]{.red}.

For Microservices, *container* technology has been shown to be a promising approach for deployment. It builds upon....

*Docker* [@Docker] is a prominent example of a container tool. It is especially convenient, for it facilitates 