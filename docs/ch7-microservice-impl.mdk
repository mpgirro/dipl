
Microservice-based Implementation {#ch-microservice-impl}
=================================


~ Epigraph { caption: "Terry Winograd"}
The main activity of programming is not the origination of new independent programs, but in the integration, modification, and explanation of existing ones.
~

~ Epigraph { caption: "Ian Robinson"}
Be of the web, not behind the web.
~


This chapter covers a Microservice Architecture approach used to implement the concurrent system outlined in chapter [#ch-scenario]. We will focus our discussion on concerns specific to the Microservice paradigm for meeting the system requirements.

## Service Technology Stack

Dedicated languages for the Service Oriented Programming paradigm seem to be a good choice. However, though some are theoretically matured, from a practical point they are as of yet still at an early, prototypical stage. Jolie for example still misses an ecosystem and tool support we are looking for compared to Akka. Therefore we refrained from used it to implement Echo. 

Instead, Microservices are composed using a more traditional technology stack. Java serves as the programming language. Services are based on the *Spring*[^fn-spring] framework collection, most noteably its *Spring Boot* module for application fundamentals, and the *Spring Cloud Netflix* modules for Microservice related concerns. Such have been proven very effective for Microservice development in industrial applications [@Car17]. 

[^fn-spring]: <https://spring.io>

Spring is based on the concept of *Inversion of Control* (IoC), such that programmers may focus on implementing certain *concerns* of arbitrary nature regarding the application, and leave their actual execution logic to the IoC container [erklären!]{.red}. This has conceptually a certain resemblance to Actor Systems in general.

...

## Isolation and Persistence

~LitNote
* State + Behaviour, Database (Postgres/Lucene) owning, Spring Thread Pool for DB access
* One DB per MS (e.g. PostgreSQL for directory/catalog) and lucene for index
* PostgreSQL accessed by multiple threads concurrently *within* the MS
~

## Communication Channels

[hab ich diesen blabla nicht schon bei der theory]{.red}

While communication for Actors happens in a uniform way, Microservices are faced with more challenges. The freedom in the design of services does not [vorgeben]{.red} any specific communication interface. The only restriction regarding interaction is the [davon absehen]{.red} of implementing any shared memory between services, thus solely relying on message passing mechanism, as services should aim to be cohesive and losse coupled.

Scholars tend to give REST as a prime (and often sole) example of a valid communicaton channels [quelle 1, 2, 3]{.mind}. We've found it to be practical only in certain situations. As it builds upon synchronous HTTP, it is a good solution for synchronous reqirements. Echo uses it for any direct user interaction issued through the Web interface, i.e. `G` &rightleftarrows; `D` and running search queries via `G` &rightleftarrows; `S` &rightleftarrows; `I`.

As even Fowler and Lewis [@Fow14] in their original Microservice definition point out, other mechanism are applicable as well, as long as they are lightweight and do not apply logic of their own. The information aggregation flow that is building and refreshing the Stores is more predestined for an asynchronous workflow, for no immediate reaction has to occur as a result to [wenn der eine dem nächsten was schickt]{.red}. Therefore, a message queue-like mechanism is desired. JMS (__J__ava __M__essage __S__ervice) is a prominent example for such on the JVM. However, it is also limited *to* the JVM, which contradicts the open and well-defined interface principle of Microservices. 

AMQP (__A__dvanced __M__essage __Q__ueue __P__rotocol) is an independent message queue interface standard [...TODO]{.red}

...

...need to introduce a new component to the architecture:

* Message Queue (Q)
  : [TODO acts as a routing channel]{.red}

The queue becomes an intermediate for all asynchronous messages, where such are pushed to it by senders, and pulled from by receivers. For example, instead of directly sending a message `C` &rarr; `P`, it instead gets pushed `C` &rarr; `Q` and at some later point pulled `P` &larr; `Q`. The active components are thus `C` and `P`, while `Q` performs merely routing logic internally.

...

Various AMQP compatible technologies, so-called *providers*, do exist. Echo is utilizing *RabbitMQ*[^fn-rabbitmq], a rather [slim?]{.red} yet performant implementation written in Erlang.

[^fn-rabbitmq]: <https://www.rabbitmq.com>

As a result, service can have multiple different interfaces, based on heterogenous technologies. In fact, this also allows service to provide the *same* functionality on *different* interfaces. In fact, all the messages that services are consuming from the AMQP queue can also be sent directly to a specific via HTTP, for all services offer respective REST interfaces in order to accept and process these. This turned out especially useful for debugging purposes, and suggests that it could be a [guter ansatz/zielführend sein]{.red} to maintain different interfaces for production as well as maintenance operation. 



...

Synchronous and Asynchronous Communication

Communication Channels and Service Interfaces

...

...RabbitMQ known from [@Dra17c] (Dustdar/Dragoni paper!)

...

Any form of communication has to happen via an inter-process communication mechanism. Some choices for such mechanism include messaging via a form of network interface like REST (__RE__presentational __S__tate __T__ransfer) or AMQP (__A__dvanced __M__essage __Q__ueue __P__rotocol) 


Channels for distributed communication are more likely to provide options to apply some data operation of their own, which would stress the third requirement on microservice communication channels. [citation needed - außer ich argumentiere hier mehr anstatt einfach zu behaupten, zB über spaces wie XVSM]{.mind} 

~Todo
howto Point to Point, Publish/Subscribe, REST and other lightweight stuff, async kafka (but offers only pub/sub), the case for AMQP/RabbitMQ for async jobs (leightweight, open protocol = polyglot, not like JMS) --> use PubSub/Kafka for DataStores (all stores need to update the data records) and MQ/AMQP for Workers (each job needs to be done by one worker)
~

~LitNote
* beschreiben das MS mehrere total verschiedene interfaces haben können (REST, AMQP)
~

~ begin red 

Microservices in general do not face difficulties for realizing different communication styles. Synchronous or asynchronous dispatch has only to be supported by the communication channel used. As was discussed, such channels only have to suffice the ... [bedingingen]{.mind}

---

Synchronous communication is easily implemented using REST principles - that is state transportation between to endpoints using HTTP methods - which complies to the requirements on communication channels for the Microservice paradigm. It is relatively lightweight, immutable and completely open to be used by all kinds of endpoints, therefore as such technologically independent. Due to the nature of the HTTP protocol, REST calls favour a synchronous scenario. Although, it is up to the actual HTTP client technology (library, etc.) used to provide an interface to handle dispatched method calls. The most easy form is the abstraction of simple remote procedure calls, but also more asynchronous Future-based variants are possible (e.g. with the Apache HTTP client library [reference]{.mind})

In general,the full span of an RPC never leaves the scope of a Microservice - unlike with Actors where it can be delegated to an on demand spawned child - and therefore it is completely handled by the initiating service. The dispatch of a new dedicated service is too expensive, and folding the result route is hard with HTTP [wie soll ich den absatz zitieren? oder anders formulieren?]{.mind}. Thus, a service needs to cope with the fact that it blocks internally for each REST call it dispatches. However, due to the freedom the MS paradigm offers, this is usually easy to handle. Using internal service concurrency, the service can be prevented by blocking as a whole, by instead dedicating one of its threads of control handle each RPC. Thus, a service should be able to handle multiple connections at the same time.

In any case, if using REST or some other mechanism, such RPC styled requests always lead to a more tight coupling in contrast to an asynchronous messaging style. The later is also an option for service communication. For message delivery a so-called *message oriented middleware* (MOM) has to be applied. Many options for such are available. However, such messaging technologies often pose as whole middlewares, offering many features usually undesired by the Microservice principles [da muss ich irgendwas zitieren. umbedingt]{.mind}. Special care has to be applied when seleting a technology. 

*Echo:MS* is relying n RabbitMQ [citation]{.mind}

[TODO kann auch für async eingesetzt werden, google REST callbacks]{.mind}

~ end red

## Internal Service concurrency

The Paradigm does not dictate any restriction on internal service structure. As such, a service may be a concurrent unit internally, and is free to utilize any mechanism it sees fit, for example also Actors. 

The *Echo* services are conceived on the Spring Framework, and as such utilize the concurrent programming structure that is provided through its *inversion of control* (IoC) container. Spring provides a thread pool on which conterns called "services" - not to be confuses with the Microservice - are scheduled. As synchronization mechanism software transactions are applied. These `or.spring...@Transactional`

... transactions are extended to database trans. in a transparent.

... uses software transaction (STM)

...uses the default software transactions provided byy the Sprinng framework f

### (Data Coupling)

~LitNote
No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
~    

From the strict notion of isolation the Microservice paradigm provides follows a high form of cohesion. It is generally agreed upon that cohesion and coupling are contrary. By implications, high cohesion leads to lower coupling [zitieren, da gibts mehrere stellen bei den OOP sachen irgendwo]{.mind}. 

The abstinence from mutable shared memory and the emphasise on open, well defined communication protocols adds to the loosening of coupling. Any open protocol offers good technological heterogenity, as we discussed in section [#sec-technological-heterogeneity]. This requires data to be transmitted in a serialized form, that is readyable by all endpoints [citation needed]{.mind}.

REST-based communication is a good example. Data is transmitted using HTTP, therefore basically plain text. To formalize (de-)serialization, usually an open format is used ontop, e.g. XML, JSON or YAML [citation needed]{.mind}.

Message passing through MOMs is also...

The combination of no shared memory and well-defined serialized data exchange frees Microservice Architectures from the risk of accidentially sharing references to state that introduces the risk of 

~Todo
Im Prinzip verhindert das auch alle formen von Aliasing, was am Franz gefällt, und ich kann darüber auch bei Actors vll etwas schreiben? Nur brauche ich dazu eine Literaturquelle
~   

### Service Discovery

Whenever direct communication is required however, the actual address of a recipient has to be known. However, depending on the deployment scenario, this may not be statically available information. Thus, Microservice Architectures apply a concept known from SOA, the so-called *service registry*. A dedicated service (the registry) is tasked with providing binding information about other services. Only the conncetion to a registry has to be predefined statically, and must be ensured at runtime. Microservices need to register with the registry service, such that they may be *discovered* by others [@Mon16a].

As a result, a new component is introduced into the architecture:

* Service Registry (R)
  : [TODO service registry]{.red} are ...

Examples for service registry technologies are Consul[^fn-consul], a standalone registry service solution, and Eureka, a library of the Spring Cloud Netflix collection for easy development of custom implementations. Echo supports Consul, but uses a dedicated service based on Eureka by default, for Concul was found to be a rather computation extensive mechanis. Eureka however tends to require extensive time for initial discovery, and shows this behavior also rarely on refreshes. In the call chain `G` &rarr; `S` &rarr; `I` this can trigger the circuit breaker [wird erst unten beschrieben!]{.red} before discovery is finished, and lead to long response times for the web interface in any case 

[^fn-consul]: <https://www.consul.io>

Using discovery mechanism can impact response times of services. If a called services requires to make a request itself before being able to provide an answer (e.g. when performing a search query), it can become necessary to lookup the address of the requires service instead. Thus, an additional RPC for registry lookup could be required up to the amount of involded services, i.e. `G` &rightleftarrows; `R` and `S` &rightleftarrows; `R` in the example. 

In contrast, message queue semantic has the major benefit of a sender being able to dispatch a message to the queue without having to know the address of a receiver. This provides a high degree of decoupling. Therefore, no service discovery technology is required when message queue channels are utilized, if the queue address is known statically. Otherwise the discovery mechanism could be used too, in order to retrieve it dynamically. 

To ensure that the information in the registry are correct and up to date, a common feature of such services is the conduction of *health checks*, i.e. checking if their registrees are actually up and alive [Dra17c]. 

~LitNote
* Was kann ich hier **allgemein** dazu sagen?; Entkopplung von fixen Adressen (Location Transparency)
* requires Discovery mechanism of clients, Consol (alternativ ZooKeeper, Eureka, etc) 
~

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * see: service discovery
    * "This is typically done with a service discovery tool, either a separate service such as Consul [9],"
~

### Load balancing    

~LitNote
* to be done manually in API gateway, or via MQ, cliend side LB (Ribbon) or server side LB (zB Zuul - was ich (noch?) nicht habe)
~

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * see: load balancing
~

## Clustering

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * see: clustering 
~

## Fault Tolerance

~LitNote
Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 
~

## Resilience

## Scalability

~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * "to enable full scalability. i.e., automation, orchestration, service discovery, load balancing, and clustering"
    * "Service discovery can make use of locality, resolving hostnames to the service instance that is closest to the requester, hereby achieving geographical scala-bility."
~

## Deployment (!)

~LitNote
depending on specific need, some sort of cloud management framework (or a combination of more) is required. multiple instances easy with container technology (e.g. Docker), but no guarantee for singleton usage
~

As was already mentioned, approaching Microservices at the moment is focused on a deployment view. It is not important *how* services are being implemented, as long as they are composed correctly. Note that this is however not the theoretical notion of *correctness* such that it could be asserted by applying proof techniques, e.g. by showing safety and liveness properties, or interface type compatibility, but a mere practical understanding of "executing and interlinking services such that the system works" [andere bezeichnung?]{.red}.

For microservices, *container* technology has been shown to be a promising approach for deployment. It builds upon....

Docker [^fn-docker] is a prominent example of a container tool. It is especially convenient, for it facilitates 

[^fn-docker]: <https://www.docker.com>

## Availability

[weglassen?]{.red}

## Extensibility

~LitNote
* [@Mon16a]: "New versions of components can be gradually intro- duced in a system, by deploying them side to side with previous versions. This advantage can be incorporated in Continuous Integration"
~

## Configuration, logging, etc

[weglassen?]{.red}

## Summary {#microservice-impl-summary}