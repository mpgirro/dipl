
Microservice-based Implementation {#ch-microservice-impl}
=================================


~ Epigraph { caption: "Ian Robinson"}
Be of the web, not behind the web.
~


This chapter covers a Microservice Architecture approach used to implement the concurrent system outlined in chapter [#ch-scenario]. We will focus our discussion on concerns specific to the Microservice paradigm for meeting the system requirements.


## Service Technology Stack


Dedicated languages for the Service Oriented Programming paradigm seem to be a good choice. However, though some are theoretically matured, from a practical point they are as of yet still at an early, prototypical stage. Jolie for example still misses an ecosystem and tool support we are looking for compared to Akka. Therefore we refrained from used it to implement Echo. 

Instead, Microservices are composed using a more traditional technology stack. Java serves as the programming language. Services are based on the *Spring* [@PivotalSpring] framework collection, most noteably its *Spring Boot* module for application fundamentals, and the *Spring Cloud* that integrates the Netflix open source stack, which has proven very effective for Microservice development in industrial applications [@Car17]. 

Spring is based on the concept of *Inversion of Control* (IoC), such that programmers may focus on implementing certain *concerns* of arbitrary nature regarding the application, and leave their actual execution logic to the IoC container [erklären!]{.red}. This has a certain conceptual resemblence to Actor Systems [HAB ICH IRGENDWO EINE QUELLE WO ACTOR SYS. ALS IOC CONTAINER BESCHRIEBEN WERDEN?]{.red}.

...


## Isolation and Persistence


Each Microservices is by definition instantiated as a system level process. As such, their isolation is founded on the strict memory boundries enforced by the operating system. By convention layed out by the paradigm, services refrain from implementing shared memory sections among them. Thus, there is no shared state to be synchronized between them.

Databases are used for persisting state. By another convention, each service owns its databases exclisively [WO STEHT DAS IN DER LIT?]{.red}, for sharing databases conceptionally relates to sharing state, thus an implicit form of shared state communication [kann ich da was zitieren? irgendwo hab ich das doch her]{.red}

Access to the database is usually supported in a concurrent way by the database management system. As with Actors, concurrent connections increase throughput significantly. Spring, more precisely *Spring Data*, offers a good interface as well as a transparent abstraction to interact with the database in a concurrent way. Such interactions are, as is custom with the IoC approach of Spring, executed on a thread pool inside the services process. 


## Communication Channels


[hab ich diesen blabla nicht schon bei der theory]{.red}

Any form of communication has to happen via an inter-process communication mechanism, with various kinds of interfaces. While communication for Actors happens in a uniform way, Microservices are thus faced with more challenges. The freedom in the design of services does not dictate any specific communication interface. The only restriction regarding interaction is omitting any shared memory between services, thus solely relying on message passing mechanism, as services should aim to be cohesive and losely coupled.

Scholars tend to give REST (__RE__presentational __S__tate __T__ransfer) as a prime (and often sole) example of a valid communicaton channels [quelle 1, 2, 3]{.mind}. We've found it to be practical only in certain situations. As it builds upon synchronous HTTP, it is a good solution for synchronous reqirements. Echo uses it for any direct user interaction issued through the Web interface, i.e. `G` &rightleftarrows; `D` and running search queries via `G` &rightleftarrows; `S` &rightleftarrows; `I`.

As even Fowler and Lewis [@Fow14] in their original Microservice definition point out, other mechanism are applicable as well, as long as they are lightweight and do not apply logic of their own. The information aggregation flow that is building and refreshing the Stores is more predestined for an asynchronous workflow, for no immediate reaction has to occur as a result to [wenn der eine dem nächsten was schickt]{.red}. Therefore, a message queue-like mechanism is desired. JMS (__J__ava __M__essage __S__ervice) is a prominent example for JVM technologies. However, it is also limited *to* the JVM, which contradicts the open and well-defined interface principle of Microservices. 

A technology heterogenous message queue standard is required. AMQP [@AMQP] (__A__dvanced __M__essage __Q__ueue __P__rotocol) is an open specification for asynchronous messaging. It defines the message format in contrast to JMS, where only the interfaces are specified. This has the advantage that different implementations are possible that may be interchanged freely [quelle]{.red}. Various of such AMQP compatible technologies, so-called *providers*, do exist. Echo is utilizing *RabbitMQ* [@PivotalRabbitMQ], a messaging system that is complying to AMQP besides other standards, and has been shown to integrate well in Microservice Architectures [@Dra17c]. Such message queue conceptually introduces a new component into the architecture:

* Message Queue (Q)
  : [TODO acts as a routing channel]{.red}

<!--
~ Figure { #fig-ms-channels; caption: "Microservice communication channels"; width:50%; float:left; margin-right: 1ex; }
![img-ms-channels]
~

[img-ms-channels]: graphics/ms-channels.[pdf,svg,png] "Image about Microservice communication channels" { width: 85%; vertical-align:middle; padding-bottom:1em; }
-->

The queue becomes an intermediate for all asynchronous messages, where such are pushed to it by senders, and pulled from by receivers. For example, instead of directly sending a message `C` &rarr; `P`, it instead gets pushed `C` &rarr; `Q` and at some later point pulled `P` &larr; `Q`. The active components are thus `C` and `P`, while `Q` performs merely routing logic internally.

In general, service can have multiple different interfaces, based on heterogenous technologies. As a result, this allows them to also provide the *same* functionality on *different* interfaces. In fact, all the messages that Echo's services are consuming from the AMQP queue can also be sent directly to them via HTTP, for all services offer respective REST interfaces in order to accept and process these. This turned out especially useful for testing and debugging purposes, and suggests that it could be a valuable to maintain different interfaces for production as well as maintenance operations. 

~ red
Channels for distributed communication are more likely to provide options to apply some data operation of their own, which would stress the third requirement on microservice communication channels. [citation needed - außer ich argumentiere hier mehr anstatt einfach zu behaupten, zB über spaces wie XVSM]{.mind} 
~


## Internal Service Concurrency


The Paradigm does not dictate any restriction on internal service structure. As such, a service may be a concurrent unit internally, and is free to utilize any mechanism it sees fit, for example also Actors. 

Echo's services are conceived through the Spring Framework, and as such utilize the concurrent programming structure that is provided through its IoC container. Spring provides a thread pool on which concerns, e.g. so-called *service*-objects (not to be confuses with the Microservice concept), are scheduled. Software transactions are used as synchronization mechanism. These are marked with the `@Transactional` annotation on service-object's methods, and their STMs extend to database transactions transparently.

[TODO mehr? ...]{.red}

<!-- TODO delete?
## (Data Coupling)

[DIESES UNTERKAPITEL EINFACH WEGLASSEN?]{.red}

~LitNote
No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
~    

From the strict notion of isolation the Microservice paradigm provides follows a high form of cohesion. It is generally agreed upon that cohesion and coupling are contrary. By implications, high cohesion leads to lower coupling [zitieren, da gibts mehrere stellen bei den OOP sachen irgendwo]{.mind}. 

The abstinence from mutable shared memory and the emphasise on open, well defined communication protocols adds to the loosening of coupling. Any open protocol offers good technological heterogenity, as we discussed in section [#sec-technological-heterogeneity]. This requires data to be transmitted in a serialized form, that is readyable by all endpoints [citation needed]{.mind}.

REST-based communication is a good example. Data is transmitted using HTTP, therefore basically plain text. To formalize (de-)serialization, usually an open format is used ontop, e.g. XML, JSON or YAML [citation needed]{.mind}.

Message passing through MOMs is also...

The combination of no shared memory and well-defined serialized data exchange frees Microservice Architectures from the risk of accidentially sharing references to state that introduces the risk of 

~Todo
Im Prinzip verhindert das auch alle formen von Aliasing, was am Franz gefällt, und ich kann darüber auch bei Actors vll etwas schreiben? Nur brauche ich dazu eine Literaturquelle
~   
-->


## Discovery


Whenever direct communication is required however, the actual address of a recipient has to be known. However, depending on the deployment scenario, this may not be statically available information. Thus, Microservice Architectures applies the concept of *service discovery* known from SOA. A dedicated service component, the so-called *registry*, is tasked with providing binding information about other services. Only the conncetion to a registry has to be predefined statically, and must be ensured at runtime. Microservices need to register with the registry service, such that they may be discovered by others [@Mon16a]. This service is introduced as a new component into the architecture:

* Discovery Registry (D)
  : [TODO service registry]{.red} are ...

Examples for service registry technologies are Consul [@HashicorpConsul], a standalone registry service solution, and Eureka [@NetflixEureka], a library of Spring Cloud to add registry capabilities to custom applications. Echo supports Consul, but uses a dedicated service based on Eureka by default, for Concul was found to be a rather computation extensive mechanis. Eureka however tends to require extensive time for initial discovery, and shows this behavior also rarely on refreshes. In the call chain `G` &rarr; `S` &rarr; `I` this can trigger the circuit breaker [wird erst unten beschrieben!]{.red} before discovery is finished, and lead to long response times for the web interface in any case 

Using discovery mechanism can impact response times of services. If a called services requires to make a request itself before being able to provide an answer (e.g. when performing a search query), it can become necessary to lookup the address of the requires service instead. Thus, an additional RPC for registry lookup could be required up to the amount of involded services, i.e. `G` &rightleftarrows; `D` to lookup `S`, and `S` &rightleftarrows; `D` to lookup `I`. [hat das einen einfluss auf Liveness?]{.red}

In contrast, message queue semantic has the major benefit of a sender being able to dispatch a message to the queue without having to know the address of a receiver. This provides a high degree of decoupling as well as a notion of location transparency of sender and receiver. Therefore, no service discovery technology is required when message queue channels are utilized, if the queue address is known statically. Otherwise the discovery mechanism could be used too, in order to retrieve it dynamically. 

To ensure that the information in the registry are correct and up to date, a common feature of such services is the conduction of *health checks*, i.e. checking if their registrees are actually up and alive [@Dra17c]. 


## Clustering


~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * see: clustering 
~

## (Fault Tolerance and) Resilience

~LitNote
Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 
~


## Scalability


~LitNote
* [@Dra17c] Dustdar/Dragoni paper!
    * "to enable full scalability. i.e., automation, orchestration, service discovery, load balancing, and clustering"
    * "Service discovery can make use of locality, resolving hostnames to the service instance that is closest to the requester, hereby achieving geographical scala-bility."
~


## Load balancing {#sec-ms-load-balancing}


~ todo
hier teile aus der Eval/Diskus hinauf schieben, sodass unten kürzer wird. 
~

Load Balancing (LB) is the idea of distributing work (the *load*) between multiple instances of the same task unit, such that the resources of all instances are optimally utilized and no single unit is overloaded, in order to maximize throughput and minimize response time of the overall system. [quelle? mehr oder minder aus der wikipedia umformuliert]{.red}

There are two directions towards load balancing: server-side and client-side. The former approach requires a supervising entity to distribute work between receiving services, while the later has the sending services distribute the work among its known receivers themselves [CITATION]{.red}. 

Echo's Microservices use *Ribbon* [@NetflixRibbon] for client-side load balancing, which is supported by Spring Cloud. The main reason for prefering Eureka over Consul for service discovery is that it integrates automatically with Ribbon, such that a client does not dispatch a message directly to the address obtained from the registry, but sends it to an abstract (static) name through Ribbon, which transparently cooperates with Eureka to distribute the work among all these equally [@Car17]. This all happens inside the sending Microservice. 

In contrast, with server-side load balancing, the recipient selection is not done on the client-side, but by a dedicated balancing server. Spring Could also offers a library tool for conceiving such as well, called *Zuul* [@NetflixZuul]. Therefore this approach requires to add a new balancing component to the system architecture:

* Load Balancer (L)
  : [TODO]{.red} are centralized services dedicated to distribute messages between a set of equal instances...

~ todo
noch einen schönen Abschluss(ab)satz
~


## Deployment (!)


~LitNote
depending on specific need, some sort of cloud management framework (or a combination of more) is required. multiple instances easy with container technology (e.g. Docker), but no guarantee for singleton usage
~

As was already mentioned, approaching Microservices at the moment is focused on a deployment view. It is not important *how* services are being implemented, as long as they are composed correctly. Note that this is however not the theoretical notion of *correctness* such that it could be asserted by applying proof techniques, e.g. by showing safety and liveness properties, or interface type compatibility, but a mere practical understanding of "executing and interlinking services such that the system works" [andere bezeichnung?]{.red}.

For microservices, *container* technology has been shown to be a promising approach for deployment. It builds upon....

Docker [@Docker] is a prominent example of a container tool. It is especially convenient, for it facilitates 