
Conclusion
==========

~ Epigraph { caption: "Theodor W. Adorno"}
Weil das was ist sich ändern kann, ist das, was ist, nicht alles.
~

## The Case for Actors

~LitNote
- von der WeAreDevs2018 inspiriert:
  * When taking Part of the System (monolith) out of the System (into a MS), connectivity becomes more important -> Actors allow splitting monolith, without requiring more focus on connectivity because it has a standard unified abstraktion! ... and connectivity/communication interfaces are from my experience kind of the most work of any MS
- easy to write from the ground up
- has to be started as a small programm, and extended one by one (otherwise one gets totally lost in the messages)
- less to do (the Actor framework/middleware does a lot for you), but has to live/work with the particula restrictions
- thread switching within an Actor can get a problem, e.g. with locking (have seen it with lucene)
- obwohl Active Obj. "leider" die selben Probleme wie Distr. Obj. haben, ist genau diese enge Verbindung der Proof of Concept bzgl Technology Heterogenity. Distr Obj varianten erlauben auch Bindings via verschiedene Technologien (zB CORBA), und demonstrieren somit, dass auch die statische - dh zur compile time - garantierte Kompatibilität der Typen von Messages zwischen Objekte über verschiedene Technologie hinaus garaniert werden kann.
  * hier gibts es sicherlich neue Probleme. In den Publikationen vom Franz dürfte dazu einiges stehen! Der hat doch eh ein CORBA Paper zB geschrieben. Und welche das so Act. Obj. Typen teilweise statisch/teilweise dynamisch evaluiert werden.
* [@Tas13] "Why do scala developers mix the actor model with other concurrency models?"
  * "This implies that developers tend to use other ways than remote actors for implementing distributed computations."
~


## The Case for Microservices

~LitNote
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@Fow14]
* MS können gut sein wenn man einen bestehenden Monolithem refaktorisiert und aufspaltet (Literatur benötigt!)
* Jonas Boner beschreibt in einem Youtube Talk und im Podcast, dass MS in für große Unternehmen gut sein können, wo es wichtig ist die Code base aufzuspalten um produktiv zu bleiben
* good to break up large monoliths
* literature on project success, where it says that projects transforming monolith into MSA have a high success chance, while projects starting initially with an MSA tend way more to fail
* freedom to practically do whatever you want (if it works within a monolith, this particual function also works within a smaller program = MS)
* Als Vorteil gegenüber Actors sollte ich herausheben, dass diese es erlauben "explicit" die communication ports zu beschreiben. entnommen aus:
  * [@Gui17] "Erlang and Go do not separate behavior from deployment, and more concretely do not come with explicitly defined ports describing the dependencies and requirements of services"
  * kann ich alternativ auch noch im outlook unten anbringen, wo ich den eh zitiere (die info fehlt jedenfalls noch!)
~

## Empirical Indications

~LitNote
  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refActorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
* [@Has16] "Microservices and Their Design Trade-offs: A Self-Adaptive Roadmap"
  * "Among these problems is finalising the level of granularity of a microservice too early. “Splitting too soon can make things very difficult to reason about. It will likely happen that you (the software architect) will learn in the process. [1]."
  * [@Tai17] "Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation"
* [@Dra17c] "Microservices: Migration of a Mission Critical System"
~

## Integrating Actors and Microservices

~important
Das hier ist relativ frei aus der Hand geschrieben. Hier sollte ich Dinge zitieren, abseits von der Akka-HTTP Dokumentation!
~

In our discussion, we've focused on Actors and Microservices as competing approaches for constructing concurrent systems so far. However, it is worth to entertain the thought of *combining* both concepts instead. 

The Microservice principles allow the services a rather high degree of freedom regarding their communication. REST-based state transfer via HTTP is a popular choice, but e.g. the through an AMQP interface are possible as well. Actors on the other hand are more restricted, for the model semantic requires them to receive *message* constructs in a uniform way. However, by implication this means that different communication channels could be integrated as long as they comply to a homogenous message receiving abstraction.

*Akka HTTP*[citation]{.mind} is part of the Akka library collection. It provides a full client- and server-side HTTP stack ontop of the basic Actor abstraction. Thus, HTTP requests may be received as messages, just like from any other Actor: 

```{language:scala}
override def receive = {
  case SomeMessage(_)                           => // handle message
  case HttpResponse(status, headers, entity, _) => // process response
}
```

For Actors are identified by their unique address, which is specific to a concrete Actor System and not conform to a URI (**U**niform **R**esource **I**dentifier) as is required by HTTP in general, a integration layer between an HTTP-addressable unit and the actual Actor has to be utilized [steht irgendwo am einführungs blabla zu AkkaHTTP]{.mind}. 

Though such receiving is in principle conform to the Actor abstraction, there are certain limits. By implication, HTTP endpoints also do not comply to Actor addresses in general. The standard *send* mechanism through `tell` and `ask` is therefore not applicable to dispatch HTTP requests. An alternative interface is required:

```{language:scala}
Http().singleRequest(HttpRequest(URI(s"http://example.com")
  .withQuery(s"name", s"value"))
  .pipeTo(self)
```

The example uses `pipeTo` to have the integration layer reroute any response as an `HttpResponse`{language:scala} message to the sending Actor (delegation).

We see, not all the basic Actor primitives are suitable to be used outside the Actor abstraction. However, well introduced abstractions like *Akka HTTP* allow Actors to provide Microservice-like *service behavior* to the outside, while simply handling its through its own *Actor behavior*. Thus, communication between Actors and Microservices is possible in principle. This allows to construct systems where tasks are distributed between Actors and Microservices.  

This is not a novel idea however. Chapter [#ch-discussion] already mentioned the theoretical foundation from [@Mon97] for incorporating Actors and agents of the &pi;-calculus. There too, so-called *actor-&pi; coordinators* are used to translate between communication channels, similar to the integration layer of *Akka HTTP*.

This unified approach isn't quite common yet, but technologies are starting to emerge building on this idea. An example is the *Lagom* Framework[^fn-lagom], a reactive microservice system framework built ontop of Akka.

[^fn-lagom]: <https://www.lagomframework.com> 

## Outlook


~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

In this thesis, we've discussed the conceptualities of Actors and Microservices, formulated an argumentation favouring each, and even demonstrated one possibility of integrating both. In this final section, we want to argue a conceptual evolution towards a unification.

For the scope of this thesis, we've found it rather difficult to narrow on the essential characteristics that constitute the Microservice paradigm. We believe this observation to be also reflected in the literature, where we've frequently found authors to tend to fairly short, unilateral or superficial definitions for the sake of an easier and more focused argumentation. For example, REST is by far the most popularly pointed out mechanism of sole communication, without entertaining neither the possibility nor implications of other and especially non request/response channels.

In our opinion this is due to the fact that the Microservice style, although conceived as an aim towards minimalistic components, is on the other hand too allowing in general regarding the options for conceiving each single service of any system. The lack of a more coherent technological context among at least some or even all service components also hinders the introduction of enhancing concepts. Examples like behavioral types, choreographies or means of verification in general have already been discussed. Such would only be possible with greater difficulties and come with restrictions nevertheless. As was motivated, languages dedicated to the Service-Oriented Programming paradigm offer the potential towards overcomming this limitation. Even more, if these languages are based on a process calculus, such open up the potentials of their theoretical properties and possibilities. 

Other authors, like Bonér [@Bon16;@Bon17], are advocating for Microservices following the conceptualities as are outlined by the Actor model. However, it's worth to ask why then not to employ Actors altogether in the first place? As Guidi et al. [@Gui17] point out, general purpose languages utilizing mechanisms that are competing with Microservice concerns, like concurrency and scalability, do not provide a conceptual difference between the behavior of a task unit and the deployment thereof. Neither does a very sophisticated Actor language as Erlang, nor an equally potent framework like Akka. 

It is our believe however, that service oriented programming languages are already fostering components that are following many of the conceptualities of Actors. CAOPLE services for examples are already limited to asynchronous communication [@Xu16]. Yet SOP languages keep the openness of well-defined interfaces, such that interoperability with other technologically heterogenous components is still not restricted. [hier noch dazuschreiben, dass somit die gradual evolution and replacement of components weiterhin erhalten bleibt ("future proof")]{.important}

...As a result, it is our believe that an languages-based solution is worth a [???]{.mind}

... Promising protoypes as Jolie essentially produce constructs that are rather similar to Actors - except that the creation of new components is not an essential primitive. 

...


... evolution of Actors like with Orleans auch möglich

... we don't claim that service-oriented programming languages are the key towards the future, but it is our believe that Actors and Microservices *learning from* each other and *growing closer too* each other are a promising ... [1) unterhosen 2) ? 3) profit]{.important}

~LitNote
Eigentlich Conclusions, aber eher Ausblick (weil sprachfokusiert):

~~ important
* MS paradigm is too allowing in general, too much options to allow the introducation of more sophisticated concepts - e.g. behavioral types, choreographies or verification in general - without great difficulties and some restrictions nevertheless. As we've motivated, dedicated languages to the Service-Oriented Programming paradigm offer the potential towards overcomming this limitation. Even more, if such language is based on a process calculus, it opens up the potentials of the theoretical properties and implications; ... especially if such are based on a process calculus "erschließen weiterer möglichen basierend auf dessen theoretischen eigenschaften"
~~

* SOP languages are focusing/fixing many problems that Actor Systems have (conceptually?), while basically providing the same features (essentially they provide constructs that are rather similar to Actors - except that the creation of new components is not an essential primitive). Major plus is that they allow aim towards open and well-interfaces in general, thus they do not restrict the interoperability with other technology heterogenous components. 
  * [@Gui17]: "However, Erlang and Go do not separate behavior from deployment, and more concretely do not come with explicitly defined ports describing the dependencies and requirements of services"
* Are therefore SOP-languages merely better Actor-based languages? That it are they an evoltion? (sollte ich vielleicht nicht als frage formulieren, sonst muss ich das noch diskutieren; alternativ kann ich ja schlicht andeuten, dass diese oder ein entsprächend ähnliche ansätze das potential haben die actos zu evolutionieren)
  * Bonér schlägt ja das umgekehrte vor, nämlich das MS mehr wie Actors werden sollen. Ich kann ja schreiben das SOP-langs, im princip genau ein schritt in diese richtung sind.

Und auf mehr will ich eigentlich gar nicht hinaus, oder?
~

...

Languages like Jolie demonstrate how (micro-)service oriented computing can be facilitated on a language level. Microservices in general, an Jolie in particular, are having much in common with Actor Systems, as we've described in this thesis. Besides concurrency, concerns like scalability and [???]{.mind} are approached well by matured technologies like Akka or Erlang, on a programming language level [@Gui17]. However, their Actor abstraction prevents them from facilitating multiple communication channels in a uniform way, as was just demonstrated for HTTP. Service-oriented languages on the other hand can integrate multiple channels and their respective protocols in a seamless way. Extending Jolie programs with HTTP is demonstrated in [@Mon16b].

... It is our belief that...

... Bonèr is arguing for an evolution of the Microservice principles towards reactive systems [...die mehr actors ensprechen]{.important}. We've found his arguments to have resemblance to the fundamentals of process algebra theory [...dh er will das die MS sich mehr an so eine theory halten (?) --> Jolie macht ja genau das]{.mind}. ...Languages dedicated to the service-oriented programming paradigm can be an promising approach towards this ...

... Boner schlägt zB vor das Microservices gechrieben werden sollen nach den Actor Prinzipien; schlägt dafür sogar einen komischen Namen vor

... dafür einfach dedizierte sprachen erfinden die beides vereinen

...außerdem sollen sie behavioral types unterstützen...

---

Service oriented programming languages machen erzeugen im prinzip constructe, die eh sehr nahe an actors sind. ich sehe die zukunft daher in einer vermischen aus actors abstraktion und SOP 

---

~LitNote
* Services as First-Class Citizens
* [@Kan15] beschreibt eine distributed Actors in Erlang, mit Erweiterungen:
    * "This new model is designed for representing Cloud applications based on Actors in a deterministic, expressive and scalable way. It can also solve certain categories of problems more productively than original Actor model, and more advantageously in multi-computer ar- chitecture than other deterministic concurrency models such as task parallelism"
    * By introducing distask model, a number of constructs can now be supported. It provides a flexible set of primitives and runtime support to easily write various of distributed applications scaling over a dynamic changeable environment. New capabilities can be summed up for three main points, introduced below:
        * Deterministic Expression: The key powerful expressivity of deterministic concurrency allows programmers to encapsulate complicated communica- tion and synchronization protocols as first-class abstractions
        * Advanced Concurrency in Actors Internal: Internal parallelization, Join Calculus --> **internal parallelization ist genau das was MS mit ihrer internal concurrency auch haben -> das habe ich in einem unterkapitel auch angemerkt. sollte ich auf jeden falls hier zusammenbringen!**
        * Scalability & Fault Tolerance
* [@Gho12] "Programming language impact on the development of distributed systems"
* [@Gui17] "Microservices: A Language-Based Approach"
* [@Cha13]
  * "It applies to concurrency as well as distribution, but has not yet entered the native programming domain. This paper contributes the design of a native actor extension for C++, and the report on a software platform that implements our design for (a) concurrent, (b) distributed, and (c) heterogeneous hardware environments"
  * "Our design includes a lightweight, lock-free, and network-transparent message passing system that is implemented without context switching"
* [@Ber14] "Orleans: Distributed Virtual Actors for Programmability and Scalability"
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
  * "First and foremost, languages that embrace the service-oriented paradigm are needed (instead, for the most part, microservice architectures still use OO lan-guages like Java and Javascript or functional ones)."
* [@Aue94] "High-level language support for programming distributed systems"
  * Beschreibt auch schon wie man auf Language ebene Processe programmiert, mit Ports und Communication und allem, was dann Jolie auch macht.
~

...

~ important
In this thesis, we discussed the new microservices style and quite old principles of concurrent and distributed programming as if they were two competing approaches, and one will eventually emerge victorios. In this chapter, instead of rivalry, want to entertain the though of a unification of both towards a new style of programming. 
One the one hand, we analyzed microservices for their core concepts and found that their natural characteristics implied a high form of isolation. Combined with an asynchronouse communication mechanism, they become highly decoupled and the resulting architecture enjoys the principles of Actor based concurrency combined with the feature of distribution and mobility that agent based systems defined long ago. Yet programming a microservice architecture results in a significant overhead in terms of complexity, maintainability, etc. 
On the other hand, we discussed the classic concurrency model through Actors, and found that if it gets extended by additional concepts, such as it is done in existing implementations today, the resulting artifacts yield similar benefits as the microservice approach to. For these implementations are integrated into many mainstream programming languages, they are naturally available to developers to use without increasing complexity and related software development concerns as microservices architectures do. It seems programming concurrency is still unnatural or at least not loved by programmers. The microservice apporach seems to let them better think and plan the separation of concerns inside their software architecture in a divide an conquer way that concurrency primitives of programming languages do.

On this observaton we want to motivate that it seems to be a good idea to integrate the concepts of the service as a principle component into programming languages (like objects) is a good approach. In fact, this is done in some projects already. As the most promising one, we see Jolie. This approach allows developers to write microservice styled programm architectures in a single codebase, while in principle they write software with and Actor-based concurrency and distribution approach as we discussed in this thesis.

**Und dann noch weiteren blabla, aber das ist doch schon mal ein guter Ansatz das anzugehen, und den Outlook mit diesem Thema doch drinnen zu haben!**   
~

...

~LitNote
* in [@Dra17a] wir im Kapitel "Tomorrow" ein weiter Blick in zukünftige Möglichkeiten gegeben:
  * connecting behavioural types and choreographies to well-known logical models
  * a logical reconstruc- tion of behavioural types in classical linear logic that supports parametric polymorphism [83];
  * type theories for integrating higher-order process models with functional computation [79];
  * initial ideas for algorithms for extracting choreographies from separate service programs [18];
  * a logical characterisation of choreography-based behavioural types [19]; 
  * explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13];
  * formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems;
  * these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics;
~