
Conclusion
==========

~ Epigraph { caption: "Theodor W. Adorno"}
Weil das was ist sich ändern kann, ist das, was ist, nicht alles.
~

## The Case for Actors

~LitNote
- easy to write from the ground up
- has to be started as a small programm, and extended one by one (otherwise one gets totally lost in the messages)
- less to do (the Actor framework/middleware does a lot for you), but has to live/work with the particula restrictions
- thread switching within an Actor can get a problem, e.g. with locking (have seen it with lucene)
- obwohl Active Obj. "leider" die selben Probleme wie Distr. Obj. haben, ist genau diese enge Verbindung der Proof of Concept bzgl Technology Heterogenity. Distr Obj varianten erlauben auch Bindings via verschiedene Technologien (zB CORBA), und demonstrieren somit, dass auch die statische - dh zur compile time - garantierte Kompatibilität der Typen von Messages zwischen Objekte über verschiedene Technologie hinaus garaniert werden kann.
  * hier gibts es sicherlich neue Probleme. In den Publikationen vom Franz dürfte dazu einiges stehen! Der hat doch eh ein CORBA Paper zB geschrieben. Und welche das so Act. Obj. Typen teilweise statisch/teilweise dynamisch evaluiert werden.
* [@Tas13] "Why do scala developers mix the actor model with other concurrency models?"
  * "This implies that developers tend to use other ways than remote actors for implementing distributed computations."
~


## The Case for Microservices

~LitNote
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@Fow14]
* MS können gut sein wenn man einen bestehenden Monolithem refaktorisiert und aufspaltet (Literatur benötigt!)
* Jonas Boner beschreibt in einem Youtube Talk und im Podcast, dass MS in für große Unternehmen gut sein können, wo es wichtig ist die Code base aufzuspalten um produktiv zu bleiben
* good to break up large monoliths
* literature on project success, where it says that projects transforming monolith into MSA have a high success chance, while projects starting initially with an MSA tend way more to fail
* freedom to practically do whatever you want (if it works within a monolith, this particual function also works within a smaller program = MS)
~

## Empirical Indications

~LitNote
  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refActorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
* [@Has16] "Microservices and Their Design Trade-offs: A Self-Adaptive Roadmap"
  * "Among these problems is finalising the level of granularity of a microservice too early. “Splitting too soon can make things very difficult to reason about. It will likely happen that you (the software architect) will learn in the process. [1]."
  * [@Tai17] "Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation"
~

## Integrating Actors and Microservices

~important
Das hier ist relativ frei aus der Hand geschrieben. Hier sollte ich Dinge zitieren, abseits von der Akka-HTTP Dokumentation!
~

In our discussion, we've focused on Actors and Microservices as competing approaches for constructing concurrent systems so far. However, it is worth to entertain the thought of *combining* both concepts instead. 

The Microservice principles allow the services a rather high degree of freedom regarding their communication. REST-based state transfer via HTTP is a popular choice, but e.g. the through an AMQP interface are possible as well. Actors on the other hand are more restricted, for the model semantic requires them to receive *message* constructs in a uniform way. However, by implication this means that different communication channels could be integrated as long as they comply to a homogenous message receiving abstraction.

*Akka HTTP* is part of the Akka library collection. It provides a full client- and server-side HTTP stack ontop of the basic Actor abstraction. Thus, HTTP requests may be received as messages, just like from any other Actor: 

```{language:scala}
override def receive = {
  case SomeMessage(_)                           => // handle message
  case HttpResponse(status, headers, entity, _) => // process response
}
```

For Actors are identified by their unique address, which is specific to a concrete Actor System and not conform to a URI (**U**niform **R**esource **I**dentifier) as is required by HTTP in general, a integration layer between an HTTP-addressable unit and the actual Actor has to be utilized [steht irgendwo am einführungs blabla zu AkkaHTTP]{.mind}. 

Though such receiving is in principle conform to the Actor abstraction, there are certain limits. By implication, HTTP endpoints also do not comply to Actor addresses in general. The standard *send* mechanism through `tell` and `ask` is therefore not applicable to dispatch HTTP requests. An alternative interface is required:

```{language:scala}
Http().singleRequest(HttpRequest(URI(s"http://example.com")
  .withQuery(s"name", s"value"))
  .pipeTo(self)
```

The example uses `pipeTo` to have the integration layer reroute any response as an `HttpResponse`{language:scala} message to the sending Actor (delegation).

We see, not all the basic Actor primitives are suitable to be used outside the Actor abstraction. However, well introduced abstractions like *Akka HTTP* allow Actors to provide Microservice-like *service behavior* to the outside, while simply handling its through its own *Actor behavior*. Thus, communication between Actors and Microservices is possible in principle. This allows to construct systems where tasks are distributed between Actors and Microservices.  

This unified approach isn't quite common yet, but technologies are starting to emerge building on this idea. An example is the *Lagom* Framework[^fn-lagom], a reactive microservice system framework built ontop of Akka.

[^fn-lagom]: <https://www.lagomframework.com> 

## Outlook


~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

...

Languages like Jolie demonstrate how (micro-)service oriented computing can be facilitated on a language level. Microservices in general, an Jolie in particular, are having much in common with Actor Systems, as we've demonstrated in this thesis. Besides concurrency, concerns like scalability and [???]{.mind} are approached well by matured technologies like Akka or Erlang, on a programming language level [@Gui17]

~todo
Weiters in [@Gui17]: "However, Erlang and Go do not separate behavior from deployment, and more concretely do not come with explicitly defined ports describing the dependencies and requirements of services"
~ 

... It is our belief that...

...


... Bonèr is arguing for an evolution of the Microservice principles towards reactive systems [...die mehr actors ensprechen]{.important}. We've found his arguments to have resemblance to the fundamentals of process algebra theory [...dh er will das die MS sich mehr an so eine theory halten (?) --> Jolie macht ja genau das]{.mind}. ...Languages dedicated to the service-oriented programming paradigm can be an promising approach towards this ...

... Boner schlägt zB vor das Microservices gechrieben werden sollen nach den Actor Prinzipien; schlägt dafür sogar einen komischen Namen vor

... dafür einfach dedizierte sprachen erfinden die beides vereinen

...außerdem sollen sie behavioral types unterstützen...

---

Service oriented programming languages machen erzeugen im prinzip constructe, die eh sehr nahe an actors sind. ich sehe die zukunft daher in einer vermischen aus actors abstraktion und SOP 

---

~LitNote
* Services as First-Class Citizens
* [@Kan15] beschreibt eine distributed Actors in Erlang, mit Erweiterungen:
    * "This new model is designed for representing Cloud applications based on Actors in a deterministic, expressive and scalable way. It can also solve certain categories of problems more productively than original Actor model, and more advantageously in multi-computer ar- chitecture than other deterministic concurrency models such as task parallelism"
    * By introducing distask model, a number of constructs can now be supported. It provides a flexible set of primitives and runtime support to easily write various of distributed applications scaling over a dynamic changeable environment. New capabilities can be summed up for three main points, introduced below:
        * Deterministic Expression: The key powerful expressivity of deterministic concurrency allows programmers to encapsulate complicated communica- tion and synchronization protocols as first-class abstractions
        * Advanced Concurrency in Actors Internal: Internal parallelization, Join Calculus --> **internal parallelization ist genau das was MS mit ihrer internal concurrency auch haben -> das habe ich in einem unterkapitel auch angemerkt. sollte ich auf jeden falls hier zusammenbringen!**
        * Scalability & Fault Tolerance
* [@Gho12] "Programming language impact on the development of distributed systems"
* [@Gui17] "Microservices: A Language-Based Approach"
* [@Cha13]
  * "It applies to concurrency as well as distribution, but has not yet entered the native programming domain. This paper contributes the design of a native actor extension for C++, and the report on a software platform that implements our design for (a) concurrent, (b) distributed, and (c) heterogeneous hardware environments"
  * "Our design includes a lightweight, lock-free, and network-transparent message passing system that is implemented without context switching"
* [@Ber14] "Orleans: Distributed Virtual Actors for Programmability and Scalability"
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
  * "First and foremost, languages that embrace the service-oriented paradigm are needed (instead, for the most part, microservice architectures still use OO lan-guages like Java and Javascript or functional ones)."
* [@Aue94] "High-level language support for programming distributed systems"
  * Beschreibt auch schon wie man auf Language ebene Processe programmiert, mit Ports und Communication und allem, was dann Jolie auch macht.
~

In this thesis, we discussed the new microservices style and quite old principles of concurrent and distributed programming as if they were two competing approaches, and one will eventually emerge victorios. In this chapter, instead of rivalry, want to entertain the though of a unification of both towards a new style of programming. 
One the one hand, we analyzed microservices for their core concepts and found that their natural characteristics implied a high form of isolation. Combined with an asynchronouse communication mechanism, they become highly decoupled and the resulting architecture enjoys the principles of Actor based concurrency combined with the feature of distribution and mobility that agent based systems defined long ago. Yet programming a microservice architecture results in a significant overhead in terms of complexity, maintainability, etc. 
On the other hand, we discussed the classic concurrency model through Actors, and found that if it gets extended by additional concepts, such as it is done in existing implementations today, the resulting artifacts yield similar benefits as the microservice approach to. For these implementations are integrated into many mainstream programming languages, they are naturally available to developers to use without increasing complexity and related software development concerns as microservices architectures do. It seems programming concurrency is still unnatural or at least not loved by programmers. The microservice apporach seems to let them better think and plan the separation of concerns inside their software architecture in a divide an conquer way that concurrency primitives of programming languages do.

On this observaton we want to motivate that it seems to be a good idea to integrate the concepts of the service as a principle component into programming languages (like objects) is a good approach. In fact, this is done in some projects already. As the most promising one, we see Jolie. This approach allows developers to write microservice styled programm architectures in a single codebase, while in principle they write software with and Actor-based concurrency and distribution approach as we discussed in this thesis.

**Und dann noch weiteren blabla, aber das ist doch schon mal ein guter Ansatz das anzugehen, und den Outlook mit diesem Thema doch drinnen zu haben!**   

~LitNote
* "Programming Services as a new Paradigm"
  * Hier die Vision und die Gründe/Vorteile von einem neuen Paradigma beschreiben
  * Bsp der Datenbank-Services: 
    * Jeder MS sollte seine eigene DB haben. Kann man genau so mit zB Actors oder auch Threads handhaben. Aber beim Deployment gibt es hier Unterschiede. Beim starten eines neuen MS (= Program/Single-Executable-Artefact) ist es leicht auch eine neue DB zu starten (weil auch Programm). Über einen Mechanismus/Tool welches auf dieser konzeptionellen Ebene arbeitet (Programme im OS zu starten, zB Docker) lässt sich dies heute leicht automatisieren. Ein Thread (oder Actor/Active Obj/etc.) steht konzeptionell auf einer anderen Ebene. Es ist ein Konstrukt innerhalb des übergeordnetten Programms. Dh wenn ein neuer Thread erstellt wird ist dies in der Programmiersprache (oder Library/Framework) vorgesehen, aber die DB muss irgendwie extra über eine Interaktion mit dem unterliegenden OS (noch schwieriger in der Cloud, weil nicht umbedingt ein OS sichtbar/ansprechbar ist) gestartet werden. Java zB abstrahiert ja mit der JVM das OS so gut es geht weg (Plattformunabhängigkeit). Natürlich kann man mit dem System schon reden, aber es ist konzeptionell nicht vorgesehen dies als Standardmechanismus ständig zu verwenden. Die Datenbank muss anschließend auch noch irgendwie initialisiert werden, was zB wiederum das Laden eins Init-Scripts erforderlich macht. Dh das Deployment des Threads und das der Datenbank stehen auf konzeptionell unterschiedlichen Ebenen, ihr gemeinsames Deployment ist nicht vorgesehen und somit umständlich/schwierig. Bei MS ist dies konzeptionell auf die selbe Ebene gehoben. 
* in [@Dra17a] wir im Kapitel "Tomorrow" ein weiter Blick in zukünftige Möglichkeiten gegeben:
  * connecting behavioural types and choreographies to well-known logical models
  * a logical reconstruc- tion of behavioural types in classical linear logic that supports parametric polymorphism [83];
  * type theories for integrating higher-order process models with functional computation [79];
  * initial ideas for algorithms for extracting choreographies from separate service programs [18];
  * a logical characterisation of choreography-based behavioural types [19]; 
  * explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13];
  * formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems;
  * these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics;
~