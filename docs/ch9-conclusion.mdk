
Discussion & Conclusion {#ch-conclusion}
==========


~ Epigraph { caption: "Theodor W. Adorno"}
Weil das was ist sich ändern kann, ist das, was ist, nicht alles.
~


This thesis has discussed the concepts of programming Actors and Microservices to conceive concurrent computation, and evaluated their common properties and capabilities. As a bottom line, we now want to argue for an application of each of them, and outline towards their integration as well as our concluding vision regarding future development. 

As we've illustrated, both Actors and Microservices are qualified to express concurrent computation for both parallel execution on multicore processor as well as distributed computation as are for example cloud deployments. Kang & Cao [@Kan12] as well as Karmani *et al.* [@Kar09] suggest that programing models regarding parallel and distributed contexts should be evaluated based on their emphasize on two objectives: *efficiency* of execution and *expressiveness* for programmers. Agha & Kim extend the concerns on universal programming models by *portability* and *performance predictability* [@Agh99], thus we will merit them attention as well in this concluding discussion.


## The Case for Actors


The Actor model provides an abstraction for writing task units mostly focused on concerns related to their responsibility. The Actor system centralies many additional concerns not directly related to the scope of responsibility of each individual Actor, such that they are met by one managing entity per system node. Many are abstracted away completely, e.g. through a uniform interface for local and remote communication and discovery is transparenly hidden within the Actor addresses. Others, like fault tolerance, are provided with sane default behaviors, and beyond these influenceable through well-defined, coherent interfaces (e.g. `SupervisionStrategy`{language:scala}). Theoretical limitations, like asynchronous message passing, may be loosened up by introducing additional abstraction, e.g. Future-based computation and synchronous-styled `ask` pattern, at the risk of introducing potential model semantic violations. Akka, due to its library conception, specifically suffers from risks provided by the JVM ecosystem and Java/Scala language semantics. However, if used with care, we deem the Actor abstraction very expressive, once a certain learning curve regarding a reactive programming style has been mastered.

Actor are conceptually very slim computational units. Erlang is best known for its lightweight Actor variant, and Akka through its behavior closures too is able to provide a very efficient Actor implementation compared to Scala's original variant. 

Essentially, it is our obersavtion that each Actor system aims to keep their units more lightweighted than a program thread, such that the Actors are being scheduled on a thread-pool if they are required. This allows to greatly improve performance by preventing idle Actors to consume computational resources. The runtime of Orleans even holds its Actors merely virtual, such that they are instantiated just on demand.   

~ todo
irgendwo hab ich gelesen: Scala actors mehrere 10k, bei Erlang sogar mehrere Mio. [QUELLE?!]{.red}
~

...

However, the Actor runtime makes prediction about the performance difficult. Akka's dispatcher's provide besides a fixed thread-pool size also a dynamic pool size configuration. This will elastically scale the amount of threads based on the current demand. Consequently, long turns, e.g. due to blocking operations, will lead to an increase of threads in the pool. Yet Java thread efficiency is related to the amount of cores available on the host machine, such that a high thread-to-core ratio will have a negative impact on the overall performance. This has been experienced with Echo's web crawlers, which rely on blocking HTTP calls to retrieve remote content. Thus, deployment configuration specific to each individual nodes host machine, whith a focus on the different options regarding thread-pool management, is recommendable in general.

Therefore we observe that the portability of Actor system nodes is relative to the machine configurations of the old and new deployment locations, at least regarding a predictable performance behavior. Additionally, the ecosystem is also limited by the Actor system technology. As all involved tasks have to be interoperable, thus conceived through the Actor system variant, all components are limited by it. As Akka is a JVM based library, with dedicated binding for Java and Scala, portability is still good, as the JVM is available for most potential host machines. Other Actor system face essentially the same limitations. Erlang was specifically designed for Actor utilization, thus they are deeply founded in the languages concepts. Its Actors are thus at most interoperable with other BEAM-based constructs, e.g. such constructed using the Elexir language.


## The Case for Microservices


Microservice architectures also facilitate constructs aiming for a clear and easy separation of concerns [(vll etwas anders formulieren?)]{.red} in dedicated computation units. However, as all these services are individual processes spawned from distinct program images, each Microservice in general has to pay attention to many more aspects than its primary responsibility. 

Most importantly, as services cannot facilitate in-memory calls like monolithic system architectures do, their connectivity becomes an essential concern essential. All communication channel technologies required to achieve a desired interaction, but also resilience mechanisms down to more trivial matters like logging concerns have to be supported individually. Regarding communication, this can be a benefit. The paradigm allows to explicitely define communication ports, whereas Actors have to comply to the abstraction provided by the system.

However, due to the increased complexity in any case, we deem the programming model of Microservices therefore less expressive from a programmer's perspective than Actors in general. Technology stacks like Spring Cloud can greatly help in easing the effort through provided linguistic abstractions for IoC executed solutions, but cannot erase the fact that each service has to merit these concerns separately, resulting in an increased accumulated performance demand. Additionally, such technologies tend to produce rather large application skeletons (despite being "micro"), as their offered linguistic constructs, e.g. for easing the utilization of various communication mechanisms, come at the price of requiring many additional dependencies and considerable runtime overhead of realizing the declarative programming style allowing to write sparse custom code focused on the respective service's concern

As a result, each Microservice's (custom written) code base compared to its Actor counterpart is larger, but not significantly. However, the compiled executables of each service is merely slightly below the compiled size of the whole monolithic Actor executable. This is also reflected in the startup time. While an arbitrary OS process can be started rather quickly in general, considerable time (two digit amount of seconds) is required before any of Echo's microservices is up and ready to be used, depending on the current load of the executing host.

Microservice generally affect the efficiency of an architecture in a positive way compared to traditional monoliths, as has been one of the primary goals for the paradigms conception. Individual replication and scaling of each service is possible on as many diverse hosts as desired, provided that a service is deployable there (technology compatibility). However, each service process always stresses the nodes performance capacity, even if it is unused.

This also affects the services portability. As services are independently replaceable, they can also be addapted to support new target ecosystems. Their basic process abstractions does not demand any specifics regarding parallelization, as it is merely optionally achievable, if multiple CPUs per host are available. Network topology is a bigger concern in principle, as such is not automatically abstractable. Dedicated discovery services are additionally required.

General performance is well predictable, when the number of service instances can be fixed, as is with Echo. No elasticity mechanism is supported, thus the required operating system processes is foreseeable. Of course, third party components, e.g. RabbitMQ for asynchronous messaging, may spawn additional processes themselves. However, such are also expected to do this in a foreseeable way. In general, we deem it less likely to create new services as flexible as is done with Actors, for process creation comes with a relatively high price, e.g. due to the memory address space.  


## Empirical Indications


~LitNote
  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refActorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
* [@Has16] "Microservices and Their Design Trade-offs: A Self-Adaptive Roadmap"
  * "Among these problems is finalising the level of granularity of a microservice too early. “Splitting too soon can make things very difficult to reason about. It will likely happen that you (the software architect) will learn in the process. [1]."
  * [@Tai17] "Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation"
* [@Dra17c] "Microservices: Migration of a Mission Critical System"
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@Fow14]
* MS können gut sein wenn man einen bestehenden Monolithem refaktorisiert und aufspaltet (Literatur benötigt!)
* literature on project success, where it says that projects transforming monolith into MSA have a high success chance, while projects starting initially with an MSA tend way more to fail
~

## Integrating Actors and Microservices {#sec-actor-ms-integration}

~important
Das hier ist relativ frei aus der Hand geschrieben. Hier sollte ich Dinge zitieren, abseits von der Akka-HTTP Dokumentation!
~

In our discussion, we've focused on Actors and Microservices as competing approaches for constructing concurrent systems so far. However, it is worth to entertain the thought of *combining* both concepts instead. From a theoretical point of view, any two concurrent units are required to share a communication channel in order to interact [@Agh97]. 

The Microservice principles allow the services a rather high degree of freedom regarding their communication. REST-based state transfer via HTTP is a popular choice, but e.g. the through an AMQP interface are possible as well. Actors on the other hand are more restricted, for the model semantic requires them to receive *message* constructs in a uniform way. However, by implication this means that different communication channels could be integrated as long as they comply to a homogenous message receiving abstraction.

*Akka HTTP* [@AkkaHTTP] is part of the Akka library collection. It provides a full client- and server-side HTTP stack ontop of the basic Actor abstraction. Thus, HTTP requests may be received as messages, just like from any other Actor: 

```{language:scala}
override def receive = {
  case SomeMessage(_)                           => // handle message
  case HttpResponse(status, headers, entity, _) => // process response
}
```

For Actors are identified by their unique address, which is specific to a concrete Actor System and not conform to a URI (__U__niform __R__esource __I__dentifier) as is required by HTTP in general, a integration layer between an HTTP-addressable unit and the actual Actor has to be utilized [steht irgendwo am einführungs blabla zu AkkaHTTP]{.mind}. 

Though such receiving is in principle conform to the Actor abstraction, there are certain limits. By implication, HTTP endpoints also do not comply to Actor addresses in general. The standard *send* mechanism through `tell` and `ask` is therefore not applicable to dispatch HTTP requests. An alternative interface is required:

```{language:scala}
Http().singleRequest(HttpRequest(URI(s"http://example.com")
  .withQuery(s"name", s"value"))
  .pipeTo(self)
```

The example uses `pipeTo` to have the integration layer reroute any response as an `HttpResponse`{language:scala} message to the sending Actor (delegation).

We see, not all the basic Actor primitives are suitable to be used outside the Actor abstraction. However, well introduced abstractions like *Akka HTTP* allow Actors to provide Microservice-like *service behavior* to the outside, while simply handling its through its own *Actor behavior*. Thus, communication between Actors and Microservices is possible in principle. This allows to construct systems where tasks are distributed between Actors and Microservices.  

This is not a novel idea however. Chapter [#ch-evaluation] already mentioned the theoretical foundation from [@Mon97] for incorporating Actors and agents of the &pi;-calculus. There too, so-called *actor-&pi; coordinators* are used to translate between communication channels, similar to the integration layer of *Akka HTTP*. However, interoperability is merely a concern of static configuration, for processes have only a static notion of interconnection topology in general, which violates the dynamic reconfiguration inherent to Actors [@Akm90;@Agh85b]. In order to overcome this, bridge technologies like service discovery have to be utilized by Microservices, thus it would require Actors to integrate into this discovery mechanism, effectively rendering each Actor into a mere Microservices themselves.

This unified approach isn't quite common yet, but technologies are starting to emerge building on this idea. An example is the *Lagom* Framework[^fn-lagom], a reactive microservice system framework built ontop of Akka.

[^fn-lagom]: <https://www.lagomframework.com> 


## Outlook


<!--
~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~
-->


In this thesis, we've evaluated the conceptualities of Actors and Microservices, formulated arguments favouring each, and motivated their potential integration. In this final section, we want to argue a conceptual evolution towards a unification.

For the scope of this thesis, we've found it rather difficult to narrow on the essential characteristics that constitute the Microservice paradigm. We believe this observation to be also reflected in the literature, where we've frequently found authors to tend to fairly short, unilateral or superficial definitions for the sake of an easier and more focused argumentation. For example, REST is by far the most popularly pointed out mechanism of sole communication, without entertaining neither the possibility nor implications of other and especially non request/response channels.

In our opinion this is due to the fact that the Microservice style, although conceived as an aim towards minimalistic components, is on the other hand too allowing in general regarding the options for conceiving each single service of any system. The lack of a more coherent technological context among at least some or even all service components also hinders the introduction of enhancing concepts. Challenges regarding behavioral types, choreographies or means of verification have already been outlined. Such would only be possible with greater difficulties and come with restrictions nevertheless. As was motivated, languages dedicated to the Service-Oriented Programming paradigm offer the potential towards overcomming this limitation. Even more, if these languages are based on a process calculus, such open up the potentials of their theoretical properties and possibilities. 

Other authors, like Bonér [@Bon16;@Bon17], are advocating for Microservices following the conceptualities as are outlined by the Actor model. 

However, this raises the question why an Actor approach should not be pursued in the first place? As Guidi *et al.* [@Gui17] point out, general purpose languages utilizing mechanisms that are competing with Microservice concerns, like concurrency and scalability, do not provide a conceptual difference between the behavior of a task unit and the deployment thereof. This is true even for very sophisticated Actor language like Erlang and Orleans, as well as equally potent frameworks like Akka. 

It is our believe however, that service oriented programming languages are already fostering components that are following many of the conceptualities of Actors. CAOPLE services for examples are already limited to asynchronous communication [@Xu16]. Yet SOP languages keep the openness of well-defined interfaces, such that the interoperability of diverse technologies is ensured.  [hier noch dazuschreiben, dass somit die gradual evolution and replacement of components weiterhin erhalten bleibt ("future proof")]{.important}



...We see ourselves affirmed in the literature, from a theoretical as well as a practical perspective. 

As has been pointed out, Agha *et al.* [@Agh97] argument towards regarding high-level language semantics instead, and then reason about equivalence to Actor- and in their case &pi;-programs. We see constructs and conceptualities of the service-oriented programming paradigm exactly as such high-level language concepts and their semantics is convenient to be compared to Actor and Microservice programming, as we've aimed to point out throughout this thesis. 

...As a result, it is our believe that an languages-based solution is worth a [???]{.mind}

... Promising protoypes as Jolie essentially produce constructs that are rather similar to Actors - except that the creation of new components is not an essential primitive. 

... Critique that actors do not compose [@Agh97], but SOP languages do.


... we don't claim that service-oriented programming languages are the key towards the future, but it is our believe that Actors and Microservices *learning from* each other and *growing closer too* each other are promising ... [1) unterhosen 2) ? 3) profit]{.important}

...

Languages like Jolie demonstrate how (micro-)service oriented computing can be facilitated on a language level. Microservices in general, and Jolie in particular, are having much in common with Actor Systems, as we've described in this thesis. Besides concurrency, concerns like scalability and [???]{.mind} are approached well by matured technologies like Akka or Erlang, on a programming language level [@Gui17]. However, their Actor abstraction prevents them from facilitating multiple communication channels in a uniform way, as was just demonstrated for HTTP. Service-oriented languages on the other hand can integrate multiple channels and their respective protocols in a seamless way. Extending Jolie programs with HTTP is demonstrated in [@Mon16b].

... It is our belief that...

... Bonèr is arguing for an evolution of the Microservice principles towards reactive systems [...die mehr actors ensprechen]{.important}. We've found his arguments to have resemblance to the fundamentals of process algebra theory [...dh er will das die MS sich mehr an so eine theory halten (?) --> Jolie macht ja genau das]{.mind}. ...Languages dedicated to the service-oriented programming paradigm can be an promising approach towards this ...

... Boner schlägt zB vor das Microservices gechrieben werden sollen nach den Actor Prinzipien; schlägt dafür sogar einen komischen Namen vor

... dafür einfach dedizierte sprachen erfinden die beides vereinen

...außerdem sollen sie behavioral types unterstützen...

---

Service oriented programming languages machen erzeugen im prinzip constructe, die eh sehr nahe an actors sind. ich sehe die zukunft daher in einer vermischen aus actors abstraktion und SOP 

---

It is our utmost belief that Actor and Microservice technologies can greatly influence their mutual evolution. For example, Akka cluster nodes (in the version Echo is using) require static configuration for initial discovery. But recently automatic discovery capability using the Consul service registry has been merged into the Akka codebase for a future release.   

---

~LitNote
* Services as First-Class Citizens
* [@Kan15] beschreibt eine distributed Actors in Erlang, mit Erweiterungen:
    * "This new model is designed for representing Cloud applications based on Actors in a deterministic, expressive and scalable way. It can also solve certain categories of problems more productively than original Actor model, and more advantageously in multi-computer ar- chitecture than other deterministic concurrency models such as task parallelism"
    * By introducing distask model, a number of constructs can now be supported. It provides a flexible set of primitives and runtime support to easily write various of distributed applications scaling over a dynamic changeable environment. New capabilities can be summed up for three main points, introduced below:
        * Deterministic Expression: The key powerful expressivity of deterministic concurrency allows programmers to encapsulate complicated communica- tion and synchronization protocols as first-class abstractions
        * Advanced Concurrency in Actors Internal: Internal parallelization, Join Calculus --> **internal parallelization ist genau das was MS mit ihrer internal concurrency auch haben -> das habe ich in einem unterkapitel auch angemerkt. sollte ich auf jeden falls hier zusammenbringen!**
        * Scalability & Fault Tolerance
* [@Gho12] "Programming language impact on the development of distributed systems"
* [@Gui17] "Microservices: A Language-Based Approach"
* [@Cha13]
  * "It applies to concurrency as well as distribution, but has not yet entered the native programming domain. This paper contributes the design of a native actor extension for C++, and the report on a software platform that implements our design for (a) concurrent, (b) distributed, and (c) heterogeneous hardware environments"
  * "Our design includes a lightweight, lock-free, and network-transparent message passing system that is implemented without context switching"
* [@Ber14] "Orleans: Distributed Virtual Actors for Programmability and Scalability"
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
  * "First and foremost, languages that embrace the service-oriented paradigm are needed (instead, for the most part, microservice architectures still use OO lan-guages like Java and Javascript or functional ones)."
* [@Aue94] "High-level language support for programming distributed systems"
  * Beschreibt auch schon wie man auf Language ebene Processe programmiert, mit Ports und Communication und allem, was dann Jolie auch macht.
~

...

~ important
In this thesis, we discussed the new microservices style and quite old principles of concurrent and distributed programming as if they were two competing approaches, and one will eventually emerge victorios. In this chapter, instead of rivalry, want to entertain the though of a unification of both towards a new style of programming. 
One the one hand, we analyzed microservices for their core concepts and found that their natural characteristics implied a high form of isolation. Combined with an asynchronouse communication mechanism, they become highly decoupled and the resulting architecture enjoys the principles of Actor based concurrency combined with the feature of distribution and mobility that agent based systems defined long ago. Yet programming a microservice architecture results in a significant overhead in terms of complexity, maintainability, etc. 
On the other hand, we discussed the classic concurrency model through Actors, and found that if it gets extended by additional concepts, such as it is done in existing implementations today, the resulting artifacts yield similar benefits as the microservice approach to. For these implementations are integrated into many mainstream programming languages, they are naturally available to developers to use without increasing complexity and related software development concerns as microservices architectures do. It seems programming concurrency is still unnatural or at least not loved by programmers. The microservice apporach seems to let them better think and plan the separation of concerns inside their software architecture in a divide an conquer way that concurrency primitives of programming languages do.

On this observaton we want to motivate that it seems to be a good idea to integrate the concepts of the service as a principle component into programming languages (like objects) is a good approach. In fact, this is done in some projects already. As the most promising one, we see Jolie. This approach allows developers to write microservice styled programm architectures in a single codebase, while in principle they write software with and Actor-based concurrency and distribution approach as we discussed in this thesis.

**Und dann noch weiteren blabla, aber das ist doch schon mal ein guter Ansatz das anzugehen, und den Outlook mit diesem Thema doch drinnen zu haben!**   
~

...

~LitNote
* in [@Dra17a] wir im Kapitel "Tomorrow" ein weiter Blick in zukünftige Möglichkeiten gegeben:
  * connecting behavioural types and choreographies to well-known logical models
  * a logical reconstruc- tion of behavioural types in classical linear logic that supports parametric polymorphism [83];
  * type theories for integrating higher-order process models with functional computation [79];
  * initial ideas for algorithms for extracting choreographies from separate service programs [18];
  * a logical characterisation of choreography-based behavioural types [19]; 
  * explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13];
  * formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems;
  * these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics;
~