
Discussion & Conclusion {#ch-conclusion}
==========


~ Epigraph { caption: "Theodor W. Adorno"}
Weil das was ist sich ändern kann, ist das, was ist, nicht alles.
~


This thesis has discussed the concepts of programming Actors and Microservices to conceive concurrent computation and evaluated their common properties and capabilities. As a bottom line, we now want to argue for an application of each of them, and outline towards their integration as well as our concluding vision regarding future development. 

As we've illustrated, both Actors and Microservices are qualified to express concurrent computation for both parallel execution on multicore processor as well as distributed computation as are for example cloud deployments. Kang & Cao [@Kan12] as well as Karmani *et al.* [@Kar09] suggest that programing models regarding parallel and distributed contexts should be evaluated based on their emphasize on two objectives: *efficiency* of execution and *expressiveness* for programmers. Agha & Kim extend the concerns on universal programming models by *portability* and *performance predictability* [@Agh99], thus we will merit them attention as well in this concluding discussion.


## The Case for Actors


The Actor model provides an abstraction for writing task units mostly focused on concerns related to their responsibility. The Actor system centralizes many additional concerns not directly related to the scope of responsibility of each individual Actor, such that they are met by one managing entity per system node. Many are abstracted away completely, e.g. through a uniform interface for local and remote communication and discovery is transparently hidden within the Actor addresses. Others, like fault tolerance, are provided with sane default behaviors, and beyond these influenceable through well-defined, coherent interfaces (e.g. `SupervisionStrategy`{language:scala}). Theoretical limitations, like asynchronous message passing, may be loosened up by introducing additional abstraction, e.g. Future-based computation and synchronous-styled `ask` pattern, at the risk of introducing potential model semantic violations. Akka, due to its library conception, specifically suffers from risks provided by the JVM ecosystem and Java/Scala language semantics. However, if used with care, we deem the Actor abstraction very expressive once a certain learning curve regarding a reactive programming style has been mastered.

Actor are conceptually very slim computational units. Erlang is best known for its lightweight Actor variant, and Akka through its behavior closures too is able to provide a very efficient Actor implementation compared to Scala's original variant. 

Essentially, it is our observation that each Actor system aims to keep their units more lightweighted than a program thread, such that the Actors are being scheduled on a thread-pool if they are required. This allows to greatly improve performance by preventing idle Actors to consume computational resources. The runtime of Orleans even holds its Actors merely virtual, such that they are instantiated just on demand.   

However, the Actor runtime makes prediction about the performance difficult. Akka's dispatchers provide besides a fixed thread-pool size also a dynamic pool size configuration. This will elastically scale the amount of threads based on the current demand. Consequently, long turns, e.g. due to blocking operations, will lead to an increase of threads in the pool. Yet Java thread efficiency is related to the number of cores available on the host machine, such that a high thread-to-core ratio will have a negative impact on the overall performance. This has been experienced with Echo's web crawlers, which rely on blocking HTTP calls to retrieve remote content. Thus, deployment configuration specific to each individual node host machine, with a focus on the different options regarding thread-pool management, is recommendable in general.

Therefore, we observe that the portability of Actor system nodes is relative to the machine configurations of the old and new deployment locations, at least regarding a predictable performance behavior. Additionally, the ecosystem is also limited by the Actor system technology. As all involved tasks have to be interoperable, thus conceived through the Actor system variant, all components are limited by it. As Akka is a JVM based library, with dedicated binding for Java and Scala, portability is still good, as the JVM is available for most potential host machines. Other Actor system face essentially the same limitations. Erlang was specifically designed for Actor utilization, thus they are deeply founded in the languages concepts. Its Actors are thus at most interoperable with other BEAM-based constructs, e.g. such constructed using the *Elixir* language.


## The Case for Microservices


Microservice architectures also facilitate constructs aiming for a clear and easy separation of concerns into dedicated computation units. However, as all these services are individual processes spawned from distinct program images, each Microservice in general has to pay attention to many more aspects than its primary responsibility. 

Most importantly, as services cannot facilitate in-memory calls like monolithic system architectures do, their connectivity becomes an essential concern essential. All communication channel technologies required to achieve a desired interaction, but also resilience mechanisms down to more trivial matters like logging concerns have to be supported individually. Regarding communication, this can be a benefit. The paradigm allows to explicitly define communication ports, whereas Actors have to comply to the abstraction provided by the system.

However, due to the increased complexity in any case, we deem the programming model of Microservices therefore less expressive from a programmer's perspective than Actors in general. Technology stacks like Spring Cloud can greatly help in easing the effort through provided linguistic abstractions for IoC executed solutions but cannot erase the fact that each service has to merit these concerns separately, resulting in an increased accumulated performance demand. Additionally, such technologies tend to produce rather large application skeletons (despite being "micro"), as their offered linguistic constructs, e.g. for easing the utilization of various communication mechanisms, come at the price of requiring many additional dependencies and considerable runtime overhead of realizing the declarative programming style allowing to write sparse custom code focused on the respective service's concern

As a result, each Microservice's (custom written) code base compared to its Actor counterpart is to be assumed much larger in general, but not significantly in Echo due to IoC through Spring. However, the compiled executables of each service is merely slightly below the compiled size of the whole monolithic Actor executable. This is also reflected in the startup time. While an arbitrary OS process can be started rather quickly in general, considerable time (two-digit amount of seconds) is required before any of Echo's microservices is up and ready to be used, depending on the current load of the executing host.

Microservice generally affect the efficiency of an architecture in a positive way compared to traditional monoliths, as has been one of the primary goals for the paradigms conception. Individual replication and scaling of each service is possible on as many diverse hosts as desired, provided that a service is deployable there (technology compatibility). However, each service process always stresses the nodes performance capacity, even if it is unused.

This also affects the services portability. As services are independently replaceable, they can also be adapted to support new target ecosystems. Their basic process abstractions does not demand any specifics regarding parallelization, as it is merely optionally achievable, if multiple CPUs per host are available. Network topology is a bigger concern in principle, as such is not automatically abstractable. Dedicated discovery services are additionally required.

General performance is well predictable, when the number of service instances can be fixed, as is with Echo. No elasticity mechanism is supported, thus the required operating system processes is foreseeable. Of course, third party components, e.g. RabbitMQ for asynchronous messaging, may spawn additional processes themselves. However, such are also expected to do this in a foreseeable way. In general, we deem it less likely to create new services as flexible as is done with Actors, for process creation comes with a relatively high price, e.g. due to the memory address space.  


## Empirical Indications

~ todo
Hier kurz beschreiben welche Erkenntnisse es aus empirischer Forschung und Überlegungen es gibt, welche den einen oder anderen Ansatz befürworten. Zentral wird hier die Erkenntnis, dass sich der Microservice Ansatz dazu eignet ein bestehendes System zu refaktorisieren, um somit die concurrency (und scalability, extensibility, etc.) zu verbebssern. Hingegen denke ich nicht das ein bestehendes (monolytisches) System in eine Actor Architectur refaktorisiert werden kann. Umgekehrt gibt es Daten die belegen, dass MSA Projekte eine hohe Erfolgsaussicht haben, wenn sie refaktorisieren, aber eine hohe Schweiterwahrscheinlichkeit für Projekte "from the ground" nahelegen, dass das Concept initial zu überfordernd ist. Actors hingegen eignen sich sehr gut für eine schnelle Entwicklung von Anfang an, da das Actor system bereits sehr viele Concerns bedient  
~


~LitNote
  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refActorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
* [@Has16] "Microservices and Their Design Trade-offs: A Self-Adaptive Roadmap"
  * "Among these problems is finalising the level of granularity of a microservice too early. “Splitting too soon can make things very difficult to reason about. It will likely happen that you (the software architect) will learn in the process. [1]."
  * [@Tai17] "Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation"
* [@Dra17c] "Microservices: Migration of a Mission Critical System"
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@Fow14]
* MS können gut sein wenn man einen bestehenden Monolithem refaktorisiert und aufspaltet (Literatur benötigt!)
* literature on project success, where it says that projects transforming monolith into MSA have a high success chance, while projects starting initially with an MSA tend way more to fail
~


## Integrating Actors and Microservices {#sec-actor-ms-integration}


In our discussion, we've focused on Actors and Microservices as competing approaches for constructing concurrent systems so far. However, it is worth to entertain the thought of *combining* both concepts instead. From a theoretical point of view, any two concurrent units are required to share a communication channel in order to interact [@Agh97]. 

The Microservice principles allow the services a rather high degree of freedom regarding their communication. REST-based state transfer via HTTP is a popular choice, but e.g. the through an AMQP interface are possible as well. Actors on the other hand are more restricted, for the model semantic requires them to receive *message* constructs in a uniform way. However, by implication this means that different communication channels could be integrated as long as they comply to a homogenous message receiving abstraction.

*Akka HTTP* [@AkkaHTTP] is part of the Akka library collection. It provides a full client- and server-side HTTP stack on top of the basic Actor abstraction. Thus, HTTP requests may be received as messages, just like from any other Actor: 

```{language:scala}
override def receive = {
  case SomeMessage(_)                           => // handle message
  case HttpResponse(status, headers, entity, _) => // process response
}
```

For Actors are identified by their unique address, which is specific to a concrete Actor System and not conform to a URI (__U__niform __R__esource __I__dentifier) as is required by HTTP in general, a integration layer between an HTTP-addressable unit and the actual Actor has to be utilized [@AkkaHTTP]. 

Though such receiving is in principle conform to the Actor abstraction, there are certain limits. By implication, HTTP endpoints also do not comply to Actor addresses in general. The standard *send* mechanism through `tell` and `ask` is therefore not applicable to dispatch HTTP requests. An alternative interface is required:

```{language:scala}
Http().singleRequest(HttpRequest(URI(s"http://example.com")
  .withQuery(s"name", s"value"))
  .pipeTo(self)
```

The example uses `pipeTo` to have the integration layer reroute any response as an `HttpResponse`{language:scala} message to the sending Actor (delegation).

We see, not all the basic Actor primitives are suitable to be used outside the Actor abstraction. However, well introduced abstractions like Akka HTTP allow Actors to provide Microservice-like *service behavior* to the outside, while simply handling it through its own *Actor behavior*. Thus, communication between Actors and Microservices is possible in principle. This allows to construct systems where tasks are distributed between Actors and Microservices.  

This is not a novel idea however. Chapter [#ch-evaluation] already mentioned the theoretical foundation from [@Mon97] for incorporating Actors and agents of the &pi;-calculus. There too, so-called *actor-&pi; coordinators* are used to translate between communication channels, similar to the integration layer of Akka HTTP. However, interoperability is merely a concern of static configuration, for processes have only a static notion of interconnection topology in general, which violates the dynamic reconfiguration inherent to Actors [@Akm90;@Agh85b]. In order to overcome this, bridge technologies like service discovery have to be utilized by Microservices, thus it would require Actors to integrate into this discovery mechanism, effectively rendering each Actor into a mere Microservices themselves.

This unified approach isn't quite common yet, but technologies are starting to emerge building on this idea. An example is the *Lagom* [^fn-lagom] framework, a reactive microservice system framework built on top of Akka.

[^fn-lagom]: <https://www.lagomframework.com> 


## Outlook and Future Work


<!--
~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~
-->


We've evaluated the conceptualities of Actors and Microservices, formulated arguments favoring each, and motivated their potential integration. In this final section, we want to argue a conceptual evolution towards a unification.

For the scope of this thesis, we've found it rather difficult to narrow on the essential characteristics that constitute the Microservice paradigm. We believe this observation to be also reflected in the literature, where we've frequently found authors to tend to fairly short, unilateral or superficial definitions for the sake of an easier and more focused argumentation. For example, REST is by far the most popularly pointed out mechanism of sole communication, without entertaining neither the possibility nor implications of other and especially non request/response channels.

In our opinion this is due to the fact that the Microservice style, although conceived as an aim towards minimalistic components, is on the other hand too allowing in general regarding the conception options for each single service of any system. The lack of a more coherent technological context among at least some or even all service components also hinders the introduction of enhancing concepts. Challenges regarding behavioral types, choreographies or means of verification have already been outlined. Such would only be possible with greater difficulties and come with restrictions nevertheless. As was motivated, languages dedicated to the service-oriented programming paradigm offer the potential towards overcoming this limitation. Even more, if these languages are based on a process calculus, such open up the potentials of their profound theoretical properties and resulting possibilities. 

Some authors, like Bonér [@Bon16;@Bon17], are advocating for Microservices following the conceptualities as are outlined by the Actor model. However, this raises the legitimate question of why an Actor approach should not be pursued in the first place? As Guidi *et al.* [@Gui17] point out, general purpose languages utilizing mechanisms that are competing with Microservice concerns, like concurrency and scalability, do not provide a conceptual distinction between the behavior of a task and the deployment thereof. This is true even for very sophisticated Actor language like Erlang and Orleans, as well as equally potent frameworks like Akka. 

It is our believe however, that service-oriented programming languages are already fostering components that are following many of the conceptualities of Actors. CAOPLE services for example are limited to asynchronous communication [@Xu16]. Yet SOP languages keep the openness of well-defined interfaces, such that the interoperability of heterogenous technologies is ensured, while their preservation of independent deployment capabilities allows for gradual replacement and evolution. This decoupling of technological dependencies are a valuable for future proof system development and maintenance.

We see ourselves affirmed in the literature, from a theoretical as well as a practical perspective. As has been pointed out, Agha *et al.* [@Agh97] argument towards regarding high-level language semantics instead, and then reason about equivalence to Actor- and in their case &pi;-programs. We see constructs and conceptualities of the service-oriented programming paradigm exactly as such high-level language concepts and their semantics is convenient to be compared to Actor and Microservice programming, as we've aimed to point out throughout this thesis. On the other hand, Bonér is arguing for an evolution of the Microservice principles towards reactive systems which are more closer to Actor systems in general [@Bon16]. We've found his arguments to have resemblance to the fundamentals of process algebra theory.

As a result, it is our believe that language-based solutions are worth future endeavors. Promising prototypes as Jolie essentially produce constructs that are rather similar to Actors - except that the creation of new components is not an essential primitive. The profound foundation on process algebra and other theoretical concepts provide the basis for applying formal methods to introduce advanced mechanisms. For example, a Curry-Howard isomorphism has been shown between session types and the &pi;-calculus process model which resulted further work, e.g. how multiparty sessions (multiple services interactions) relate to certain techniques of logical reasoning, or a support for parametric polymorphism in behavioral types by reconstruction in classical linear logic. Such findings provide a strong indication that correct Microservice system conception can also be improved through such techniques [@Dra17a]. 

The utilization of such formalisms is of course possible for the enhancement of the Actor model too, e.g. as was done by introducing the *Join* calculus into Erlang Actors to allow internal parallelization and deterministic concurrency [@Kan15].

In any case, Actor and Microservice technologies can greatly influence their mutual evolution by *learning from* and *growing closer too* each other. For example, Akka already provides circuit breakers for `ask`-calls within its HTTP module. Additionally, Akka cluster nodes (in the version Echo is using) require static configuration for initial discovery. Just recently, automatic discovery capability using the Consul service registry has been merged into the Akka codebase for a future release.   

<!--
Languages like Jolie demonstrate how (micro-)service oriented computing can be facilitated on a language level. Microservices in general, and Jolie in particular, are having much in common with Actor Systems, as we've described in this thesis. Besides concurrency, concerns like scalability and [???]{.mind} are approached well by matured technologies like Akka or Erlang, on a programming language level [@Gui17]. However, their Actor abstraction prevents them from facilitating multiple communication channels in a uniform way, as was just demonstrated for HTTP. Service-oriented languages on the other hand can integrate multiple channels and their respective protocols in a seamless way. Extending Jolie programs with HTTP is demonstrated in [@Mon16b].
-->

~ todo
Future Work
~