
Discussion
==========

## Command-Query-Responsibility-Segregation

~LitNote
* Both solutions have a kind of CQRS model in place
* CQRS is a special form of Command Query Separation (CQS), more complicated
  * CQS ist im Meyer Buch ausführlich definiert, dh ich kann darauf verweisen. Yay!
  * CQS ist demnach gut für die ganzen gründe weswegen Actors/MS verwendet werden
~

## Saga Pattern 

## The Case for Actors

~LitNote
- easy to write from the ground up
- has to be started as a small programm, and extended one by one (otherwise one gets totally lost in the messages)
- less to do (the Actor framework/middleware does a lot for you), but has to live/work with the particula restrictions
- thread switching within an Actor can get a problem, e.g. with locking (have seen it with lucene)
- obwohl Active Obj. "leider" die selben Probleme wie Distr. Obj. haben, ist genau diese enge Verbindung der Proof of Concept bzgl Technology Heterogenity. Distr Obj varianten erlauben auch Bindings via verschiedene Technologien (zB CORBA), und demonstrieren somit, dass auch die statische - dh zur compile time - garantierte Kompatibilität der Typen von Messages zwischen Objekte über verschiedene Technologie hinaus garaniert werden kann.
  * hier gibts es sicherlich neue Probleme. In den Publikationen vom Franz dürfte dazu einiges stehen! Der hat doch eh ein CORBA Paper zB geschrieben. Und welche das so Act. Obj. Typen teilweise statisch/teilweise dynamisch evaluiert werden.
~

### Case Study: Why do Scala Programmers mix Actors with other Concurrency Constructs?

## The Case for Microservices

~LitNote
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@Fow14]
* MS können gut sein wenn man einen bestehenden Monolithem refaktorisiert und aufspaltet (Literatur benötigt!)
* Jonas Boner beschreibt in einem Youtube Talk und im Podcast, dass MS in für große Unternehmen gut sein können, wo es wichtig ist die Code base aufzuspalten um produktiv zu bleiben
* good to break up large monoliths
* literature on project success, where it says that projects transforming monolith into MSA have a high success chance, while projects starting initially with an MSA tend way more to fail
* freedom to practically do whatever you want (if it works within a monolith, this particual function also works within a smaller program = MS)
~

## Empirical Indications

~LitNote
  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refActorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
* [@Has16] "Microservices and Their Design Trade-offs: A Self-Adaptive Roadmap"
  * "Among these problems is finalising the level of granularity of a microservice too early. “Splitting too soon can make things very difficult to reason about. It will likely happen that you (the software architect) will learn in the process. [1]."
  * [@Tai17] "Processes, Motivations, and Issues for Migrating to Microservices Architectures: An Empirical Investigation"
~