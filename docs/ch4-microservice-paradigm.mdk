
The Microservice Paradigm {#ch-microservice-paradigm}
=========================



~ Epigraph { caption: "Ellen Ullman"}
We build our computer (systems) the way we build our cities: over time, without a plan, on top of ruins.
~

~ Epigraph { caption: "Groucho Marx"}
These are my principles. If you don't like them, I have others.
~


~LitNote
* Unlike the Actor model, Microservices were not invented as a specific form of computation, but emerged as the result of an historical evolution. --> von mir gescgrieben, muss ich irgendwie in den kontext setzen
* Dragoni [@Dra17a] calls it "Service-Oriented Architecture and Programming from the large to the small."
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
* [@Maz16] "Towards Microservices and Beyond: An incoming Paradigm Shift in Distributed Computing"
* [@Fra17] "Architecting Microservices"
* [@Sha17a] "Microservices: Granularity vs. Performance"
* [@Dra17b] "Microservices: How To Make Your Application Scale"
* [@New15] "Building Microservices"
* [@Fow14] "Microservices: a definition of this new architectural term"
~

At the beginning of our current decade, a new architectural term called *Microservice Architecture* emerged. This concept was originally born from the industrial need to break the scalability barrier that monolithic applications inevidently reach [citation needed]{.mind}. Only later the scientific community gained interrest in this paradigm, which lead to an explosion of contributions on this concept. Yet, academia still has some trouble to settle on a common basic definition on the overall concept(s) determining the microservice paradigm [@Has16]. Fowler[^fn-microservice-term] and Lewis [@Fow14] gave the first overall review to the microservice concept, and is the original source most scientists refere to. But they focus on describing the common characteristics from a more practical engineering perspective. Dragoni et al. [@Dra17a] tried to give a general, conceptial description, and therefore we will be founding our discussion of this paradigm on the definitions they provide.

[^fn-microservice-term]: Fowler points out that he heard the term first in 2011, where it has been conceived at a workshop to summarize the participants ideas. 

Historically, software systems often have always been implemented in a so-called *monolithic* setup, where all the source code is compiled into one single artifact that can be executed on a machine. This is based on the level of abstraction mainstream programming languages provide to break down complexity of the programming task: *modules*. They allow to logically separate concerns ["of ???" - diesen Teil kann ich sicher etwas ausschmücken und auf B. Meyer verweisen]{.mind}, yet the transformation from the abstraction of program code to machine code leads to a result where the different module components are merged into one unified construct: the (monolithic) *executable*. By inversion of argument, a monolith is an application of modules that cannot be executed independently [@Dra17a].

These naturally introduces a relative strong form of coupling, for each module tends to expect the presence of any other module [citation needed]{.mind}. *Coupling* is a **metric that describes the amount of dependencies between components** [so irgendwie ?]{.mind}. It is usually effected by the kind of interaction between the components. Any form of in-memory call communication eases the tightening of coupling, for it is a relatively easy and direct way of addressing components [frei erfunden, hat das mal jemand so argumentiert?]{.mind}.

Any application subject to tight coupling of its modules suffers from certain issues. With increasing coupling and therefore interweaving, it becomes hard to maintain. Software evolution is also hindered due to growing complexity [@Dra17a]. Especially modelling concurrent aspects introduces complexity due to the need for synchronization of shared state, or nondeterminism introduced by event-based approaches (like Actors) [citation needed für diesen satz]{.mind}. Strongly coupled modules tend to have a less strictly separated [wie sagt man: hier können alle möglichen dinge verschmischt werden, was die sache noch viel komplizierter macht?]{.mind}.

Scholars identified many more issues that come with monolithic applications [mehr? citation?]{.mind}. Such have been first encountered in the more early days in computing history. Therefore, from the early 1970s, an interrest in distributing applications accross multiple host machines arose, originally due to the limits of the machines back than [citation needed. hab ich irgendwas zu concurrency history?]{.mind}. However, with growing performance, focus shifted on concurrent programming approaches due to Moore's law, stating that the number of transistors in a processing unit (e.g. CPU) "roughly" doubles every two years. 

This does not hold exactly true anymore[^fn-moores-law] since the 2000s, for speed increasment since than is not backed by increasing transistors inside a processor, but to the trend of including multiple cores into a single CPU [@Mac11]. The importance of multicore programming increased significantely since then [citation needed?]{.mind}. 

[^fn-moores-law]: In fact, Moores original empirical observation about *doubling of components per chip* never held true very long. But over the decades various trends in semiconductor manufacturing still resulted in a rough doubling of processing power. Mack [@Mac11] gives an interresting analysis on this being simply the result of an economic will to make the law come true.

Even though the processing power increases all the time, any monolith inevidently reaches a limit when it comes to scalability. This limit is influenced by many factors, e.g. [wie gut man es eben monolith. scalieren kann??]{.mind}, but eventually reaches an upper bound based on hardware limitations of the host machine [citation]{.mind}.

Many approaches to overcome this limit have been proposed over the years. All of them have distribution in mind [faderer satz geht ja nimma...]{.mind}. Previously, the *Service Oriented Architecture* (SOA) approach gained popularity. It is based on the idea of interconnecting the capabilities of multiple monolithic applications, by connceting them on a single, uniform communication channel. Such integration mechanisms, like the so-called *Enterprise-service Buses* (ESB), however [...sind auch nicht gut]{.mind}

SOA still builds upon the idea of large monolithic applications, and all their fallities [?]{.mind}. In order to overcome these limitations, the idea of dividing up these monoliths based on their functionalities ["bruchlinie anhand der funktionalität"?]{.mind} came up. Such was borne the idea of *Microservices* (MS).

For an in depth review on how Microservices historically evolved from a distributed systems perspective, starting with the client-server paradigm, to mobile agents technology and Service Oriented Architectures, we refere the interrested reader to Salah et al. [@Sal16].

The basic idea of a Microservice is to put related functionality [gibt ne bessere formulierung]{.mind} into a dedicated process, and have it provide this via an interface for a lightweight communication mechanism [citation needed]{.mind} - in contrast to the heavyweight channels as ESB 

A *Microservice Architectures* (MSA) is a software architecture composed of Microservices [citation needed]{.mind}.

Any MSA is composed of so-called *Microservices* (MS), basic building blocks, each with their own functionality and connceted via lightweight, open communication protocols. 

~LitNote
* [@Dra17a]: "the evolution of objects into services, and the relative comparisons, has to be treated carefully since the first focus on encapsulation and information is hidden in a shared-memory scenario, while the second is built on the idea of independent deployment and message-passing"
~

 In order to 

In this chapter, we will analyze the concepts that make up the Microservice paradigm. 

[@Dra17a] defines:

~ Definition {#def-monolith; caption: "Monolith"}
A monolith is a software application whose modules cannot be executed independently.
~   

~ Definition {#def-microservice; caption: "Microservice"}
A microservice is a cohesive, independent process interacting via messages.
~   

## Service Ambiguity



~LitNote
* [@Bro16]
    * "larger grained APIs"
    * "deployment: serveral small applications implementing part of the whole"
    * "strictly limit types of network connectivity that a service can implement to achieve maximum simplicity"
    * "more choices via polyglot programming / polyglot persistence"
    * "avoid thight coupling via implicit communication through databas"
    * "all communication from service to service must be through the service API"
    * "different services evolve at different rates; allows that evolution to proceed at is own natural pace"
    * "horizontal scaling of single services"
~

No shared state, etc

...

---

The term "service" is used in an overloaded manner in the literature. We can identify two general meanings attributed to it. On the one hand, it referes to a computational task unit, e.g. a process, as part of a service-oriented architecture. That's what's [am öftensten mit der bezeichnung gemeint]{.mind} when refering to a "Microservice". On the other hand, a service also describes a specific functionality that can be utilized through an interface. This notion is known from object-orientation, where objects provide services in the form of procedures through their public interface [@Sny93]. 


In order to avoid confusion, some scholars propose a clear distinction. For example, Xu et al. [@Xu16] are using the term "service" exclusively for the functionality part, and refere to the component as *agent*. We will follow the example of Guidi and Montesi [@Gui09] by destinguishing between the *service engine*, that is the component deployed as a process, and the *service behavior* for the functionality a given deployed service engine offers. This terminology suits us, for it highlights the resemblence between an Actors behavior and a Microservices behavior. 

## Independence

[TODO]{.red}

~LitNote
* [@Gui17] "Since microservices are independent, the interactions among them all happen by exchanging messages"
* [@Fow14] "These services are independently deployable by fully automated deployment machinery"
* [@Dra17a;@Dra17c] "Microservices: Migration of a Mission Critical System"
    * independence
* [@Bon16] "Reactive Microservices Architecture"
    * isolation
* 
~

## Service Communication {#sec-ms-communication}

Any communication between microservices has to happen accross the boundries of the service processes. This is called *inter-process communication* (IPC) [citation needed]{.mind}. Variouse forms of IPC channels exists. Examples of simple IPC mechanisms are a shared memory section between two processes within the same operating system, or Unix pipes.

The microservice idiom specifies the following requirements on service IPC:

1. Messages between services should be immutable [citation needed]{.mind} 
2. Communication channels should be light-weighted [citation needed]{.mind} 
3. Communication channels should only act as message routers, and therefore should not introduce data processing logic of their own [citation needed]{.mind} . Fowler calls this characteristic "smart endpoints and dumb pipes" [@Fow14]

From the two example IPC mechanisms above, Unix pipes and shared memory, only the pipes qualify for a valid microservice communication channel. If data is in the form of text strings, it represents serialized data (= state information) of one service that is transported in an immutable way between the opposite endpoint of the pipe. Raymond describes this in his Unix *Rule of Composition* as [@Ray03]:

> "*Text streams are to Unix tools as messages are to objects in an object-oriented setting. The simplicity of the text-stream interface enforces the encapsulation of the tools.*" 

This satisfies the channel requirements given above. Therefore pipes are a valid communication mechanism. However they do not offer any specific structuring of the byte stream. An application-level protocol therefore has to be defined ontop of the pipe mechanism [@Bac03]. Shared memory on the other hand faces multiple conceptional problems regarding a microservice communication mechanism. First, messages between services are being send by modifying memory both services have access to. It is not guaranteed in general that these messages are being receiving by the indented recipient unmodified, for a third party entity also having access to the memory could get a lock and make modifications to the data beforehand. Additionally, shared memory validates the no shared resources between services principle already defined.

~todo
Open/well-defined Communication Interface, such that heterogenous components can interact
~

~LitNote
Conceptual Roots:

SOA, OOP
~


~LitNote
* [@Dra17a;@Dra17c], high cohesion, loose coupling, independence
~

## Concurrent and Distributed Building Blocks

~Todo
Eigentlich gehört der inhalt dieses kapitels soweit er jetzt hier steht zur "Service Communication" section oben. Und das mit der inherent Concurrency ist auch schon erklärt. Ich sollte dann einfach abschließen und weiter die Distribution überführen?
~

Each Microservice is by design a dedicated process. As we discussed in section [#sec-concurrency-os-level], processes are inherently concurrent on the operating system level, which facilitates parallelization by default. Any microservice architecture is therefore an inherently concurrent system.

In section [#sec-ms-communication] we discussed the requirements on a communication channel between services. Any mechanism has to be able to send data between processes. Some valid channels (like Unix pipes) are also only capable of sending messages between processes on the same operating system. However, recalling the case study on process system programming in C from section [#sec-concurrent-c], such fork/pipe based systems are executed in a concurrent fashion through the process scheduling of the operating system. For the concurrent components have strictly isolated states through the boundries of their distinct address spaces and the communication mechanism is sufficient in general, it's worth debating weither such systems apply for a Microservice Architecture.

The fork pattern spawns processes in a tree-like fashion, thus all components rely on a shared ancestor. Despite any child could easily replace itself by an arbitrary other program image using `exec`, the setup of the communication routes relies on an instantiation of the pipe before the fork, such that both parent and child know about it. Thus it limits the possibility to take down or add new components independently. Pipes are still rather restrictive and present a certain degree of coupling [@Bac03], such that it is difficult to replace the systems components independently.

To overcome these restriction, the construct of *named pipes* were introduced into later Unix system, allowing processes to hook into a common pipe without a shared ancestor [@Bac03]. However, this IPC mechanism definitely does not provide communication outside the boundry of the common operating system. Thus it limits scalability by restricting the service architecture onto a single host maschine, at least partially for the services facilitating this communication channel. Network-based IPC mechanism on the other hand overcome this restriction inherently [citation?]{.mind}. 

<!--
The concurrent components have strictly isolated states through the boundries of their distinct address spaces (all child states are full replicas of their parents state) and employ a communication mechanism that [...TODO...]{.mind}. Thus it is worth debating weither such systems apply for a Microservice Architecture.
-->

<!--
We've argued that Unix pipes are a viable queue-like mechanism sufficing the requirements on communication channels for Microservices. 
-->

<!--
Fork/pipe based systems are executed in a concurrent fashion through the process scheduling of the operating system. The concurrent components have strictly isolated states through the boundries of their distinct address spaces (all child states are full replicas of their parents state) and employ a communication mechanism that [...TODO...]{.mind}. Thus it is worth debating weither such systems apply for a Microservice Architecture.
-->

<!--
Though isolation is ensured and communication adequate, it is still difficult to replace the systems components independently. The fork pattern spawns processes in a tree-like fashion, thus all components rely on a shared ancestor. Despite any child could easily replace itself by an arbitrary other program image using `exec`, the setup of the communication routes relies on an instantiation of the pipe before the fork, such that both parent and child know about it. Thus it limits the possibility to take down or add new components independently. Pipes are still rather restrictive and  present a certain degree of coupling [@Bac03]. 
-->


## Size, Scope and Granularity {#sec-ms-granularity}

Bonér [@Bon17] criticizes the term "micro" for it encourages debating the actual *size* of a service. Any size definition requires a metric to be able to make comparisons and argue up to which limit an application may be called *Micro*service. Therefore, developers focus on metrics like *Lines of Code* up to more obscure ones, e.g. the reported *Two Pizza Team* size, where a service is written and maintained by a team that can be fed by two pizzas[^fn-two-pizza-team] [@Fow14]. These discussions are missleading.

[^fn-two-pizza-team]: Assuming an arbitrary pizza size, this either suggest very small teams, or really big pizzas.

Instead, Bonèr argues, a notion of size should refere to the "scope of responsibility". A guidline towards this can once again be the already refered to UNIX philisophy [@Ray03]. It suggests that programs should have a well-defined, limited scope, such that more complex functionality can be realized by composing multiple of these simple programs. This concept is also found in object-oriented design, where Martin [citation?!]{.mind} introduced the so-called *Single Responsibility Principle* (SRP) for objects.

In the Microservice context however, authors do not refere to the SRP a lot. Instead, they tend to phrase it *bounded context* [@Dra17a;@Dra17c;@Maz16], by arguing that services should be an aggregation of functionality around a single business capability. This divergence of granularity is one of the major evolutionary changes from SOA to Microservices [@Mon16a;@Gui17].

However, to fine a granularity can become an issues. In a distributed setting, it is always a balance between the number of messages to be sent versus the performance implications to be expected thereof. Latencies of network channels, processing time of addressed services and delay penalties resulting from unavailability have to be considered when designing the granularitiy of Microservices [@Sha17a].

## Service-oriented Programming

Until now, we've regarded Microservices in the light of a software architectural style. Within, the  building blocks are all truely isolated components instantiated from independently executable artifacts, merely linked by rather loosely coupled message passing communication channels. It has been argued that due to these characteristics the perspective in the literatur (both academic as well as industrial) has had a focus on the operation of the service engines, that is their *deployment* [@Gui17;@Xu16]. After all, the deployment context of MSA is the origin of its concurrent nature, that is independet processes of the OS or network. In this section however, we want to favour an argumentation towards a linguistic viewpoint on Microservices instead.

Programming paradigms build upon respective conceptual constructs, e.g. objects in OOP or functions in Functional Programming. In more reject time, a now paradigm called *Service-Oriented Programming* (SOP) [@Mon14] emerged. It builds upon the *Service-Oriented Commputing* (SOC) approach emphasized by SOA and subsequently Microservices, and introduces it into programming language design. ["services are the smallest programmable constructs" -> irgendwo gelesen und finde ich nicht mehr]{.red}

~LitNote
* hier die basis für die spätere Diskussion zu Behavioural Types legen (die ich schon in der diskussion bei design by conract bringen will, ansatt erst in der Conclusion anteaser)
* [@Gui17] "Microservices: a Language-based Approach"
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
* [@Xu16] "CAOPLE : A Programming Language for Microservices SaaS"
~


...service as first-class entities [@Gui17]

... instead of a single executable artifact, they compiled into multiple executables, one for each of the service constructs in the source code. 

...When the Microservices principles finally distilled, it was found that compilation of SOP languages essentially produced Microservice Architectures. Thus, instead of the total technology freedom of the MS paradigm, SOP languages are a separate approach towards the Microservice style.

...have to ensure well-defined and open interfaces to be able to interoperate with non SOP components

...

...The Microservice approach has gained much attention first in the industry and nowadays as well in the academic community. As such, many different research disciplines focus on incorporating the Microservice paradigm into their respective field [...]{.mind}.






... for service composition is not [vorgegeben]{.mind} by dedicated abstractions [@Gui17].

do not provide dedicated abstractions for service composition.

...

* CAOPLE
  : One attempt of a service-oriented programming language is *CAOPLE* [@Xu16]. It's basic programming constructs are services so-called *agents* (services), which provide a very strict notion of state encapsulation, autonomy and well-defined communication interfaces. They are executed on a dedicated virtual machine called *CAVM-2*, which is focusing on providing lightweight dynamic deployment of services compared to using container technology. Additionally, it is optimized for running large quantities of services in a lightweight manner, as well as abstracting network distribution.

* Jolie
  : Currently the most advanced and scientifically best described service-oriented language is *Jolie* [@Mon14;@Mon16b;@Gui17;@Min17;@Gui09]. We will therefore use it as the primary linguistic example throughout the remainder of this thesis. A Jolie program defines services which are described of two basic aspects. First, the *behavior* .....
  
  ...Second, the *deployment* ...

  ...

...

For Microservices share many similarities with objects in general [citation?]{.mind}, such service-oriented languages tend to have many analogies to object-oriented languages, as the computational units in both paradigms provide functionality via a public interface [@Xu16; @Sny93]. For example, Jolie has static type checking for service interfaces [@Min17], and CAOPLE even supports polymorphism via an inheritance mechanism.


