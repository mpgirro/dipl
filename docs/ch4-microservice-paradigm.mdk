
The Microservice Paradigm {#ch-microservice-paradigm}
=========================


~ Epigraph { caption: "Groucho Marx"}
These are my principles. If you don't like them, I have others.
~


Recently, a new software architecture style called *Microservice Architecture* (MSA) emerged for designing software applications as systems of loosely coupled, independently deployable, single purpose services [@Fow14]. Instead of developing monolithic applications, the application logic is split up into a suite of small parts, each implemented as a dedicated program designed to provide a single task of the business logic. These programs posing as the applications components are called *Microservices*.

Their style is open for any programming language or paradigm. For services are communication with message passing semantic on the OS or network level, the services themselves may be conceived in different programming languages and technologies. As long as they expose the interface required by the architecture, they are useable components [@Dra17a;@Mon16a].

Unlike the Actor model, Microservices were not invented as a specific form of computation, but emerged from the industrial need to break the scalability barrier that monolithic[^fn-monolith] applications inevitably reach [@Bon17]. Only later the scientific community gained interest in this paradigm, which lead to an explosion of contributions on this concept. Yet, academia still has some trouble to settle on a common basic definition on the essential concept(s) determining the paradigm [@Has16]. Fowler & Lewis [@Fow14] gave the first overall review to the Microservice concept, thus they are the original source most scholars refer to. But they focus on describing the common characteristics from a more practical engineering perspective. Dragoni *et al.* [@Dra17a] later gave an extensive conceptual description, thus we refer to them for further reading.

[^fn-monolith]: The term originates from the *monolithic kernel* style of operating system architectures. Such is a sole binary running in kernel mode and providing the process- and memory management, file system, etc.


## Limits of Centralization


Historically, software systems often have always been implemented in a so-called *monolithic* way, where all the source code is compiled into one single, central artifact that can be executed on a machine. This is based on the level of abstraction mainstream programming languages provide to break down complexity of the programming task: *modules*. They allow to logically separate concerns, yet their transformation from program code to machine code leads to a result where all such modules are merged into one unified construct: the (monolithic) *executable*. By inversion of argument, a monolith is an application of modules that cannot be executed independently [@Dra17a].

These naturally introduces a relative strong form of coupling, as in-memory call communication is a cheap and direct way of addressing components, and thus heavily applied in monoliths [@Bon17]. Yet any application subject to tight coupling of its modules suffers from certain issues. Its components are less reusable [@Sal16], increased interleaving becomes hard to maintain, all modules need to be upgraded simultaneously and are limited in the technologies they can use [@Dra17c], and evolution is generally hindered due to growing complexity [@Dra17a].

Most importantly, the main issue given against monoliths is scalability [@Dra17a]. As any single instantiation of a program executable can intrinsically merely be running on a single machine, there is a natural bound of the applications performance based on hardware limitations. Many approaches to overcome this limit(s) have been proposed over the years. Previously, the *Service-oriented Architecture* (SOA) approach gained popularity. It is based on the idea of combining the capabilities of multiple monoliths, either based on the same or different program images, by integrating them through a uniform communication channel like an *Enterprise-service Buses* (ESB) [@Fow14;@Sal16]. This approach allows to link heterogenous technologies and independent deployment, as it does not require in-memory call between these services anymore. However SOA still facilitates large monolithic applications, thus such have to be scaled by duplicating entire application instances [@Dra17b]. 

In order to overcome these limitations, the Microservice paradigm aims for separating the modules into small services in the form of dedicated applications. Therefore, SOA have been called "first generation" services, while Microservices are subsequently the "second generation" of services. As these evolved from SOA, they are thus also part of the general *Service-oriented Computing* (SOC) paradigm [@Maz16;@Dra17a]. For an in depth review on how Microservices historically evolved from a distributed systems perspective, starting with the client-server paradigm, to mobile agents technology and Service Oriented Architectures, we refer the interested reader to Salah *et al.* [@Sal16].

<!--
...

With increasing coupling and therefore interweaving, it becomes hard to maintain. Software evolution is also hindered due to growing complexity [@Dra17a], and all modules of a monolith need to be upgraded simultaniously. 

Especially modelling concurrent aspects introduces complexity due to the need for synchronization of shared state, or nondeterminism introduced by event-based approaches (like Actors) [citation needed für diesen satz]{.mind}. Strongly coupled modules tend to have a less strictly separated [wie sagt man: hier können alle möglichen dinge verschmischt werden, was die sache noch viel komplizierter macht?]{.mind}.

...

Scholars identified many more issues that come with monolithic applications [mehr? citation?]{.mind}. Such have been first encountered in the more early days in computing history. Therefore, from the early 1970s, an interrest in distributing applications accross multiple host machines arose, originally due to the limits of the machines back than [citation needed. hab ich irgendwas zu concurrency history?]{.mind}. However, with growing performance, focus shifted on concurrent programming approaches due to Moore's law, stating that the number of transistors in a processing unit (e.g. CPU) "roughly" doubles every two years. 

This does not hold exactly true anymore[^fn-moores-law] since the 2000s, for speed increasment since than is not backed by increasing transistors inside a processor, but to the trend of including multiple cores into a single CPU [@Mac11]. The importance of multicore programming increased significantely since then [citation needed?]{.mind}. 

[^fn-moores-law]: In fact, Moores original empirical observation about *doubling of components per chip* never held true very long. But over the decades various trends in semiconductor manufacturing still resulted in a rough doubling of processing power. Mack [@Mac11] gives an interresting analysis on this being simply the result of an economic will to make the law come true.

Even though the processing power increases all the time, any monolith inevidently reaches a limit when it comes to scalability. This limit is influenced by many factors, e.g. [wie gut man es eben monolith. scalieren kann??]{.mind}, but eventually reaches an upper bound based on hardware limitations of the host machine [citation]{.mind}.
-->


## Term Ambiguity


The *service* term service is used in an overloaded manner in the literature. We can identify two general meanings attributed to it. On the one hand, it refers to a computational task unit, i.e. a process, as part of a service-oriented architecture. This is the predominant intention when it is being referred to a "Microservice". On the other hand, a service also describes a specific functionality that can be utilized through an interface. This notion is known from object-orientation, where objects provide services in the form of procedures through their public interface [@Sny93]. 

In order to avoid confusion, some scholars propose a clear distinction. For example, Xu *et al.* [@Xu16] are using the term "service" exclusively for the functionality part, and refer to the component as *agent*. We will follow the example of Guidi & Montesi [@Gui09] by distinguishing between the *service engine*, that is the component deployed as a process, and the *service behavior* for the functionality a given deployed service engine offers. This terminology suits us, for it highlights the resemblance between an Actors behavior and a Microservices behavior. 


## Independence and Interaction


From the separation of modules into dedicated service applications comes such a high cohesion of the modules as well as a loose coupling among them that the services are highly independent [@Dra17a;@Dra17b;@Gui17]. The inherent fact that each service engine is a separate application implies that the engines are independently deployable [@Fow14].   

The decoupling of services also affects their state as it is conceptually isolated. Thus, services are required to refrain from sharing any resources related to memory persistence as for example databases would introduce a notion of implicit communication among services having access to it. An essential principle of the architectural style is thus the commitment to provide any service engine with its own exclusive database instances [@Fow14;@Dra17a;@New15].

Any communication between Microservices therefore has to happen across the boundaries of the service engine processes. This is called *inter-process communication* (IPC) [@Bac03]. Various forms of IPC channels exist. Examples of general mechanisms are a shared memory section between two processes within the same operating system, or Unix pipes. The Microservice idiom specifies the following requirements on service IPC [@Fow14]:

1. Communication channels should be open and provide well-defined interfaces, such that heterogenous technologies are able to employ them. 
2. Communication channels should be light-weighted, such that they are cheap mechanisms without much additional functionality besides basic message transportation.
3. Communication channels should only act as message routers, such that they transport immutable messages and do not apply data processing logic on their own. 

From the two example IPC mechanisms above, Unix pipes and shared memory, only the pipes qualify for a valid Microservice communication mechanisms. If data is in the form of text strings, it represents serialized state information of one service that is transported in an immutable way between the endpoints of the pipe. Raymond describes this in his Unix *Rule of Composition* as [@Ray03]:

> "Text streams are to Unix tools as messages are to objects in an object-oriented setting. The simplicity of the text-stream interface enforces the encapsulation of the tools." 

This satisfies the channel requirements given above. Therefore, pipes are a valid communication mechanism. However, they do not offer any specific structuring of the byte stream. An application-level protocol therefore has to be defined on top of the pipe mechanism [@Bac03]. Shared memory on the other hand faces multiple conceptional problems regarding a Microservice communication mechanism. First, messages between services are being send by modifying memory both services have access to. It is not guaranteed in general that these messages are being receiving by the indented recipient unmodified, for a third-party entity also having access to the memory could get a lock and make modifications to the data beforehand. Additionally, shared memory validates the no shared resources between services principle already defined.


## Concurrent and Distributed Building Blocks


As independently deployable applications, each Microservice is by design a dedicated process. Such are inherently concurrent on the operating system level and also facilitate parallelization on multiple cores transparently. Any communication mechanism thus has to be able to send data across the distinct address spaces which strictly isolate the states. 

Recalling the case study on process system programming in C, fork/pipe-based applications utilize Unix pipes for this. Their components too are concurrently executed through the process scheduling of the OS. It is thus worth debating whether such systems qualify for Microservice Architectures.

<!--
Any communication mechanism thus has to be able to send data between processes. Yet some valid channels (like Unix pipes) are only capable of sending messages between processes on the same operating system. 

Recalling the case study on process system programming in C, fork/pipe based applications are also executed concurrentlyy through the process scheduling of the OS. For these concurrent components have strictly isolated states through the boundries of their distinct address spaces and the communication mechanism is viable in general, it's worth debating weither such systems qualify for Microservice Architectures.
-->


<!--
....

---

Each Microservice is by design a dedicated process. As we discussed in section [#sec-concurrency-os-level], processes are inherently concurrent on the operating system level, which facilitates parallelization by default. Any microservice architecture is therefore an inherently concurrent system.

In section [#sec-ms-communication] we discussed the requirements on a communication channel between services. Any mechanism has to be able to send data between processes. Some valid channels (like Unix pipes) are also only capable of sending messages between processes on the same operating system. However, recalling the case study on process system programming in C from section [#sec-concurrent-c], such fork/pipe based systems are executed in a concurrent fashion through the process scheduling of the operating system. For the concurrent components have strictly isolated states through the boundries of their distinct address spaces and the communication mechanism is sufficient in general, it's worth debating weither such systems apply for a Microservice Architecture.
-->

The fork pattern spawns processes in a tree-like fashion, thus all components rely on a shared ancestor. Despite any child could easily replace itself by an arbitrary other program image using `exec`, the setup of the communication routes relies on an instantiation of the pipe before the fork, such that both parent and child know about it. Thus, it limits the possibility to take down or add new components independently. Pipes are therefore still rather restrictive and present a certain degree of coupling [@Bac03], such that it is difficult to replace the systems components independently.

To overcome these restriction, the construct of *named pipes* were introduced into later Unix variants, allowing processes to hook into a common pipe without a shared ancestor [@Bac03]. However, any communication route fixed at compile time, generally called *static channel naming*, limits the ability for changing topologies [@And83]. In any case, this IPC mechanism definitely does not provide communication outside the boundary of the common operating system. Thus it limits scalability by restricting the service architecture onto a single host machine, at least for the subset of services facilitating this mechanism. Network-based IPC mechanism on the other hand overcome this restriction inherently and are thus preferred for MSAs in general as they provide higher degrees of freedom regarding deployment as well as technology integration at the price of more costly data transfers (cf. fallacy 7: *transport cost is zero*) [@Cou05].

As a result, Microservices are always presume to be concurrent components supporting parallel execution. However, if they qualify for distributed components within their respective architecture is subject to the employed communication mechanism(s).


<!--
The concurrent components have strictly isolated states through the boundries of their distinct address spaces (all child states are full replicas of their parents state) and employ a communication mechanism that [...TODO...]{.mind}. Thus it is worth debating weither such systems apply for a Microservice Architecture.
-->

<!--
We've argued that Unix pipes are a viable queue-like mechanism sufficing the requirements on communication channels for Microservices. 
-->

<!--
Fork/pipe based systems are executed in a concurrent fashion through the process scheduling of the operating system. The concurrent components have strictly isolated states through the boundries of their distinct address spaces (all child states are full replicas of their parents state) and employ a communication mechanism that [...TODO...]{.mind}. Thus it is worth debating weither such systems apply for a Microservice Architecture.
-->

<!--
Though isolation is ensured and communication adequate, it is still difficult to replace the systems components independently. The fork pattern spawns processes in a tree-like fashion, thus all components rely on a shared ancestor. Despite any child could easily replace itself by an arbitrary other program image using `exec`, the setup of the communication routes relies on an instantiation of the pipe before the fork, such that both parent and child know about it. Thus it limits the possibility to take down or add new components independently. Pipes are still rather restrictive and  present a certain degree of coupling [@Bac03]. 
-->


## Size, Scope and Granularity {#sec-ms-granularity}


Bonér [@Bon17] criticizes the term "micro" for it encourages debating the actual *size* of a service. Any size definition requires a metric to be able to make comparisons and argue up to which limit an application may be called *Micro*service. Therefore, developers focus on metrics like *Lines of Code* up to more obscure ones, e.g. the reported *Two Pizza Team* size, where a service is written and maintained by a team that can be fed by two pizzas[^fn-two-pizza-team] [@Fow14]. These discussions are misleading.

[^fn-two-pizza-team]: Assuming an arbitrary pizza size, this either suggests very small teams, or really big pizzas.

Instead, Bonér argues, a notion of size should refer to the "scope of responsibility". A guideline towards this can once again be the already referred to Unix philosophy [@Ray03]. It suggests that programs should have a well-defined, limited scope, such that more complex functionality can be realized by composing multiple of these simple programs. This concept is also found in object-oriented design, where it is known as the *Single Responsibility Principle* (SRP) of objects [@Gui17].

In the Microservice context however, authors do not refer to the SRP a lot. Instead, they tend to phrase it *bounded context* [@Dra17a;@Dra17c;@Maz16], by arguing that services should be an aggregation of functionality around a single business capability. This divergence of granularity is one of the major evolutionary changes from SOA to Microservices [@Mon16a;@Gui17].

However, to fine a granularity can become an issue. In a distributed setting, it is always a balance between the number of messages to be sent versus the performance implications to be expected thereof. Latencies of network channels, processing time of addressed services and delay penalties resulting from unavailability have to be considered when designing the granularity of Microservices [@Sha17a].


## Service-oriented Programming


Until now, Microservices have been regarded in the light of a software architectural style. Within, the building blocks are all truly isolated components instantiated from independently executable artifacts, merely linked by rather loosely coupled message passing communication channels. It has been argued that due to these characteristics the perspective in the literature (both academic as well as industrial) has had a focus on the operation of the service engines, that is their *deployment* [@Gui17;@Xu16]. After all, the deployment context of MSA is the origin of its concurrent nature, that is independent processes of the OS or network. In this section however, we want to favor an argumentation towards a linguistic viewpoint on Microservices instead.

Programming paradigms build upon respective conceptual constructs, e.g. objects in OOP or functions in Functional Programming. In more reject time, a new paradigm called *Service-oriented Programming* (SOP) [@Gui09;@Mon14] emerged. It builds upon the Service-oriented Computing approach emphasized by SOA and subsequently Microservices and introduces it into programming language design. 

Services become first-class entities of the language and are the smallest programmable constructs. Instead of a single executable artifact, such service-oriented programs compile into multiple executables, one for each of the service constructs in the source code. Initially the conception of SOP was an aiming for an evolutionary step from combining the object-oriented paradigm with SOA ideas to program distributed systems. When the Microservices principles finally distilled, it was found that compilation of SOP languages essentially produced Microservice Architectures. Thus, instead of the total technology freedom of the MS paradigm, SOP languages are a separate approach towards the Microservice style [@Mon14;@Gui17].

Multiple prototype languages facilitating the service-oriented programming concept exists. Two will merit attention here:

* CAOPLE
  : One attempt of a service-oriented programming language is *CAOPLE* [@Xu16]. It's basic programming constructs are so-called *agents* (services), which provide a very strict notion of state encapsulation, autonomy and well-defined communication interfaces. Unlike traditional Microservices, these agents are directly executed by the host operating system, but are running on a dedicated virtual machine called *CAVM-2* instead, which is focusing on providing lightweight dynamic deployment of services compared to using container technology. Additionally, it is optimized for running large quantities of services in a lightweight manner, as well as abstracting network distribution.

* Jolie
  : Currently the most advanced and scientifically best described service-oriented language is *Jolie* [@Mon14;@Mon16b;@Gui17;@Min17;@Gui09]. We will therefore use it as the primary linguistic example throughout the remainder of this thesis. A Jolie program defines services which are described by two basic aspects. First, the *behavior* expresses all functionality offered by the service, and makes it available on so-called *communication ports*. Second, the *deployment* describes how a service is used, i.e. the communication technology, addresses of exposed functionality and data protocols. These two main parts of any Jolie program indicate the strong *separation of concerns* between what we've designated service behavior and service engine. It is even expressed syntactically on the root level of the program structure:

  : ~ center
    `Program \(void|::=\) D \(return|main\) { B }`{language:"java"; class:"pretty"}
    ~
    
  : The languages syntactic rules prevent any deployment expression (`D`{.pretty}) from being introduced into behavioral expressions (`B`{.pretty}) and vice versa. The only connection between behavior and deployment are the communication ports. They are abstractly used by the behavior, and concretely defined by the deployment. As such, behavior and deployment are complemental. As a scientific prototype language, it incorporates many interesting concepts. There is no notion of concurrency beyond the implicit from executing services as OS processes, and the `concurrent`{color:blue} primitive as one option for the so-called *execution modality*. In this case, upon receiving a message on a communication port, a Jolie service will spawn a dedicated process such that the behavior is executed in a separate local memory space (cf. the fork approach in the C processes case study), thus allowing concurrent message processing. Among other concepts, there is complex message routing supported through *correlation sets* and the facilitation of transparent delegation by the so-called *aggregation* primitive which extends a service's interface with the interfaces of other services.

For Microservices share many similarities with objects in general [@Dra17a], such service-oriented languages tend to have many analogies to object-oriented languages, as the computational units in both paradigms provide functionality via a public interface [@Xu16;@Sny93]. However, these mark also the most important difference to objects. The former facilitate information hiding and encapsulation in a *shared memory* setup, while the later solely rely on *message passing* [@Dra17a]. Besides this, advanced object-oriented concepts are also possible. For example, Jolie has static type checking for service interfaces [@Min17], and CAOPLE even supports polymorphism via an inheritance mechanism.


