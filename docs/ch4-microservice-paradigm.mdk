
The Microservice Paradigm {#ch-microservice-paradigm}
=========================



~LitNote
* Unlike the Actor model, Microservices were not invented as a specific form of computation, but emerged as the result of an historical evolution. --> von mir gescgrieben, muss ich irgendwie in den kontext setzen
* Dragoni [@Dra17a] calls it "Service-Oriented Architecture and Programming from the large to the small."
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
* [@Maz16] "Towards Microservices and Beyond: An incoming Paradigm Shift in Distributed Computing"
* [@Fra17] "Architecting Microservices"
* [@Sha17a] "Microservices: Granularity vs. Performance"
* [@Dra17b] "Microservices: How To Make Your Application Scale"
* [@New15] "Building Microservices"
* [@Fow14] "Microservices: a definition of this new architectural term"
~

At the beginning of our current decade, a new architectural term called *Microservice Architecture* emerged. This concept was originally born from the industrial need to break the scalability barrier that monolithic applications inevidently reach [citation needed]{.mind}. Only later the scientific community gained interrest in this paradigm, which lead to an explosion of contributions on this concept. Yet, academia still has some trouble to settle on a common basic definition on the overall concept(s) determining the microservice paradigm [@Has16]. Fowler[^fn-microservice-term] and Lewis [@Fow14] gave the first overall review to the microservice concept, and is the original source most scientists refere to. But they focus on describing the common characteristics from a more practical engineering perspective. Dragoni et al. [@Dra17a] tried to give a general, conceptial description, and therefore we will be founding our discussion of this paradigm on the definitions they provide.

[^fn-microservice-term]: Fowler points out that he heard the term first in 2011, where it has been conceived at a workshop to summarize the participants ideas. 

Historically, software systems often have always been implemented in a so-called *monolithic* setup, where all the source code is compiled into one single artifact that can be executed on a machine. This is based on the level of abstraction mainstream programming languages provide to break down complexity of the programming task: *modules*. They allow to logically separate concerns ["of ???" - diesen Teil kann ich sicher etwas ausschmücken und auf B. Meyer verweisen]{.mind}, yet the transformation from the abstraction of program code to machine code leads to a result where the different module components are merged into one unified construct: the (monolithic) *executable*. By inversion of argument, a monolith is an application of modules that cannot be executed independently [@Dra17a].

These naturally introduces a relative strong form of coupling, for each module tends to expect the presence of any other module [citation needed]{.mind}. *Coupling* is a **metric that describes the amount of dependencies between components** [so irgendwie ?]{.mind}. It is usually effected by the kind of interaction between the components. Any form of in-memory call communication eases the tightening of coupling, for it is a relatively easy and direct way of addressing components [frei erfunden, hat das mal jemand so argumentiert?]{.mind}.

Any application subject to tight coupling of its modules suffers from certain issues. With increasing coupling and therefore interweaving, it becomes hard to maintain. Software evolution is also hindered due to growing complexity [@Dra17a]. Especially modelling concurrent aspects introduces complexity due to the need for synchronization of shared state, or nondeterminism introduced by event-based approaches (like Actors) [citation needed für diesen satz]{.mind}. Strongly coupled modules tend to have a less strictly separated [wie sagt man: hier können alle möglichen dinge verschmischt werden, was die sache noch viel komplizierter macht?]{.mind}.

Scholars identified many more issues that come with monolithic applications [mehr? citation?]{.mind}. Such have been first encountered in the more early days in computing history. Therefore, from the early 1970s, an interrest in distributing applications accross multiple host machines arose, originally due to the limits of the machines back than [citation needed. hab ich irgendwas zu concurrency history?]{.mind}. However, with growing performance, focus shifted on concurrent programming approaches due to Moore's law, stating that the number of transistors in a processing unit (e.g. CPU) "roughly" doubles every two years. 

This does not hold exactly true anymore[^fn-moores-law] since the 2000s, for speed increasment since than is not backed by increasing transistors inside a processor, but to the trend of including multiple cores into a single CPU [@Mac11]. The importance of multicore programming increased significantely since then [citation needed?]{.mind}. 

[^fn-moores-law]: In fact, Moores original empirical observation about *doubling of components per chip* never held true very long. But over the decades various trends in semiconductor manufacturing still resulted in a rough doubling of processing power. Mack [@Mac11] gives an interresting analysis on this being simply the result of an economic will to make the law come true.

Even though the processing power increases all the time, any monolith inevidently reaches a limit when it comes to scalability. This limit is influenced by many factors, e.g. [wie gut man es eben monolith. scalieren kann??]{.mind}, but eventually reaches an upper bound based on hardware limitations of the host machine [citation]{.mind}.

Many approaches to overcome this limit have been proposed over the years. All of them have distribution in mind [faderer satz geht ja nimma...]{.mind}. Previously, the *Service Oriented Architecture* (SOA) approach gained popularity. It is based on the idea of interconnecting the capabilities of multiple monolithic applications, by connceting them on a single, uniform communication channel. Such integration mechanisms, like the so-called *Enterprise-service Buses* (ESB), however [...sind auch nicht gut]{.mind}

SOA still builds upon the idea of large monolithic applications, and all their fallities [?]{.mind}. In order to overcome these limitations, the idea of dividing up these monoliths based on their functionalities ["bruchlinie anhand der funktionalität"?]{.mind} came up. Such was borne the idea of *Microservices* (MS).

For an in depth review on how Microservices historically evolved from a distributed systems perspective, starting with the client-server paradigm, to mobile agents technology and Service Oriented Architectures, we refere the interrested reader to Salah et al. [@Sal16].

The basic idea of a Microservice is to put related functionality [gibt ne bessere formulierung]{.mind} into a dedicated process, and have it provide this via an interface for a lightweight communication mechanism [citation needed]{.mind} - in contrast to the heavyweight channels as ESB 

A *Microservice Architectures* (MSA) is a software architecture composed of Microservices [citation needed]{.mind}.

Any MSA is composed of so-called *Microservices* (MS), basic building blocks, each with their own functionality and connceted via lightweight, open communication protocols. 


 In order to 

In this chapter, we will analyze the concepts that make up the Microservice paradigm. 

[@Dra17a] defines:

~ Definition {#def-monolith; caption: "Monolith"}
A monolith is a software application whose modules cannot be executed independently.
~   

~ Definition {#def-microservice; caption: "Microservice"}
A microservice is a cohesive, independent process interacting via messages.
~   

## Microservice Principles

~ Epigraph { caption: "Groucho Marx"}
These are my principles. If you don't like them, I have others.
~

~LitNote
* [@Bro16]
    * "larger grained APIs"
    * "deployment: serveral small applications implementing part of the whole"
    * "strictly limit types of network connectivity that a service can implement to achieve maximum simplicity"
    * "more choices via polyglot programming / polyglot persistence"
    * "avoid thight coupling via implicit communication through databas"
    * "all communication from service to service must be through the service API"
    * "different services evolve at different rates; allows that evolution to proceed at is own natural pace"
    * "horizontal scaling of single services"
~

No shared state, etc

## Service Communication {#sec-ms-communication}


~ Epigraph { caption: "Doug McIlroy"}
One favorite pipeline was `bc | speak` — a talking desk calculator. It knew number names up to a vigintillion.
~


~LitNote
Open/well-defined Communication Interface
~

Any communication between microservices has to happen accross the boundries of the service processes. This is called *inter-process communication* (IPC) [citation needed]{.mind}. Variouse forms of IPC channels exists. Examples of simple IPC mechanisms are a shared memory section between two processes within the same operating system, or Unix pipes.

The microservice idiom specifies the following requirements on service IPC:

1. Messages between services should be immutable [citation needed]{.mind} 
2. Communication channels should be light-weighted [citation needed]{.mind} 
3. Communication channels should only act as message routers, and therefore should not introduce data processing logic of their own [citation needed]{.mind} . Fowler calls this characteristic "smart endpoints and dumb pipes" [@Fow14]

From the two example IPC mechanisms above, Unix pipes and shared memory, only the pipes qualify for a valid microservice communication channel. Pipes are a form of byte stream between processes [@Bac03]. If data is in the form of text strings, it represents serialized data (= state information) of one service that is transported in an immutable way between the opposite endpoint of the pipe[^fn-unix-pipes]. Raymond describes this in his Unix *Rule of Composition* as [@Ray03]:

> "Text streams are to Unix tools as messages are to objects in an object-oriented setting. The simplicity of the text-stream interface enforces the encapsulation of the tools". 

This satisfies the channel requirements given above. Therefore pipes are a valid communication mechanism. However they do not offer any specific structuring of the byte stream. An application-level protocol therefore has to be defined ontop of the pipe mechanism [@Bac03]. Shared memory on the other hand faces multiple conceptional problems regarding a microservice communication mechanism. First, messages between services are being send by modifying memory both services have access to. It is not guaranteed in general that these messages are being receiving by the indented recipient unmodified, for a third party entity also having access to the memory could get a lock and make modifications to the data beforehand. Additionally, shared memory validates the no shared resources between services principle already defined.

[^fn-unix-pipes]: Unix pipes are often used in a *pipe and filter* combination. This can cause the impression that pipes are able to perform data transformation (= filter) operations when multiple filters are chained up into a so-called *pipeline*, and are therefore not guaranteed to transport data unmodified. However, the pipe itself is not applying any processing logic, only endpoints are doing data transformation. A pipeline will therefore in general present a modifying communication route, but each single pipe is transporting immutable data. 

## Inherent Concurrency and Distribution

~Todo
Eigentlich gehört der inhalt dieses kapitels soweit er jetzt hier steht zur "Service Communication" section oben. Und das mit der inherent Concurrency ist auch schon erklärt. Ich sollte dann einfach abschließen und weiter die Distribution überführen?
~

Any microservice within an MSA is by design a dedicated process. As we discussed in section [#sec-concurrency-os-level], processes are inherently concurrent on the operating system level, which facilitates parallelization by default. Any microservice architecture is therefore an inherently concurrent system.

In section [#sec-ms-communication] we discussed the requirements on a communication channel between services. Any mechanism has to be able to send data between processes. Some valid channels (like Unix pipes) are also only capable of sending messages between processes on the same operating system. However, recalling the case study on process system programming in C from section [#sec-concurrent-c], such fork/pipe based systems are executed in a concurrent fashion through the process scheduling of the operating system. For the concurrent components have strictly isolated states through the boundries of their distinct address spaces and the communication mechanism is sufficient in general, it's worth debating weither such systems apply for a Microservice Architecture.

The fork pattern spawns processes in a tree-like fashion, thus all components rely on a shared ancestor. Despite any child could easily replace itself by an arbitrary other program image using `exec`, the setup of the communication routes relies on an instantiation of the pipe before the fork, such that both parent and child know about it. Thus it limits the possibility to take down or add new components independently. Pipes are still rather restrictive and present a certain degree of coupling [@Bac03], such that it is difficult to replace the systems components independently.

To overcome these restriction, the construct of *named pipes* were introduced into later Unix system, allowing processes to hook into a common pipe without a shared ancestor [@Bac03]. However, this IPC mechanism definitely does not provide communication outside the boundry of the common operating system. Thus it limits scalability by restricting the service architecture onto a single host maschine, at least partially for the services facilitating this communication channel.

<!--
The concurrent components have strictly isolated states through the boundries of their distinct address spaces (all child states are full replicas of their parents state) and employ a communication mechanism that [...TODO...]{.mind}. Thus it is worth debating weither such systems apply for a Microservice Architecture.
-->

<!--
We've argued that Unix pipes are a viable queue-like mechanism sufficing the requirements on communication channels for Microservices. 
-->

<!--
Fork/pipe based systems are executed in a concurrent fashion through the process scheduling of the operating system. The concurrent components have strictly isolated states through the boundries of their distinct address spaces (all child states are full replicas of their parents state) and employ a communication mechanism that [...TODO...]{.mind}. Thus it is worth debating weither such systems apply for a Microservice Architecture.
-->

<!--
Though isolation is ensured and communication adequate, it is still difficult to replace the systems components independently. The fork pattern spawns processes in a tree-like fashion, thus all components rely on a shared ancestor. Despite any child could easily replace itself by an arbitrary other program image using `exec`, the setup of the communication routes relies on an instantiation of the pipe before the fork, such that both parent and child know about it. Thus it limits the possibility to take down or add new components independently. Pipes are still rather restrictive and  present a certain degree of coupling [@Bac03]. 
-->



...

Any form of communication has to happen via an inter-process communication mechanism. Some choices for such mechanism include messaging via a form of network interface like REST (__RE__presentational __S__tate __T__ransfer) or AMQP (__A__dvanced __M__essage __Q__ueue __P__rotocol) 


Channels for distributed communication are more likely to provide options to apply some data operation of their own, which would stress the third requirement on microservice communication channels. [citation needed - außer ich argumentiere hier mehr anstatt einfach zu behaupten, zB über spaces wie XVSM]{.mind} 

## Service Granularity (Size, Scope and Granularity) {#sec-ms-granularity}

~LitNote
* "micro should refere to the scope of responsibility, not the lines of code"
* Size vs. Number of Services
* [@Par72] "On the Criteria To Be Used in Decomposing Systems into Modules"
* [@Sha17a] "Microservices: Granularity vs. Performance"
* "key difference between SOA and MS lies in granularity (in SOA, all services are parts of a monolith)" [@Mon16a]
~

...

Bonér criticizes the term "micro" for it encourages debating the actual size of a service [@Bon17]. Any size definition requires a metric to be able to make comparisons and argue up two which limit an application may be called "microservice". Therefore, developers focus on metrics like *Lines of Code* up to more obscure ones, e.g. the reported *Two Pizza Team* size, where a service is written and maintained by a team that can be fed by two pizzas[^fn-two-pizza-team] [@Fow14]. These discussions are missleading.

[^fn-two-pizza-team]: Assuming an arbitrary pizza size, this either suggest very small teams, or really big pizzas.

## Conceptual Roots

## Relation to Processes Calculi {#sec-ms-process-calculus}

~LitNote
* <https://en.wikipedia.org/wiki/Process_calculus>
* Können MS mit CSP als theoretische Grundlage ihrer Concurrency modelliert werden. Denn später kann ich die Vorteile von Actors gegenüber MS besonders bezüglich Elasticity und Discovery mit anderer Literatur beschreiben. Ich muss die CSP Argumentation nur schon hier einführen. 
* siehe <https://en.wikipedia.org/wiki/Actor_model_and_process_calculi_history>
    * scheint weniger CSP, als CCS und pi-calculus zu sein
* JOLIE basiert auf der theorie eines Process-calculie (steht in "Microservice: a language-based approach"). Dh es müsste zumindest bei denen etwas genauer beschreiben sein, wie man das Konzept von Service-oriented Programming zusammen mit Process calculi bringt. Da kann ich mir hoffentlich eine Seite aus den Fingern saugen
* Es gibt zB auch calculi die "mobility" unterstützen
    * *Robin Milner, Joachim Parrow and David Walker. A calculus of mobile processes Computer Science Dept. Edinburgh. Reports ECS-LFCS-89-85 and ECS-LFCS-89-86. June 1989. Revised Sept. 1990 and Oct. 1990 respectively.*
    * *Cédric Fournet, Georges Gonthier, Jean-Jacques Lévy, Luc Maranget, and Didier Rémy. A Calculus of Mobile Agents CONCUR 1996.*
    * *Tatsurou Sekiguchi and Akinori Yonezawa. A Calculus with Code Mobility FMOODS 1997.*
* *Nancy Lynch and Michael Fischer. On describing the behavior of distributed systems in Semantics of Concurrent Computation. Springer-Verlag. 1979.*
* *Nissim Francez, C.A.R. Hoare, Daniel Lehmann, and Willem de Roever. Semantics of nondetermiism, concurrency, and communication Journal of Computer and System Sciences. December 1979.*
* Für ganz allgemeinen Blabla: *He Jifeng and C.A.R. Hoare. Linking Theories of Concurrency United Nations University International Institute for Software Technology UNU-IIST Report No. 328. July, 2005*
* Asynchronous Sequential Processes (ASP) --> "D. Caromel, L. Henrio, and B. P. Serpette. Asynchronous sequential processes. Inf. Comput., 207(4):459–495, Apr. 2009"
    * [@Kos16] vergleich diese mit Active Objects, nur mit gröberer Granularität
~

Among the theories of formulating concurrent computation is found a family called *process calculi*. Such define mathematical models composed of so-called *processes* which are communicating within the laws and conditions layed out by the calculus [citation]{.mind}.

Depending on the calculus, communication may be of a synchronous (e.g. in the Communicating Sequential Processes - CSP [citation]{.mind}) or asynchronous (like Asynchronous Sequential Processes - ASP[citation]{.mind}). The unifying properties of all these calculi are that they avoid any kind of shared state and rely on message-passing for communication [citation]{.mind}. This already bears resemblence to the Microservice paradigm.

In fact, some scientific approaches on modelling interacting processes, which were also found to be well suited for expressing Microservices, like Jolie[citation]{.mind} or CAOPLE[citation]{.mind}, have their theoretic foundation in a process calculus [citation]{.mind}. 

~Todo
In [@Swa14] wird beschrieben, dass Process Calculi auch nur eine Msg nach der anderen abarbeiten. Ist das generell so? Weil MS können intern schon Concurrent sein. Dann müsste ich explizit darauf hinweißen, dass mit Process Calculi zwar MS Architecturen beschrieben werden können, aber nicht jeder Microservice deswegen einem Process Calculus entsprechen muss. Irgendwo sollte da Literatur bei diesem "MS: Language-based Approach" sein!
~

### Language-based Approaches

~LitNote
* Jolie, CAOPLE
* grundstein in Process Calculi
* hier die basis für die spätere Diskussion zu Behavioural Types legen (die ich schon in der diskussion bei design by conract bringen will, ansatt erst in der Conclusion anteaser)
* [@Gui17] "Microservices: a Language-based Approach"
* [@Dra17a] "Microservices: yesterday, today, and tomorrow"
* [@Xu16] "CAOPLE : A Programming Language for Microservices SaaS"
~

The Microservice approach has gain much attention first in the industry and nowadays well as in the academic community. As such, many different research disciplines focus on [work on this...]{.mind}.

From a scientific point of view, the freedom provided by the principles can be rather unsatisfactory. It is difficult to reason about services in general, for they only have to comply to rather abstract [???]{.mind}

... for service composition is not [vorgegeben]{.mind} by dedicated abstractions [@Gui17].

do not provide dedicated abstractions for service composition.

...

* JOLIE
  : Jolie [@Mon14a;@Gui17] ...

* CAOPLE
  : CAOPLE [@Xu16] ...



*CAOPLE* is a ....


### Behavioural Types

Session Types, Process Types, etc.