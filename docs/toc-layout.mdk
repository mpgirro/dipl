* Abstract
* Preface
* Acknowledgements
* Table of Contents
* Introduction
    * Motivation
    * Scope of this Thesis
    * Methodology used
    * Road Map
* Programming Paradigms
    * Imperative, Structured and Procedual Programming
    * Object-oriented Programming
        * History of Objects: Simula and Smalltalk
        * Modular Programming
    * Functional Programming
    * Event-Driven and Flow-Driven Programming
    * Logic and Constraint Programming
    * Role-based Programming
    * Other Programming Paradigms
* Models of Concurrent Computation
    * Basic Concepts in Concurrency
        * Execution Order and Nondeterminism
        * Concurrency at the Programming Language Level
        * Concurrency at the Operating System Level
    * Threads, Locks and Shared State
        * Case Study: the Java Concurrency Model
    * Actors and Active Objects
        * Case Study: the Scala Concurrency Model
    * Software Transactional Memory
        * Case Study: the Clojure Concurrency Model
    * Event-driven Concurrency
        * Case Study: the JavaScript/node.js Concurrency Model
    * Parallel Architecture
        * Inter-process Communication
    * Concurrency Models and Distributed Systems Similarities
    * Other Approaches and Concurrency Primitives
* The Microservice Architecture Style
    * Service-oriented Systems
    * Key Concepts
    * Architecture Properties
        * Geographically Distributed Code: Concurrency Beyond Multiple Cores
        * Resilience
    * Architectural Elements
        * Communication Channel (mostly HTTP)
        * Database per Service
        * API Gateway: Request Broker and Curcuit Breaker
            * Case Study: Hysterix and Akka
    * Quality Issues
        * Software Quality Attributes
            * Performance
                * Case Study: JSON in Service as a Performance factor (siehe [@OBM05] p.15)
    * Design Concerns
        * Smart endpoints and dumb pipes (geklaut von M.Fowler)
        * Failure is inevitable
        * Service Granularity: Size vs. Number of Services
        * Satisfaction of local vs. global Quality Properties
        * Polyglot Programming
    * Patterns (Kapitel notwendig?)
        * Event-driven architecture
    * Development, Debugging and Maintenance
* The Paradigms/Concepts Analogioes of MSA (statt: Towards a (Micro)service-Oriented Paradigm: A Look at Analogies)
    * Data Abstraction
        * Encapsulation
        * Information Hiding
    * Identity and Equality
    * SOLID design principles
    * Message Passing: Avoiding Shared State
    * Design by Contract and REST
        * REpresentational State Transfer 
        * Pre- and Postconditions
        * Invariants and History-constraints
    * Behavioural Tyes and Session Types
        * Substitution and Behaviour
        * Subtyping and SOA
        * Behavioural Contracts
        * Neutral Interface Technology vs Formal Specifications (Contracts)
    * Choreographies
    * Delegation: Sharing partial implementation
        * Case Study: Delegation in JavaScript
    * Clients Request Services
    * The Case of Actors vs Active Objects
        * A Case for Actors
        * A Case for Active Objects
        * A Case against Actors and Active Objects
        * A Conflation of Distinct Concepts
    * Event-based View
    * Flow-based View   
* The Microservice Concurrency Model
    * Immutable Messages
        * Asynchronouse Dataflow with Synchronous Messages
    * Message Processing and Transactional Memory
    * Applicability for Concurrent Problems
    * Applicability for Parallel Problems
    * Resilient Code
    * Geographically Distributed Code
    * Distributed Computation
    * Concurrent Process Types for Services
* Scenario-based Experiment
    * Scenario
    * Prototype using Standard Models of Concurrency
        * Case Study: Why do Java Programmers like MSA?
    * Prototype based on a Micorservice Architecture
    * Findings
* Discussion
    * Comparision of Attributes/Features/etc
    * Comparison of the MSA-Concurrency-Model with the others (based on the Properties they share with Paradigms)
    * Why Developers adopt MSA
    * Problems of Developers with Concurrency Models
        * Case Study: Why Do Scala Developers Mix the Actor Model with other Concurrency Models?
    * Mixing Concurrency Models
    * Requirements on a Language/Model to be equally powerful as MSA
        * By Nature of Problems (Concurrent/parallel/both)
        * By Parallel Architecture
        * Resilience against common Problems
        * Geographical Distribution
    * Alternatives to MSA
        * Extensions to Mainstream Languages
            * Distributed Erlang
                * Scalability and Reliability
            * C++ (new Operator)
        * Dedicated Programming Languages
            * Jolie
            * Silo
            * Orco
        * Plattform and Middleware-based Approaches
            * XVSM/MozartSpaces
* Outlook
    * Services as First-Class Citizens
* Conclusion