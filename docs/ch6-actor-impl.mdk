
Actor-based Implementation {#ch-actor-impl}
==========================


~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~


This chapter covers the conceptualities used to implement the concurrent system outlined in the previous chapter using an Actor-based programming approach. The focus will be on the linguistic support provided by the used framework to realize the requirements, that is its support for the properties of the Actor model and the provided programming abstractions for succinct expression of communication and synchronization between Actors, as is suggested by scholars [@Kar09;@Kan12;@Agh99]. Efficiency considerations will be part of chapter [#ch-evaluation].

It is important to realize that although there is *the* conceptual model, there are numerous system implementations available through various forms of interfaces, either integrated into the programming language or as a library [@Kos16]. These systems are all based on the theoretical model, but may choose to compromise some of the semantic properties in order to increase efficiency [@Kar09]. Such considerations are relevant when evaluating linguistic support.

Echo is based on an Actor variant called Akka [@Akka]. It is available for the JVM through bindings for Java and Scala but was later ported to other ecosystems such as .NET and JavaScript runtimes (through Scala.JS). The .NET variant (called *Akka.NET*) is to our knowledge not able to interweave with the original JVM version at the moment. Because our solution is solely based on the JVM, all following discussions will refer to the capabilities of Akka's original variant.

Akka is theoretically based on Agha's vision of the Actor model, and harnesses its potential for distributed problem solving [@Kos16]. An archetype has been Erlang. It is designed as a toolkit collection consisting of several libraries, able to be used in arbitrary combination based on actual need of them. The Actor runtime system offered is a lightweight execution environment based on work stealing thread-pools with local task queues which schedule the Actor execution [@Hal12].

As of Scala version 2.10, Akka replaces the default Actor implementation offered by Scala [@Hal12]. We will therefore refer to the former as *Scala Actors* in contrast to *Akka Actors*. Among the reasons were the better performance, transparent Actor addresses, expressing resilience as well as fault tolerance [@Tas13]. In fact, [@Reh13] found that Akka Actors have up to 10 times higher message throughput and a network latency under 1ms, in contrast to 0.2 seconds to Scala Actors. 


## Striving for Isolation {#sec-actor-isolation}


While Actors encapsulate state conceptually, in practice their *full isolation* must be ensured, such that there is no shared state at all. This is essential to guarantee safety properties, respectively prevent data races and state modifications [@Hal12;@Kan12]. However, Akka offers interfaces for Scala and Java. Both languages support object-orientation in an imperative programming style - even though Scala is intended to be a functional programming language. Thus, as is with most library-based Actor systems running on execution environments supporting shared-memory multithreading like the JVM, Akka cannot ensure isolation by itself [@Kos16].

Therefore it is especially interesting how the Isolated Turn Principle has to be handled with Akka, because, as was outlined in &sect; [#sec-actor-messaging-encapsulation], internal state of an Actor must only be allowed to be modified from within the Actor itself to preserve the model semantics.


### Issue of Data Hiding


As was pointed out, Akka's Actor system is capable of providing a transparent interface for component communication that might exist within the same local scope (same JVM) or remote scope (distinct JVMs). In the first case, different notions of state have to be taken into account. Kniesel [@Kni96] defines *weak state* as the state given through an objects instance variables. *Strong state* is the combination of *local state* (the objects instance variables) and *transient state* (the state of objects referenced by instance variables). 

Actor semantics implies the need for a strict conception of encapsulation where the strong state is exclusive to the Actor, i.e. no mutable local state must be exposed outside nor mutable transient state imported into the scope of the Actor. Violation of this requirement leads to overlapping (shared) mutable state, which is in contrast to the message passing semantic of the model.

*Visibility* is a property of an object's variables and methods given they are part of the object's interface [@Kni96]. It is a concern for encapsulation and subsequently shared mutability [@Sub11; @Goe06]. Java for example offers multiple granularities for visibility of class fields. The following code snippet illustrates the resulting problem:

``` {language:java}
public class Foo extends UntypedActor { 
    public String bar; 
    public static Props props() {
        return Props.create(Foo.class, () -> new Foo());
    }
    @Override
    public void onReceive(Object msg) { /* handle msg */ }
}
```

Field `bar` in class `Foo`{language:java} has been given *external visibility* by declaring it to be `public`{language:java}. Thus it is part of any object of type `Foo`{language:java}s external interface and therefore influencing the objects encapsulation [@Kni96]. From visibility follows accessibility, such that `bar` is also accessible from outside the scope of `Foo`{language:java}, and for it is not declared `final`{language:java} it may be modified the same way too. This violates Actor semantic requirements. 

Any Java-based Actor implementation therefore faces the potential problem that custom written Actor classes might easily break the required model semantic. In order to cope with this, object-oriented implementations often offer APIs where interaction with an Actor instance is not issued directly through the instances method interfaces, but instead via constructs like [@Hal12]:

``` {language:java}
final ActorRef foo = system.actorOf(Foo.props());
```

An instance of `Foo`{language:java} is not directly created using the `new`{language:java} keyword as is custom in Java, but by using a factory method `actorOf` that hides the actual instantiation. Using `props()` is common to wrap the creating Java 8 lambda. For Java lambdas are basically functional closures[^fn-clojure], they only allow to access effectively `final`{language:java} fields inside the lambda scope, preventing the exposure of mutable state to any constructor. Of course, this is only true for the `final`{language:java} field itself, but not its members (cf. Java case study in &#167; [#sec-concurrency-language-level]).

[^fn-clojure]: Not to be confused with *Clojure*, a dialect of the programming language Lisp for the JVM.

Only a proxy object of type `ActorRef`{language:java} is exposed to the user. `ActorRef`{language:java} instances do not have the external interface of the Actor class they represent, but only expose a variety of methods for sending messages to the Actor, which will then be delivered to and consumed by the Actor through its `onReceive` method [@Sub11].

This has the benefit that no direct contact with an Actor instance object is possible, preventing both visibility and accessibility to any fields, or method calls. Additionally, the communication through an `ActorRef`{language:java} proxy enables *location transparency* [@AkkaActor].


### References and Immutability 


Preventing visibility of Actor fields and methods is not sufficient for guaranteeing the required strong state encapsulation on the JVM. The method signature of `onReceive`{language:java} indicates that messages are received with type `Object`{language:java}. Though Java has pass-by-value method parameters, any variable for a non-primitive type (`byte`{language:java}, `int`{language:java}, `char`{language:java}, etc.) is actually a reference variable, storing the address to an object. Thus, a passed by value parameter is a copy of the address of the object it represents [@Gos15]. This means that any message sent between Actors contains a reference to an object representing the message[^fn-java-pass-by-value]. In general, this reference may point to *one and the same* object, for Akka only serializes messages in case both counterparts are not within the same JVM [@Sub11]. In this case, given object is therefore in the scope of both the sending and the receiving Actor, introducing shared state, which is in contrast to the strong state encapsulation requirement.

[^fn-java-pass-by-value]: This causes the illusion that Java has pass-by-reference parameters. It does not.

However, messages are meant to represent snapshot information of a state at a given point in time. Therefore, shared state is not a problem if it refers to immutable snapshots, such that there is no memory with read-write or write-write access by two distinct Actors [@Kos16], i.e. the facts cannot be modified by any of the holders. Thus the encapsulation requirement explicitly refers to *mutable* strong state. Immutability avoids what Akka calls the *shared mutable state trap* [@AkkaJMM]. 

One option for Scala is to use `case class`{language:scala} constructs, which are immutable by default except for the transient state introduced through constructor parameters [@AkkaActor]. Java offers less syntactic support for expressing immutability. The property is neither formally defined in the *Java Language Specification* nor the *Java Memory Model* [@Gos15; @Goe06]. However, the basic requirement is to have `final`{language:java} fields only[^fn-java-immutability]. This means that the transient state through internally referenced objects must be marked `final`{language:java} too. We've found that libraries utilizing source-level annotation processing[^fn-immutables-lib] provide useful abstraction for generating value objects. Such use annotated `interface`{language:java} declarations to generate consistent implementations offering builders and factory methods for instantiation [@Goe06]. 

[^fn-java-immutability]: From a technical point of view, a class can have non-`final`{language:java} fields and still instantiate immutable objects. `String`{language:java} is a prominent example. However, deeper insight into the Java Memory Model is required. Goetz gives an outline of the principal approach [@Goe06, p.47].  
[^fn-immutables-lib]: Such as <https://immutables.github.io> for example.

These restrictions still cannot even prevent all obstacles Java and Scala offer to break model semantic. Nothing can prevent an Actor from sending its own `this`{language:java} reference to another Actor. This alone is to be refrained at all times per se, for it breaks location transparent access to the Actor. Additionally, Java access modifiers are on class-level instead of object-level. Therefore, if the recipient is of the same dynamic type as the `this`{language:java} reference sender, then the recipient (after the corresponding typecast) has access to all `private`{language:java} fields of the message (Actor). Though this completely bypasses the encapsulation principle, it is intended behavior of the Java language design.

We see, a library-based Actor variant as Akka cannot enforce strict Actor semantic by itself, if the programming language offers programmers concepts to break it. Enforcing a strict notion of the semantic could only be guaranteed on a language level, as does for example Erlang. However, in general it is sufficient if programmers comply with coding conventions specific to the language to avoid shared state by accident [@Tas13]. Those come with the burden of manually ensuring deep-copying messages if such is required in each individual case. Other Actor frameworks like Orleans always provide deep copied messages automatically, which comes with a performance penalty [@Ber14].

It is worth pointing out that though the Actor model is Scala's standard concurrency abstraction, the language was not designed to enforce a strict Actor semantic. Instead it accepts the perils that come with a library-based implementation. The arguments for a library are [@Hal09; @Tas13]:

* It does not require special support by the compiler, JVM or extra syntax.
* It can be easily extended, adapted, and even replaced. This has already happened, when the standard Scala Actors have been replaced under the hood by Akka Actors.
* It can break the Actor semantic *intentionally*, e.g. to introduce an additional concurrency abstraction, as the next section will demonstrate. 


## Utilizing other Concurrency Constructs


Section [#sec-actor-concurrency-combination] motivated why the Actor model may be combined with other abstractions of concurrency, as long as these do not break Actor semantic. Akka offered support for multiple of such constructs, although with version 2.3 combining Actors with Software Transactional Memory into so-called *Transactors* was dropped. In principle, they've been useful for coordinating computations which span over the scope of multiple Actors and require consensus between all of them [@Sub11]. However, transactional memory usage has never been able to abstract distribution transparently in Akka, for STM requires shared memory which is hard across JVMs [@Swa14], and thus it has been removed eventually.

Besides STM, much more prominently used is the Future concept. It allows to define concurrent computation *inside* an Actor [@AkkaFuture]. However, Futures are not without perils of their own. The following example illustrates such:

```{language:scala}
var a = 0
override def receive = {
  case _ =>
    implicit val ec: ExecutionContext = context.dispatcher
    Future { a += 1 }
    a -= 1
    print(a)
}
```

First of all, Akka requires a so-called `ExecutionContext`{language:scala} in scope to run the Future on [@Hal18]. In the example the Actor's `Dispatcher`{language:scala}, which represents the thread-pool the Actor is being executed on, is used, but another could also be specified instead [@AkkaFuture].

Most importantly however, Futures can be misused to introduce nondeterminism into the scope of an Actor. The example defines some mutable state variable. Upon receiving an arbitrary message, a `Future`{language:scala} is being dispatched with the task of incrementing the state. Concurrently, the Actor will continue processing the message, and attempt to decrement the very same state variable. Due to the nondeterministic nature of the underlying thread-pool, multiple orders of execution are possible, and thus also multiple results for the output statement. This is possible because Java as well as Scala `Future`{language:java}s do not provide any kind of guarantee regarding the safety of data inside their scope that is exceeding the regular notion of this characteristic of the respective language [@Wel05].

The Isolated Turn Principle states that it must be guaranteed that nothing may interfere with any internal state except the Actor itself, at the very least while processing a message. Yet as the example demonstrates, Futures have the potential to violate this constraint, thus breaking the Actor semantic. Once again, Akka can neither check nor prevent this, for the programming languages visibility concept simply allows passing mutable state into the Futures scope, while the safety permits it to be actually mutated. It is up to the user to ensure that only *immutable* state in introduced from outside the scope of the Future into it [@Sub11; @AkkaJMM].

There are also other less expected issues Futures might introduce. All aggregation of remote resources by Crawlers are performed via HTTP. In principle, it is a synchronous communication protocol, such that there is always a response to any request[^fn-synchronous-http]. Most APIs are therefore blocking as they abstract remote procedure call semantic. However, some allow an asynchronous handling by providing a Future result. This has been expected to improve throughput of Crawler requests, for HTTP connections to remote and unknown servers definitively pose as potential bottlenecks, thus reducing the liveness of the tasks. The asynchronous API therefore dispatches great many Futures simultaneously, as arbitrary feed endpoints might be slow and the API allows to start requests before the previous has finished. These Futures all stress the Actor's thread-pool, which in turn lead to temporary starvations due to a lack of available threads on which the Actors can be scheduled. This has been tried with both asynchronous client APIs of the *Akka HTTP* [@AkkaHTTP] module and the *Apache HTTP Components* [@ApacheHttpComponents] library. Although the former would also provide a *flow*-based variant, where the concept of *backpressure* known from *stream*-based programming should limit throughput accordingly, we've found that the underlying *super connection pool flow* used also introduces a limit to the amount of concurrent request to a single host [@AkkaHTTP]. As with many RSS feeds in general, publishers tend to choose distributing feeds via dedicated providers, thus a great amount of feeds are centralized on a small amount of host, rendering Akka's flow variant inapplicable.

[^fn-synchronous-http]: The most basic form would be merely a status code, e.g. the famous 404. 
 
As a result, it was found that, though simple RPC styled retrieval did limit throughput, this can also be an advantage on the other hand. It puts a uniform and more predictable stress on the thread-pool, thus avoids problems like Actor starvation and maintains their overall liveness. There are however still other cases where Futures may come into play. The following section will continue discussing Future usage in the light of communication.


## Communication Abstractions


The Actor model is solely built on the concept of *asynchronous* message passing. Akka provides a respective method called `tell`, with an additional alias `!` for Scala, on `ActorRef`{language:scala} that can be used to dispatch a message object to an Actor. However, many real-life scenarios expect communication to be synchronous, i.e. to only proceed once an answer has been received and not perform any processing in-between. Echo faces this problem whenever a user is requesting information. Fortunately, any synchronous communication can be modeled with an asynchronous information flow [@Agh97].


### Future-based Messaging


Akka provides a primitive to abstract a synchronous information flow. In addition to the asynchronous `tell`/`!` command, it also offers the `ask` method, with alias `?` in Scala, of `ActorRef`{language:scala} [@AkkaActor]. It can be used to model request/reply-style communication [@Hal09]. Such method calls resemble the `!` in that they dispatch the method argument as a message to the Actor behind the reference. However, it offers a result value, respectively the expected result of a synchronous call wrapped in a `Future`{language:scala}. Thus, the caller may either proceed with some further processing, or go directly into blocking until the `Future`{language:scala} is resolved. This resembles the future type message passing of Active Objects.

Resolving any `Future`{language:scala} inside an Actor could either be done in a waiting fashion, which would cause the Actor to block and prevent it from processing any other request until an answer from an Index was received. Such should be avoided if the instance is expected to process messages in reasonable time, like the Searcher.

To prevent unnecessary blocking, monadic methods of Scala's `Future`{language:scala} trait can be used to define subsequent computation once the result becomes available. This can also be utilized when dispatching multiple synchronous messages in Actors. Scala even offers specialized syntax through the so-called *for-comprehension* [@Hal18]:

```{language:scala}
val f1: Future[Int] = actor1 ? msg1
val f2: Future[Int] = actor2 ? msg2
val f3: Future[Int] = actor3 ? msg3

val r = for {
   r1 <- f1
   r2 <- f2
   r3 <- f3
} yield (r1 + r2 + r3)
```

It is important however, that the messages are dispatched prior to the `for`{language:scala}-block's scope. Otherwise it will enforce sequential composition, if the ask-calls are inlined into the block scope [@AkkaFuture]. This is because for-comprehension unfolds to monadic combinator usage of `flatMap` and `map`, which are sequential by nature [@Hal18]. The example above becomes:

```{language:scala}
val r = f1.flatMap(r1 => f2.flatMap(r2 => f3.map(r3 => r1 + r2 + r3)))
```

It is clear to see that if the `ask`-calls would be inlined into the `for`{language:scala}-block, then the second message would only get dispatched once the first `Future`{language:scala} has been resolved. Yet if used correctly, Futures can be harnessed to preserve the single-threaded semantics of Actors and still leveraged parallel computation inside an Actor.

However useful, this approach has two downsides. First it is a load on resources, for any `Future`{language:scala} also stresses the Actor's thread pool - or another if such was specified explicitly. Secondly, there is always the risk of accidentally passing the Actors internal, mutable state into the `Future`{language:scala}s scope, thus introducing race conditions [@Sub11]. The ask pattern per se is therefore not ideal in any case, but using Futures with Actors still have a long tradition [@Tas13]. 


### Delegation-based Messaging


On of the basic Actor primitives allows any Actor to spawn new Actors. This can be used to model synchronous request handling by utilizing newly created Actors merely for temporary usage. The result handling is then relocated to a dedicated child Actor, individually spawned for each request. Creating such child and setting it as the reply destination is done in Akka by:

```{language:scala}
val handler = context.actorOf(ReponseHandler.props())
index.tell(msg, handler)
```

Using `context.actorOf` instead of `system.actorOf` makes the response handler a direct descendent of the current Actor. Providing the obtained `ActorRef`{language:scala} as a second argument to `tell`[^fn-2nd-tell-argument] sets the response handler as the official sender of the message, such that it will be able to receive the response. This dynamically created Actor poses as a temporary component in the architecture:

* Response Handler (H)
  : are tasked with the sole purpose of posing as the original sender of a simple `tell` message dispatch and eventually receiving an answer in a purely asynchronous fashion or detect a timeout. Upon message receival, they pass on the result and deconstruct. 

The actual information flow thus turns from conceptually being defined as `G` &rightleftarrows; `S` &rightleftarrows; `I` to the concrete realization `G` &rarr; `S` &rarr; `I` &rarr; `H` &rarr; `G`. Altering the reply destination this way is a form of the *delegation* concept known from object-orientation [@Yon86]. The overall approach is sometimes referred to as *cameo pattern* as it is used for brief and simple interactions between Actors [@All13].

[^fn-2nd-tell-argument]: Note that its alias `!` does not allow for more than one parameter.

This allows for an asynchronous composition style to handle synchronous communication requirements. It is also a more implementation independent approach if no handy concept like Future to be combined with are offered by the Actor System.

In any case, it is important that the messages in a synchronous information flow scenario are processes swiftly. The model's mailbox construct however buffers all incoming message to an Actor, and has it process each message in a strict FIFO (__F__irst __I__n __F__irst __O__ut) order. Large mailboxes with many messages queued up prevent timely message processing. Influencing the order of message reception is therefore a common property for Actor systems [@Kos16]. Akka provides the concept of a `PriorityMailbox`{language:scala}, which is utilizing the pattern matching syntax of Scala to assign priority levels to messages based on their type, such that those involved in synchronously styled flows may always be processes first, regardless of the actual mailbox size.  


### Modelling Timeouts


Any synchronous information flow should provide some sort of timeout, to prevent starvation. When using futures, this has to be done explicitly using language specific constructs. The already demonstrated for-comprehension syntax of Scala for examples makes it difficult however to introduces timeouts.

Akka therefore supports a special timing mechanism. Actors, e.g. newly spawned delegation-slaves, may register to receive a timeout message after a given time period and define an appropriate message handling behavior. When they receive the expected response message of the synchronous information flow, they simply chancel the timeout message. If however this timeout message is received prior to the response message, then the timeout occurs and a respective reaction is executed [@All13; @Roe15].

It is of interest how such timed messages can be introduced into the Actor abstraction. Timers require some sort of concurrent timer thread that constantly checks the current time and perform registered trigger actions. This is somewhat opposed to the Actor model and message passing in general, where any action happens as a reaction to a received message, decoupled from any notion of time. Therefore, offering solutions for timer mechanism are a concern of many Actor Systems, e.g. also in Erlang [@Arm93] and Orleans [@Ber14].

To avoid interference of any outside threads with Actor states, Akka provides a special `Scheduler`{language:scala} instance that is unique for each system. Actors can register a message sending operation to be triggered after a certain period of time:

```{language:scala}
val messenger: Cancellable = context.system.scheduler
    .scheduleOnce(5.seconds) { 
        self ! TimeoutMessage
    }
```

The provided `Chancellable`{language:scala} reference allows to prevent the trigger from firing by calling `messenger.cancel`{language:scala}. This introduces a notion of time into the Actor semantic that is natural to the model [@AkkaScheduler]. In combination with the cameo pattern it is possible to abstract synchronous information flow semantic including timeout boundaries by using purely asynchronous message passing operations. 


### Type-restricted Messages and Compatibility {#sec-type-restricted-messages-and-compatibility}


One of the basic Actor primitives allows Actors to send messages to any other Actors it knows about. However, in general this does not define any restrictions on the types of messages that are being sent, for messages are untyped in the theoretical model. Receiving Actors only decide upon actually processing a message at runtime if they can handle it.

The Active Object concept aims to provide a higher-level abstraction that fixes this flaw and provides static guarantees. However, this abstraction can become somewhat problematic under certain conditions, as will be discussed in detail in &sect; [#sec-distributed-objects]. Therefore, current developments in Akka try to address the challenge of offering some level of type safety for Actor messaging without using its `TypedActor`{language:java} abstraction for Active Objects. The APIs for this are summarized under the name *Akka Typed* [@AkkaTyped].

One part of Akka's strategy to harden the isolation of Actors is to never expose a reference to an actual Actor instance directly. Instead, all communication happens via the messaging interfaces of `ActorRef`{language:scala} address proxies (`tell`, `ask`). These interfaces take arbitrary types as messages. Akka Typed introduces a generic type parameter to the address, i.e. `ActorRef[U]`{language:scala}, such that the range of acceptable message may be limited to `U`{language:scala}-typed ones. Thus, the signatures of the messaging methods change from e.g. `tell(msg: Any)`{language:scala} to `tell(msg: U)`{language:scala}.

It is worth pointing out that in Scala general messages may be of type `Any`{language:scala}, while in Java received messages are of type `Object`{language:java}. This is somewhat counterintuitive for Akka offers compatible bindings for both languages. However, Scala's type system deviates from Java. The later distinguishes between reference types with `Object`{language:java} as &top; in the type hierarchy and primitive types (`int`{language:java}, `char`{language:java}, etc.) which are not subtypes of `Object`{language:java}. Thus, primitive types cannot be used as messages. In Scala on the other hand, all variables have `Any`{language:scala} as their unified &top;. Its direct descendent `AnyVal`{language:scala} is the supertype of all value types (`Int`{language:scala}, `Char`{language:scala}, etc.), while `AnyRef`{language:scala} corresponds to Java's `Object`{language:java} and is therefore also supertype to all non-value types. If an `AnyVal`{language:scala} is sent from a Scala to a Java Actor, the corresponding primitive type's wrapper class (`Integer`{language:java}, `Character`{language:java}, etc.) will be received.

In any case, type parameters for Actor addressed are not without their drawbacks however. The third basic model primitive states that Actors may change their behavior. When accepted messages are restricted by an `ActorRef[U]`{language:scala} that is hiding such changes transparently, any new behavior is constrained to also process messages of type `U`{language:scala} exclusively. Otherwise the address of the Actor represented by the `ActorRef[U]`{language:scala} would break the semantic and thus become invalid [@AkkaTyped]. In order to be able to ensure this at compile time, such Actors must be defined through a behavior function, which has to be typed too:

```{language:scala}
val behavior: Behavior[U] = 
    Actor.immutable[U] { (_, msg) =>
        // process msg
        Actor.same
    }
```

Here, the typization `msg:U`{language:scala} is guaranteed. The behavior is constructed with the `immutable`{language:scala} factory, therefore may not hold nor pass over mutable state [@AkkaTyped]. It always has to explicitly specify the replacement behavior for the next message, in this case the same, as is declared by `Actor.same`{language:scala}.

Though this concept provides static type safe messaging, it still has its limits. For example, it is not able to ensure at compile time that a behavior is in a certain state. Actor addresses and behaviors are associated at runtime. This is a fundamentally dynamic property of the theoretical Actor model [@AkkaTyped]. 

We've found that such kinds of compile-time message safety restrictions, apart from Active Objects, are a rare capability among Actor Systems. However, the Akka Typed library is in the current Akka version 2.5 still under active research and marked as "may change", thus to be considered experimental.


## Supervision and Monitoring


In &sect; [#sec-actor-systems] we've pointed out that Actor Systems try to provide higher-level constructs than the low-level basic model primitives. One example for such higher-level abstractions are the different messaging styles Akka facilitates. Another important reason for providing more expressive constructs is for such are required to model adequate encapsulation of faults [@Agh90]. Being aware of the possibility of faults and handling these adequately is key especially in a distributed context [@Cou05].

The key to handling faults in Akka is its concept of *supervision*. No actor exists for itself but is always subordinate to its supervisor. This builds a dependency relationship, the so-called *supervision hierarchy*. The actor system provides a default supervisor at the top-level, which has the eventual supervision of all other actors [@AkkaSupervision].  

The hierarchical relationship is fairly simple: a supervisor delegates work to its subordinate children, but in return is bound to *monitor* them. Monitoring is the concept of being notified of and reacting to subordinate's failures. A fault can be of arbitrary nature, i.e. an unhandled exception or invalid state. An actor automatically suspends itself and all its subordinates upon the occurrence of any failure, and its superior is getting notified. The supervisor then has to choose how to handle respond to the failure. 


<!--### Supervision Strategy-->


The signaling of an occurred failure is not communicated via a "normal" actor message, but on a side channel [@AkkaSupervision]. Failure notifications are handled by a so-called *supervision strategy*. Such is, at its core, able to show one of four possible actions:

1. Resuming the suspended child, when the fault can be safely ignored.
2. Restarting the suspended child, in case its internal state is in an invalid state.
3. Stopping the child completely, refraining from continuing any of its execution.
4. Escalating the failure, if the exception is not covered by this Actor. Thus the supervisor fails itself.

A supervisor is notified solely in form of an exception that has been propagated to it from the failed child. However, no state information that puts it into context is being offered. The reason for this is that state should only belong to and be processed by one Actor exclusively. If a failure would result in the propagation of state to the supervisor, then part of the child's implementation logic would leak into its supervisor, for such would require the knowledge to interpret the state in order to evaluate it in a meaningful way. The failure however remains isolated in the child. Therefore, in case it is being resumed, the cleanup actually falls to the child itself. The message on which the fault occurred is not re-introduced into the mailbox, to avoid fault-reoccurrence. All other actions discard the child's state in any case [@Roe15;@AkkaSupervision]. 

~ todo
Hier ein kurzes Code-Bsp?
~


## Information Routing and Delivery Reliability


It can be necessary to send a message not to one Actor specifically, but to have it distributed among a set of equivalent instances. Akka provides the concept of *routers* in order to achieve this:

```{language:scala}
val router: Router = {
    val routees = Seq(actor1, actor2)
    Router(RoundRobinRoutingLogic(), routees)
}
router.route(message, sender())
```

Routing to potential recipients can follow various strategies, depending on the used `RoutingLogic`{language:scala}. The examples uses `RoundRobinRoutingLogic`{language:scala}, which will redirect the message to one of the routees, the next in a cyclic order respectively. Many different routing strategies are available, e.g. `RandomRoutingLogic`{language:scala} for a random recipient, and `BroadcastRoutingLogic`{language:scala} to distribute the message to all routees [@All13].

Conceptually, routing can be done directly inside the sending actor, such that the call `router.route(m,s)` replaces the `tell(m,s)` call. Alternatively an intermediate Actor can be employed. The decision is based on the burden of managing the routees. For actors can fail, the set of routees has to be kept up to date, in order to avoid message routing to terminated actors. Therefore, the routees should be children of the router, such that the router will be informed through its supervision obligation in the case of their demise. A set of such routees is referred to as a *pool* [@Roe15]. Therefore, it can become be useful to use a separate component for routing, if actors are to be part of multiple routers, or parent-child relationship is otherwise logically inadequate:

* Message Routers (R)
  : are intermediate units tasked with distributing received messages among equally qualified potential recipients, based on a certain selection strategy, the *routing logic*. Routers supervise their routees and are thus responsible for forwarding the messages only to those alive. 

The information flow of a message thus becomes for example `W` &rarr; `R` which then distributes it `R` &rarr; `P` for some `P` $\in \{$`P`~1~$\cdots$`P`~n~$\}$  selected based on the routing logic.

Alternatively, routees are part of a so-called *group* when the router is not supervising them [@Roe15]. For this, Akka provides a concept called *Actor selection* as a mechanism to send a message to an address matching a certain pattern. This leads to the question of message delivery reliability. Actor selection does not guarantee that a recipient conform to the pattern exists. Therefore, the message might not be delivered at all, and become a *dead letter* instead. 

Delivery reliability is a general concern of sending messages to Actors, besides the context of routing. In the theoretical model, all messages are guaranteed to be delivered [@Agh85b]. Conceptually this insurance is important as it implies no permanent starvation with any Actor [@Kar09]. In practice however, this cannot be safely assumed to hold. As we assume Actors in a potentially distributed context, message delivery may be subject to a network link. Recalling fallacy 1: *the network is reliable* warns that the network cannot be trusted to guarantee the transport of data in general, thus neither can Actor message delivery be assumed.

Akka therefore weaker insurances regarding message delivery reliability than the theoretical Actor model. Particularly, all messages are merely guaranteed to be delivered *at-most-once*. Thus, they are to be assumed of potentially getting lost. Additionally, when multiple Actor send messages to the same recipient, no order of messages in the mailbox is guaranteed, which is the reason for nondeterminism in the Actor model. Yet Akka also ensures that the messages of one sender are enqueued into the receivers mailbox in the same order as they have been dispatched (FIFO order) [@AkkaMDR].

In contrast, other Actor systems like Orleans choose to provide *at-least-once* delivery by resending messages that have not been acknowledged within a certain timeframe [@Ber14]. Thus, no message is ever lost but can emerge duplicated instead. As a consequence, any application logic with such Actors has to be able to cope with the fact that one and the same message may be received multiple times. 


## Persistence and IO


In order to be able to persist their internal states, Actors must utilize some kind of data persistence mechanism, e.g. a database. Due to their single threaded semantic, only a single interaction with the database is possible at the same time. This is inefficient, for database access is input/output (IO), and such is a performance limiting factor in general [@Sub11]. Theoretically, the single threaded semantic of Actors would make database transactions obsolete, but we've found that common APIs require active transaction in any case, e.g. with JPA.

One approach to overcome the single threaded limitation is by utilizing a non-blocking API for database connections. Such provide a `Future`{language:scala} reference to an eventual result at the cost of stressing the Actors thread pool. Monadic methods once again allow to define further computation on this result once it becomes available, introducing the immanent risk of accidental data races by passing mutable state into the `Future`{language:scala}'s scope.  

If non-blocking APIs are not available, then the efficient strategy to handle multiple requests requires to intentionally weaken the encapsulation principle. Thus, multiple child Actors maintain connections to a shared database representing the persistent state. The original Actor then delegates database interaction to these children.

Isolation must not be broken though, therefore these children do not share the same database connection interface object, or any other immutable data. Simply the restriction on encapsulation the persistent part of state inside one single Actor is loosened up to allow a narrow group of Actors to manage it instead. These must utilize the database systems transaction system, as is required by any concurrent database interaction. [für diesen absatz muss ich irgendwas zutieren. fragt sich nur woher ich das nehme. hab ich mir ja theoretisch wie praktisch selber ausgedacht...]{.red}

The second strategy is perused in Echo. It still involves blocking operations inside Actors. In fact, it increases it by the factor equal to the number of used child Actors. Therefore, a shared dispatcher should be used for all Actors involved in the logical encapsulation of the persistent state. The underlying thread pool can use a fixed number of threads equal to the number of involved Actors. This provides a predictable impact on performance, in contrast to Akka's default dynamically sized thread pools, where threads are added when high demand (i.e. due to many blocking operations) is being detected. Such can consume a lot of system resources [@All13].

We see, efficient handling of IO peruses the same strategies as the introduced abstractions of synchronous Actor communication.


## Clustering

~ todo
Hier kurz die Unterschiede und benötigten Erweiterung zwischen Actors in einem rein lokalen system (single-node) und einem verteilten Setup (distributed nodes) beschreiben. Akka hat hierfür sehr gute Konzepte, welche allerdings Verlangen auf ein paar Dinge zu achten.
~

~LitNote
* Cluster / Remoting of Akka, built in discovery system among nodes  
* Cluster Singleton required by Updater, Cluster Sharding
~

~ green
The capabilities of the Actor model to support distribution was first described by Agha [REF-diss]{.red}, and since it was introduced in many variants of Actors [REF1, REF2, REF3]{.red}. 

...Erlang auch sehr wichtig

...die Erlang deutung auch sehr viel in Akka drinnen

...wichtig das die mechanismen die lokal für actos gehen auch verteil gelten 
~
