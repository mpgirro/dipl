
Actor-based Implementation {#ch-actor-impl}
==========================


~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~


This chapter covers the conceptualities used to implement the concurrent system outlined in the previous chapter using an actor-based programming approach. The focus will be on the linguistic support provided by the used framework to realize the requirements, that is its support for the properties of the actor model and the provided programming abstractions for succinct expression of communication and synchronization between actors, as is suggested by scholars [@Kar09;@Kan12;@Agh99]. Efficiency considerations will be part of Chapter [#ch-evaluation].

It is important to realize that although there is *the* conceptual model, there are numerous system implementations available through various forms of interfaces, either integrated into the programming language or as a library [@Kos16]. These systems are all based on the theoretical model, but may choose to compromise some of the semantic properties in order to increase efficiency [@Kar09]. Such considerations are relevant when evaluating linguistic support.

Echo is based on an actor variant called Akka [@LightbendAkka]. It is available for the JVM through bindings for Java and Scala but was later ported to other ecosystems such as .NET and JavaScript runtimes (through Scala.JS). The .NET variant (called *Akka.NET*) is to our knowledge not able to interweave with the original JVM version at the moment. Because our solution is solely based on the JVM, all following discussions will refer to the capabilities of Akka's original variant.

Akka is theoretically based on Agha's vision of the actor model, and harnesses its potential for distributed problem solving [@Kos16]. An archetype has been Erlang. It is designed as a toolkit collection consisting of several libraries, able to be used in arbitrary combination based on actual need of them. The actor runtime system offered is a lightweight execution environment based on work stealing thread-pools with local task queues which schedule the actor execution [@Hal12].

As of Scala version 2.10, Akka replaces the default actor implementation offered by Scala [@Hal12]. We will therefore refer to the former as *Scala actors* in contrast to *Akka actors*. Among the reasons were the better performance, transparent actor addresses, expressing resilience as well as fault tolerance [@Tas13]. In fact, [@Reh13] found that Akka actors have up to 10 times higher message throughput and a network latency under 1ms, in contrast to 0.2 seconds to Scala actors. 


## Striving for Isolation {#sec-actor-isolation}


While actors encapsulate state conceptually, in practice their *full isolation* must be ensured, such that there is no shared state at all. This is essential to guarantee safety properties, respectively prevent data races and state modifications [@Hal12;@Kan12]. However, Akka offers interfaces for Scala and Java. Both languages support object-orientation in an imperative programming style -- even though Scala is intended to be a functional programming language. Thus, as is with most library-based Actor systems running on execution environments supporting shared-memory multithreading like the JVM, Akka cannot ensure isolation by itself [@Kos16].

Therefore it is especially interesting how the isolated turn principle has to be handled with Akka, because, as was outlined in Section [#sec-actor-messaging-encapsulation], internal state of an Actor must only be allowed to be modified from within the actor itself to preserve the model semantics.


### Issue of Data Hiding


As was pointed out, Akka's actor system is capable of providing a transparent interface for component communication that might exist within the same local scope (same JVM) or remote scope (distinct JVMs). In the first case, different notions of state have to be taken into account. Kniesel [@Kni96] defines *weak state* as the state given through an objects instance variables. *Strong state* is the combination of *local state* (the objects instance variables) and *transient state* (the state of objects referenced by instance variables). 

Actor semantics implies the need for a strict conception of encapsulation where the strong state is exclusive to the actor, i.e.\ no mutable local state must be exposed outside nor mutable transient state imported into the scope of the actor. Violation of this requirement leads to overlapping (shared) mutable state, which is in contrast to the message passing semantics of the model.

*Visibility* is a property of an object's variables and methods given they are part of the object's interface [@Kni96]. It is a concern for encapsulation and subsequently shared mutability [@Sub11; @Goe06]. Java for example offers multiple granularities for visibility of class fields. The following code snippet illustrates the resulting problem:

``` {language:java}
public class Foo extends UntypedActor { 
    public String bar; 
    public static Props props() {
        return Props.create(Foo.class, () -> new Foo());
    }
    @Override
    public void onReceive(Object msg) { /* handle msg */ }
}
```

Field `bar` in class `Foo`{language:java} has been given *external visibility* by declaring it to be `public`{language:java}. It is therefore part of any object of type `Foo`{language:java} and influencing the object's encapsulation [@Kni96]. From visibility follows accessibility, such that `bar` is also accessible from outside the scope of `Foo`{language:java}. Since it is not declared `final`{language:java}, it can also be modified from outside, which violates the requirements of the actor semantics. 

All Java-based actor implementations therefore face the problem that custom-written actor classes can easily break the required model semantics. In order to cope with this problem, object-oriented implementations can offer APIs where interaction with an actor instance is not issued directly through the instances method interfaces, but instead via constructs like [@Hal12]:

``` {language:java}
final ActorRef foo = system.actorOf(Foo.props());
```

An instance of `Foo`{language:java} is not directly created using the `new`{language:java} keyword as is custom in Java, but by using a factory method `actorOf` that hides the actual instantiation. 

The `create` method of `Props`{language:java} takes a Java 8 lambda as an actor object factory. The lambda and the `create` call are commonly wrapped in a `props` method of the actor class. Java lambdas are basically functional closures[^fn-clojure] and only allow us to access effectively `final`{language:java} fields inside the lambda's scope. This restriction prevents us from exposing mutable state to the constructor of an actor class. Of course, this is only true for the `final`{language:java} fields themselves, but not their members (cf.\ Java case study in Section [#sec-concurrency-language-level]).

[^fn-clojure]: Not to be confused with *Clojure*, a dialect of the programming language Lisp for the JVM.

The actor system only exposes a proxy object of type `ActorRef`{language:java} to the user. An `ActorRef`{language:java} instance does not have the external interface of the actor class it represents, and merely offers a variety of methods for sending messages to its actor. Messages sent through these methods will be delivered by the actor system and then consumed by the actor through its `onReceive` method [@Sub11].

The use of `ActorRef`{language:java}s has the benefit that no direct contact with an actor instance object is possible. This lack of contact prevents both visibility and accessibility to any actor object fields or method calls. Additionally, `ActorRef`{language:java} proxies enable *location transparency* [@AkkaActor].


### References and Immutability 


Preventing visibility of actor fields and methods is not sufficient for guaranteeing the required strong state encapsulation on the JVM. The method signature of `onReceive`{language:java} indicates that messages are received with type `Object`{language:java}. Though Java has pass-by-value method parameters, variables with a non-primitive type (all besides `byte`{language:java}, `int`{language:java}, `char`{language:java}, etc.) are actually reference variables storing the address to their objects. A passed-by-value parameter is therefore a copy of the object-address [@Gos15]. By implication, each message sent between actors contains a reference to an object representing the message[^fn-java-pass-by-value]. In general, this reference may point to *one and the same* object, since Akka only serializes messages in case both counterparts are not within the same JVM [@Sub11]. In this case, given object is therefore in the scope of both the sending and the receiving Actor, introducing shared state, which is in contrast to the strong state encapsulation requirement.

[^fn-java-pass-by-value]: This causes the illusion that Java has pass-by-reference parameters. It does not.

However, messages are meant to represent snapshot information of a state at a given point in time. Therefore, shared state is not a problem if it refers to immutable snapshots, such that there is no memory with read-write or write-write access by two distinct actors [@Kos16]. Then the facts cannot be modified by any of the holders. The encapsulation requirement explicitly refers to *mutable* strong state, as immutability avoids what Akka calls the *shared mutable state trap* [@AkkaJMM]. 

One option for Scala is to use `case class`{language:scala} constructs, which are immutable by default except for the transient state introduced through constructor parameters [@AkkaActor]. Java offers less syntactic support for expressing immutability. The property is neither formally defined in the *Java Language Specification* nor the *Java Memory Model* [@Gos15; @Goe06]. However, the basic requirement is to have `final`{language:java} fields only[^fn-java-immutability]. This means that the transient state through internally referenced objects must be marked `final`{language:java} too. The author of this thesis has found that libraries utilizing source-level annotation processing[^fn-immutables-lib] provide useful abstraction for generating value objects. Such use annotated `interface`{language:java} declarations to generate consistent implementations offering builders and factory methods for instantiation [@Goe06]. 

[^fn-java-immutability]: From a technical point of view, a class can have non-`final`{language:java} fields and still instantiate immutable objects. `String`{language:java} is a prominent example. However, deeper insight into the Java Memory Model is required. Goetz gives an outline of the principal approach [@Goe06, p.47].  
[^fn-immutables-lib]: Such as <https://immutables.github.io> for example.

These restrictions still cannot even prevent all obstacles Java and Scala offer to break the model semantics. Nothing can hinder an actor from sending a message to another actor containing the `this`{language:java} reference of its object. `this`{language:java} in an Akka actor is a standard object pointer and therefore not equal to the `ActorRef`{language:java} that corresponds to *self* in the original actor model. Having access to the `this`{language:java} reference of another actor breaks location-transparent access to the respective actor. Additionally, Java access modifiers are on class level instead of object level. Therefore, if the recipient is of the same dynamic type as the `this`{language:java} reference sender, then the recipient (after the corresponding typecast) has access to all `private`{language:java} fields of the corresponding actor object. Though this visibility feature completely bypasses the encapsulation principle, it is intended behavior of the Java language design.

We see, a library-based actor variant as Akka cannot enforce strict actor semantics by itself, if the programming language offers programmers concepts to break it. Enforcing a strict notion of the semantics could only be guaranteed on a language level, as does for example Erlang. However, in general it is sufficient if programmers comply with coding conventions specific to the language to avoid shared state by accident [@Tas13]. Those come with the burden of manually ensuring deep-copying messages if such is required in each individual case. Other actor frameworks like Orleans always provide deep copied messages automatically, which comes with a performance penalty [@Ber14].

It is worth pointing out that though the actor model is Scala's standard concurrency variant, the language was not designed to enforce strict actor semantics. Instead it accepts the perils that come with a library-based implementation. The arguments for a library are [@Hal09; @Tas13]:

* It does not require special support by the compiler, JVM or extra syntax.
* It can be easily extended, adapted, and even replaced. This has already happened, when the standard Scala actors have been replaced under the hood by Akka actors.
* It can break the Actor semantics *intentionally*, e.g.\ to introduce an additional concurrency abstraction, as the next section will demonstrate. 


## Utilizing other Concurrency Constructs


Section [#sec-actor-concurrency-combination] motivated why the actor model may be combined with other abstractions of concurrency, as long as these do not break actor semantics. Akka offered support for multiple of such constructs, although with version 2.3 combining actors with software transactional memory into so-called *transactors* was dropped. In principle, they've been useful for coordinating computations which span over the scope of multiple actors and require consensus between all of them [@Sub11]. However, transactional memory usage has never been able to abstract distribution transparently in Akka, since STM requires shared memory which is difficult across JVMs [@Swa14], and thus it has been removed eventually.

Besides STM, much more prominently used is the future concept. It allows us to define concurrent computation *inside* an actor [@AkkaFuture]. However, futures are not without perils of their own, as the following example illustrates:

```{language:scala}
var a = 0
override def receive = {
  case _ =>
    implicit val ec: ExecutionContext = context.dispatcher
    Future { a += 1 }
    a -= 1
    print(a)
}
```

First of all, Akka requires a so-called `ExecutionContext`{language:scala} in scope to run the future on [@Hal18]. The example uses the actor's `Dispatcher`{language:scala}, which represents the thread-pool the actor is being executed on. A separate thread-pool can also be specified instead [@AkkaFuture].

Most importantly however, futures can be misused to introduce nondeterminism into the scope of an actor. The example defines some mutable state variable. Upon receiving an arbitrary message, a `Future`{language:scala} is being dispatched with the task of incrementing the state. Concurrently, the actor will continue processing the message, and attempt to decrement the very same state variable. Due to the nondeterministic nature of the underlying thread-pool, multiple orders of execution are possible, and therefore also multiple results for the output statement. This is possible because Java as well as Scala `Future`{language:java}s do not provide any kind of guarantee regarding the safety of data inside their scope that is exceeding the regular notion of this characteristic of the respective language [@Wel05].

The isolated turn principle states demands a guarantee that nothing interferes with the internal state of an actor except the actor itself, at the very least while processing a message. Yet futures have the potential to violate this constraint, thus breaking the actor semantics. Once again, Akka can neither check nor prevent this kind of concurrent modification. The programming languages visibility concepts simply allow passing mutable state into the scope of the futures, while the safety permits the state to be actually mutated. It is up to the user to ensure that only *immutable* state in introduced from outside the scope of the future into it [@Sub11; @AkkaJMM].

There are also less expected issues related to futures. All aggregation of remote resources by Crawlers are performed via HTTP. In principle, HTTP is a synchronous communication protocol, such that there is always a response to any request[^fn-synchronous-http]. Most APIs are therefore blocking as they abstract over remote procedure call semantics. However, some APIs allow us to handle requests asynchronously by providing a future result. 

HTTP connections to remote and unknown servers definitively pose as potential bottlenecks, thus reducing the liveness of the tasks

The author expected an asynchronous handling of HTTP requests when fetching feeds to improve the throughput of Crawlers. However, this approach dispatches great many `Future`{language:java}s simultaneously. Feed endpoints different response times and the API allows us to start requests before the previous has finished. All these futures stress the thread-pool of the Crawler actors. Temporary starvations due to a lack of available threads on which actors can be scheduled were the result. The author has been tried this with both asynchronous client APIs of the *Akka HTTP* [@AkkaHTTP] module and the *Apache HTTP Components* [@ApacheHttpComponents] library. Akka HTTP also provides a *flow*-based variant, where the concept of *backpressure* known from *stream*-based programming should limit throughput accordingly. However, the author experienced that the underlying *super connection pool flow* also introduces a limit to the amount of concurrent requests to a single host [@AkkaHTTP]. As with many RSS feeds in general, publishers often choose todistribute feeds via dedicated providers. As a result, a great amount of feeds are centralized on a small amount of host, rendering Akka's flow variant inapplicable.

[^fn-synchronous-http]: The most basic form would be merely a status code, e.g.\ the famous 404. 
 
Although simple RPC styled retrieval did limit throughput, this can also be an advantage on the other hand. The limitation puts a uniform and more predictable stress on the thread-pool, avoids problems like actor starvation and maintains their overall liveness. There are however still other cases where futures may come into play. The following Section will continue discussing future usage in the light of communication.


## Communication Abstractions


The actor model is solely built on the concept of *asynchronous* message passing. Akka provides a respective method called `tell`, with an additional alias `!`\ for Scala, on `ActorRef`{language:scala}. The method can be used to dispatch a message object to an actor. However, many real-life scenarios expect communication to be synchronous, i.e.\ to only proceed once an answer has been received and not perform any processing in-between. Echo faces this problem whenever a user is requesting information. Fortunately, synchronous communication can be modeled with an asynchronous information flow [@Agh97].


### Future-based Messaging


Akka provides a primitive to introduce synchronous information flow. In addition to the asynchronous `tell`/`!`\ command, `ActorRef`{language:scala} also offers the `ask` method, with alias `?`\ in Scala [@AkkaActor]. `ask` can be used to model request/reply-style communication [@Hal09]. An `ask`-call resembles a `tell`-call in that it dispatches the method's argument as a message to the actor behind the reference. However, `ask` offers a result value, respectively the expected result of a synchronous call wrapped in a `Future`{language:scala}. The caller of `ask` may either proceed its computation, or go directly into blocking until the `Future`{language:scala} is resolved. This semantics resembles the future type message passing of active objects.

Resolving a `Future`{language:scala} inside an actor can be done in a waiting fashion, which causes the actor to block and prevent it from processing any other request until an answer from e.g.\ an Index was received. However, we should avoid blocking if we expect an actor to process messages in reasonable time, e.g.\ the Searchers.

~ todo
Oben hier mehr Beispiel mit information flow?
~

To prevent unnecessary blocking, Scala provides monadic methods for the `Future`{language:scala} trait that can be used to define subsequent computation once the result becomes available. This methods can also be utilized when dispatching several synchronous messages inside actors. Scala even offers specialized syntax through the so-called *for-comprehension* [@Hal18]:

```{language:scala}
val f1: Future[Int] = actor1 ? msg1
val f2: Future[Int] = actor2 ? msg2
val f3: Future[Int] = actor3 ? msg3

val r = for {
   r1 <- f1
   r2 <- f2
   r3 <- f3
} yield (r1 + r2 + r3)
```

It is important however, that the messages are dispatched prior to the `for`{language:scala}-block's scope. Otherwise it will enforce sequential composition, if the ask-calls are inlined into the block scope [@AkkaFuture]. This is because for-comprehension unfolds to monadic combinator usage of `flatMap` and `map`, which are sequential by nature [@Hal18]. The example above becomes:

```{language:scala}
val r = f1.flatMap(r1 => f2.flatMap(r2 => f3.map(r3 => r1 + r2 + r3)))
```

It is clear to see that if the `ask`-calls is inlined into the `for`{language:scala}-block, then the second message will only get dispatched once the first `Future`{language:scala} has been resolved. Yet if used correctly, futures can be harnessed to preserve the single-threaded semantics of actors and still leverage parallel computation inside an actor.

However useful, this approach has two downsides. First it is a load on resources, since any `Future`{language:scala} also stresses the actor's thread pool -- or another if one has been been specified explicitly. Secondly, there is always the risk of accidentally passing the Actors internal, mutable state into the `Future`{language:scala}s scope, thus introducing race conditions [@Sub11]. `ask` per se is therefore not ideal in any case, but using Futures with Actors still have a long tradition [@Tas13]. 


### Delegation-based Messaging


One of the basic actor primitives allows an actor to spawn new actors. This can be used to model synchronous request handling by utilizing newly created actors merely for temporary usage. The result handling is then relocated to a dedicated child actor, individually spawned for each request. Creating a child is done in Akka by:

```{language:scala}
val handler = context.actorOf(ReponseHandler.props())
index.tell(msg, handler)
```

Using `context.actorOf` instead of `system.actorOf` makes the response handler a direct descendent of the current actor. Providing the obtained `ActorRef`{language:scala} as a second argument to `tell`[^fn-2nd-tell-argument] sets the response handler as the official sender of the message, such that it will be able to receive the response. This dynamically created Actor poses as a temporary component in the architecture:

* Response Handlers (H)
  : are tasked with the sole purpose of posing as the original sender of a simple `tell` message dispatch and eventually receiving an answer in a purely asynchronous fashion or detect a timeout. Upon message receival, they pass on the result and deconstruct. 

The actual information flow turns from being conceptually defined as `G` &rightleftarrows; `S` &rightleftarrows; `I` into the concrete realization `G` &rarr; `S` &rarr; `I` &rarr; `H` &rarr; `G`. Altering the reply destination is a form of the *delegation* concept known from object-orientation [@Yon86]. The overall approach is sometimes referred to as *cameo pattern* and mostly used for brief and simple interactions between actors [@All13].

[^fn-2nd-tell-argument]: Note that its alias `!`\ does not allow for more than one parameter.

The cameo pattern allows for an asynchronous composition style to handle synchronous communication requirements. The approach is also more implementation independent, if no handy concept like futures are offered by the actor system.

As synchronous communication is constraint by time in general, it is important that the messages for a cameo delegation are processed swiftly. The actor model's mailbox construct however buffers all incoming messages to an actor in a strict FIFO (__F__irst __I__n __F__irst __O__ut) order. Large mailboxes with many messages queued up prevent timely message processing. Influencing the order of message reception is therefore a common property for actor systems [@Kos16]. Akka provides the concept of a `PriorityMailbox`{language:scala}, which is utilizing the pattern matching syntax of Scala to assign priority levels to messages based on their type. IndexStores and CatalogStores are facilitating priority mailboxes to process all messages involved in synchronous flows first, regardless of the current mailbox size.  


### Modelling Timeouts


Synchronous information flow requires a mechanism to implement timeouts in order to prevent starvation. Akka therefore supports a special timing mechanism. Actors, e.g.\ newly spawned delegation-slaves, can register to receive a timeout message after a given time period. The actor then simply needs to define an appropriate message behavior to handle the timeout occurence. When the expected message of the synchronous flow is received before the timeout message, the actor simply cancels the timeout dispatch of the timeout message. However, if the timeout message is received prior to the response message, then the timeout occured and a respective reaction is executed [@All13; @Roe15].

It is interesting how such timed messages can be introduced into the actor system. Timers require some sort of concurrent thread that constantly checks the current time and performs registered trigger actions. Dedicated thread-based concurrency is somewhat opposed to the actor model and message passing in general, where any action happens as a reaction to a received message, decoupled from any notion of time. Therefore, offering solutions for timer mechanism are a concern of many actor systems, e.g.\ also in Erlang [@Arm93] and Orleans [@Ber14].

To avoid interference of any outside threads with actor states, Akka provides a special `Scheduler`{language:scala} instance that is unique for each system. Actors can register a message sending operation that triggers after a certain period of time:

```{language:scala}
val messenger: Cancellable = context.system.scheduler
    .scheduleOnce(5.seconds) { 
        self ! TimeoutMessage
    }
```

The provided `Cancellable`{language:scala} reference allows us to prevent the trigger from firing by calling `messenger.cancel`{language:scala}. This scheduling mechanism introduces a notion of time into the actor semantics that feels natural to the model [@AkkaScheduler]. In combination with the cameo pattern it is possible to implement synchronous information flow semantics including time constraints by using purely asynchronous message passing operations. 


### Type-restricted Messages and Compatibility {#sec-type-restricted-messages-and-compatibility}


One of the basic actor primitives allows actors to send messages to other actors it knows about. However, in general this does not define restrictions on the types of messages that are being sent. Messages are untyped in the theoretical model. An actor decides at runtime when processing a message if it can actually handle the message.

The active object concept aims to provide a higher-level abstraction and provides static guarantees for message types. However, AOs can become problematic under certain conditions, as will be discussed in detail in Section [#sec-distributed-objects]. Therefore, current developments in Akka address the challenge of offering some level of type safety for messaging without using Akka's `TypedActor`{language:java}s for active objects. The APIs are summarized under the name *Akka Typed* [@AkkaTyped].

One part of Akka's strategy to harden the isolation of actors is to never expose a reference to an actual Actor instance directly. Instead, all communication happens via the messaging interfaces of the `ActorRef`{language:scala} proxies (`tell`, `ask`). These interfaces take arbitrary types as messages. Akka Typed introduces a generic type parameter to the address, i.e.\ `ActorRef[U]`{language:scala}, such that the range of acceptable messages is limited to `U`{language:scala}-typed ones. The signatures of the messaging methods then change from e.g.\ `tell(msg: Any)`{language:scala} to `tell(msg: U)`{language:scala}.

It is worth pointing out that in Scala messages are of type `Any`{language:scala} in general, while in Java received messages are of type `Object`{language:java}. This discrepancy of the most general type is somewhat counterintuitive, since Akka offers compatible bindings for both languages. However, the type systems of Java and Scala deviate. Java distinguishes between reference types with `Object`{language:java} as &top; in the type hierarchy and primitive types (`int`{language:java}, `char`{language:java}, etc.) which are not subtypes of `Object`{language:java}. Hence, primitive types cannot be used as messages. In Scala on the other hand, all variables have `Any`{language:scala} as their unified &top;. The direct descendent `AnyVal`{language:scala} is the supertype of all value types (`Int`{language:scala}, `Char`{language:scala}, etc.), while `AnyRef`{language:scala} corresponds to Java's `Object`{language:java} and is therefore also supertype to all non-value types. If an `AnyVal`{language:scala} is sent from a Scala to a Java actor, the corresponding primitive type's wrapper class (`Integer`{language:java}, `Character`{language:java}, etc.) will be received.

In any case, type restricted actor addresses are not without drawbacks. The third basic model primitive states that actors can change their behavior. When accepted messages are restricted by an `ActorRef[U]`{language:scala} that is hiding changes transparently, a new behavior has to be constrained to also process messages of type `U`{language:scala} exclusively. Otherwise the address of the actor represented by the `ActorRef[U]`{language:scala} would break the semantics and become invalid [@AkkaTyped]. To ensure address and behavior compatibility at compile time, these actors must be defined through a behavior function that is restricted by a type parameter too:

```{language:scala}
val behavior: Behavior[U] = 
    Actor.immutable[U] { (_, msg) =>
        // process msg
        Actor.same
    }
```

In this example, the typization `msg:U`{language:scala} is guaranteed. The `Actor.immutable`{language:scala} factory prevents the constructed behavior from holding and passing over mutable state [@AkkaTyped]. Every behavior has to explicitly specify the replacement behavior for the next message. In this case, the replacement behavior stays the same, as is declared by `Actor.same`{language:scala}.

Though Akka Typed provides static type safe messaging, it still has its limits. For example, it is not able to statically ensure that a behavior is in a certain state. The association of an actor's address and behavior is a fundamentally dynamic property of the actor model [@AkkaTyped]. 

We've found that compile-time message safety restrictions, apart from active objects, are a rare capability among actor systems. However, the Akka Typed library is in the current Akka version 2.5 still under active research and marked as "may change", thus to be considered experimental.


## Supervision and Monitoring


In Section [#sec-actor-systems] we've pointed out that Actor Systems try to provide higher-level constructs than the low-level basic model primitives. One example for higher-level abstractions are the different messaging styles Akka facilitates. Another important reason for providing more expressive constructs is the encapsulation of faults [@Agh90]. Being aware of the possibility of faults and handling them adequately is key especially in a distributed context [@Cou05].

The key to handling faults in Akka is its concept of *supervision*. No actor exists for itself, but is always subordinate to its supervisor. This dependency relationship is called *supervision hierarchy*. The actor system provides a default supervisor at the top-level, which has the eventual supervision of all other actors [@AkkaSupervision].  

The hierarchical relationship is fairly simple: a supervisor delegates work to its subordinate children, but in return is bound to *monitor* them. Monitoring is the concept of being notified of and reacting to subordinate's failures. A fault can be of arbitrary nature, i.e.\ an unhandled exception or invalid state. An actor automatically suspends itself and all its subordinates upon the occurrence of a failure, and its superior is getting notified. The supervisor then has to choose how to respond to the failure. 

The signaling of an occurred failure is not communicated via a "normal" actor message, but on a side channel [@AkkaSupervision]. Failure notifications are handled by a so-called *supervision strategy*. One of four possible actions can be shown by a supervision strategy:

1. Resuming the suspended child, when the fault can be safely ignored.
2. Restarting the suspended child, in case its internal state is in an invalid state.
3. Stopping the child completely by refraining from continuing its execution.
4. Escalating the failure, if the exception is not covered by this actor. The supervisor then fails itself.

A supervisor is notified solely in form of an exception that is propagated to it from the failed child. However, no state information that puts the exception into context is being offered. The reason is that state should only belong to and be processed by one actor exclusively. Assuming a failure results in the propagation of state to the supervisor, then part of the child's implementation logic leaks into its supervisor, because the supervisor requires the knowledge to interpret the state in order to evaluate it in a meaningful way. However, Akka isolates the failure in the child. In case it is being resumed, the cleanup therefore falls to the child itself. The message on which the fault occurred is not re-introduced into the mailbox, to avoid fault-reoccurrence. All other actions discard the child's state in any case [@Roe15;@AkkaSupervision]. 

~ todo
Hier ein kurzes Code-Bsp? Aus der Crawler oder Catalog supervision?
~

~ green
Supervision strategies are expecially relevant in Echo's Crawler. ... 
~

## Information Routing and Delivery Reliability


We are frequently required to send a message not to one actor specifically, but to have it distributed among a set of equivalent instances. Akka provides the concept of *routers* to achieve this:

```{language:scala}
val router: Router = {
    val routees = Seq(searcher1, searcher2, searcher3)
    Router(RoundRobinRoutingLogic(), routees)
}
router.route(queryMsg, sender())
```

Routing to potential recipients can follow various strategies, depending on the used `RoutingLogic`{language:scala}. The `RoundRobinRoutingLogic`{language:scala} used in the example redirects the message to the next routee in a cyclic order. Many alternative routing strategies are available, e.g.\ `RandomRoutingLogic`{language:scala} for a random recipient, and `BroadcastRoutingLogic`{language:scala} to distribute the message to all routees [@All13].

Conceptually, we can do the routing directly inside the sending actor by replacing the `tell(m,s)` call with `router.route(m,s)`. Alternatively an intermediate actor can be employed. The decision is based on the burden of managing the routees. 

The set of routees has to be kept up to date, since actors can fail and no message must be sent to a terminated actor. If the routees are children of the routing actor, then the router will be informed through its supervision obligation in the case of a subordinates demise. A supervision-managed set of routees is called a *pool* [@Roe15]. Since supervision is the foundation of a pool, it can be useful to use a separate component for routing, especially if actors are part of several router pools, or parent-child relationship is otherwise logically inadequate:

* Message Routers (R)
  : are intermediate units tasked with distributing received messages among equally qualified potential recipients, based on a certain selection strategy, the *routing logic*. Routers supervise their routees and therefore only forward messages to living children. 

The information flow of a message becomes for example `W` &rarr; `R` which then distributes it `R` &rarr; `P` for some `P` $\in \{$`P`~1~$\cdots$`P`~n~$\}$  selected on the basis of the routing logic.

Alternatively, routees are part of a so-called *group* when the router is not supervising them [@Roe15]. Akka provides a concept called *actor selection* as a mechanism to send a message to an address matching a certain pattern. When no supervision relationship exists, message delivery reliability becomes a special concern. Actor selection does not guarantee that a recipient conforming to the pattern exists. Therefore, a message can become a so-called *dead letter* when it is undeliverable. 

Delivery reliability is also a general concern of sending messages to actors, besides the context of routing. In the theoretical model, all messages are guaranteed to be delivered [@Agh85b]. Conceptually this insurance is important as it implies that no actor can permanently starve [@Kar09]. In practice however, we cannot safely assume perfect delivery reliability to hold. As we consider actors in a potentially distributed context, message delivery can be subject to a network link. Recalling Fallacy 1: *the network is reliable* warns us that the network cannot be trusted to guarantee the transport of data in general. As a result, neither can we assume actor message delivery.

Akka therefore provides a weaker insurances regarding message delivery reliability than the theoretical actor model. Particularly, all messages are merely guaranteed to be delivered *at-most-once*. Additionally, when several actors send messages to the same recipient, no order of messages in the mailbox is guaranteed except that the messages of each particular sender are enqueued into the receivers mailbox in the same order as they have been dispatched by the respective sender (FIFO order) [@AkkaMDR].

In contrast, other actor systems like Orleans choose to provide *at-least-once* delivery by resending messages that have not been acknowledged within a certain timeframe [@Ber14]. No message is ever lost but can emerge duplicated instead. As a consequence, the application logic of actors with at-least-once delivery has to be able to cope with the fact that one and the same message can be received several times. 


## Persistence and IO {#sec-actor-persistence}


We must employ some kind of data persistence mechanism, e.g.\ a database, in order to persist the internal states of actors. Echo's CatalogStores are a prime example. Due to the actors single-threaded semantics, only a single interaction with the database is possible at the same time. This is inefficient, since database access is input/output and therefore a performance limiting factor in general [@Sub11]. Theoretically, the single-threaded semantics of actors makes database transactions obsolete, but the author has found that common APIs demand active transaction in any case, e.g.\ with providers of the __J__ava __P__ersistence __A__PI (JPA).

We can therefore overcome the single-threaded limitation by utilizing a non-blocking API for database connections. Such APIs provide a `Future`{language:scala} reference to an eventual result at the cost of stressing the actor's thread-pool. With the monadic methods of `Future`{language:scala} we can then define further computation on the result once it becomes available. The price is the immanent risk of accidental data races by passing mutable state into the `Future`{language:scala}'s scope.  

If non-blocking APIs are not available, then the author has found that an efficient strategy is to handle numerous requests by intentionally weaking the encapsulation principle. Several children of a CatalogStore actor maintain connections to a shared database that conceptually belongs to the CatalogStore actor exclusively and holds its persistent state. The CatalogStore actor delegates all database interactions to these children using the routing concept with a `RoundRobinRoutingLogic`{language:scala}.

~ todo
Hier könnte ich eine neue Componente beschreiben (BUCHSTABE?!), und auch eine Grafik einbringen?
~

Isolation must not be broken though. Therefore [these children (WIE NENNE ICH DIESE CHILDREN?!)]{.red} neither share the same database connection interface object, nor any other immutable data. Simply the restriction on encapsulating the persistent state inside one single actor is loosened up. A narrow group of actors is managing the persistent state instead. All these actors must utilize the database system's transaction mechanism, as is required by any concurrent database interaction. [für diesen absatz muss ich irgendwas zitieren. fragt sich nur woher ich das nehme. hab ich mir ja theoretisch wie praktisch selber ausgedacht...]{.red}

The second strategy is perused in Echo. Blocking operations inside actors are involved and in fact increased by the factor equal to the number of children used. Therefore, we use a dedicated dispatcher for all actors involved in the logical encapsulation of the persistent state. The underlying thread-pool can use a fixed number of threads. This provides a predictable impact on performance, in contrast to Akka's default dynamically sized thread-pools. This dynamic pools add threads when demand is high, i.e.\ due to many blocking operations, and can therefore consume a lot of system resources [@All13].

We see, efficient handling of IO peruses the same strategies as the introduced delegation-based handling of synchronous actor communication.


## Clustering

~ todo
Hier kurz die Unterschiede und benötigten Erweiterung zwischen Actors in einem rein lokalen system (single-node) und einem verteilten Setup (distributed nodes) beschreiben. Akka hat hierfür sehr gute Konzepte, welche allerdings Verlangen auf ein paar Dinge zu achten.
~

~LitNote
* Cluster / Remoting of Akka, built in discovery system among nodes  
* Cluster Singleton required by Updater, Cluster Sharding
~

~ green
The capabilities of the Actor model to support distribution was first described by Agha [REF-diss]{.red}, and since it was introduced in many variants of Actors [REF1, REF2, REF3]{.red}. 

...Erlang auch sehr wichtig

...die Erlang deutung auch sehr viel in Akka drinnen

...wichtig das die mechanismen die lokal für actos gehen auch verteil gelten 
~
