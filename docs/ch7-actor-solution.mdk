An Actor-based Problem Solution {#ch-Actor-solution}
===============================



In this chapter, we will discuss a practical implementation of the problem scenario outlined in chapter [#ch-problem-scenario] using an Actor-based programming model approach. When talking about the practical application of an Actor model, it is importent to realize that there is not *the* Actor model per se, but a big variaty of implementations available through variouse forms of interfaces, either integrated into the programming language (Erlang), as a library (Scala Actors, JetLang), a framework or platform (Akka, ???) [citation needed]{.mind}. In chapter [#ch-actor-model] we discussed the theoretical concept of Actors proposed by Hewitt [citation needed]{.mind} as well as the possibilities the Actor semantics opens up. The actual Actor implementations available are based upon this semantics and resulting possibilities, but vary in terms of features and [???]{.mind}. Therefore it is important to state the specific Actor variant used when discussing any Actor based system. Our scenario solution is conceived through the Akka Actor model. 

~LitNote
* [@Kar09] Actor Frameworks for the JVM Platform: A Comparative Analysis
~

## Akka {#sec-akka}

Akka [@Akka17] is an Actor implementation available for the *Java Virtual Machine* (JVM) that was later ported to the .NET ecosystem [citation needed]{.mind}. The .NET variant (called *Akka.NET*) is at the moment not able to interweave with the original JVM version [citation required?]{.mind}. Because our solution solely relies on the JVM, therefore all following discussions will refere to the capabilities of Akka's original JVM variant.

Akka is designed as a toolkit collection consisting of several libraries, able to be used in arbitrary combination based on actual need of them. In its core it implements the Actor model with the intent to be close to Armstrongs Actor implementation that is found in the Erlang language [citation needed]{.mind}. Currently it offers bindings for Scala and Java. Since Scala 2.10 it replaces the default Actor implementation offered by Scala [citation needed]{.mind}. Among the reasons were [??? paar sachen aufzählen]{.mind}

As we already mentioned, different Actor implementations have different capabilities. This effects the execution semantics [ist das das wort das ich hier verwenden will?]{.mind} that results from applying the Actor programming model. In section [#sec-distributed-objects] we outlined the combination along with additional concurrency abstractions by giving an example for handling Active Object method dispatch semantics through utilizing Future constructs. At that point we did not discuss the implications the used Actor implementation would have on the correct behaviour. Assuming the given code snipped is executed using the Active Object abstraction Akka provides (called *TypedActor* for it offers type safty for message passing), the desired non-blocking behaviour actually depends on the `Future`{language:java} used for wrapping the `Int`{language:java} result. Akka supports asynchronous dispatch only for the `scala.concurrent.Future`{language:java} trait. If class `Fnord`{language:java} uses its Java friendly `akka.dispatch.Futures`{language:java} interface, the intended behaviour is guaranteed. However, the standard `java.util.concurrent.Future`{language:java} interface would result in undesired blocking behaviour [@AkkaFuture]. 

~Todo
* Akkas Erweiterungen des Actor models kurz anteasern? Oder das erst in den kapiteln tun, in denen diese gebraucht werden (die anderen einfach unterschlagen)
~ 

## Ensuring Isolation

Object-oriented Actor implementations can face problems when it comes to ensuring Actor isolation. As was outlined in section [#sec-actor-messaging-encapsulation], internal state of an Actor must only be allowed to be modified from within the Actor itself to preserve the model semantics.

As was pointed out, this model is capable of providing a transparent interface for component communication that might exist within the same local scope (same process) or remote scope (distinct processes). 

In the first case, different notions of state have to be taken into account. Kniesel defines *weak state* as the state given through an objects instance variables. *Strong state* is the combination of *local state* (the objects instance variables) and *transient state* (the state of objects referenced by instance variables) [@Kni96]. 

Actor semantics implies the need for a strict concept of encapsulation where the strong state is exclusive to the Actor, i.e. no mutable local state must be exposed outside nor mutable transient state imported into the scope of the Actor. Violation of this requirement leads to overlaping shared mutable state, which is in contrast to the message passing semantic of the model [citation needed? sund besser formulieren]{.mind}.

Section [#sec-commonalities-isolation] discussed the potential issues with object-oriented Actors. Visibility was given as a concern for encapsulation. Java for example offers multiple granularities for visibility of class fields. The following code snippet illustrates the resulting problem:

``` {language:java}
public class Foo extends UntypedActor { 

    public String bar; // visible outside actor scope!

    @Override
    public void onReceive(Object message) {  
        // handle message
    } 
}
```

Field `bar` in class `Foo`{language:java} has been given *external visibility* by declaring it to be `public`{language:java}. Thus it is part of any object of type `Foo`{language:java}s external interface and therefore influencing the objects encapsulation [@Kni96]. Because visibility and accessibility are orthogonal, `bar` is also accessible from outside the scope of `Foo`{language:java}, and - for it is not delared `final`{language:java} - may be modified the same way too. This violates Actor semantic requirements. 

Any Java-based Actor implementation therefore faces the potential problem where custom written Actor classes might easily break the required model semantic. In order to cope with this, object-oriented implementations often offer APIs where interaction with an Actor instance is not issued directly through the instances method interfaces, but instead via constructs like:

``` {language:java}
final ActorRef foo = Actors.actorOf(Foo.class).start();
```

An instance of `Foo`{language:java} is not created using the `new`{language:java} keyword as is custom in Java, but by using a factory method that hides the actual instantiation. Only a proxy object of type `ActorRef`{language:java} is exposed to the user. `ActorRef`{language:java} instances do not have the external interface of the Actor class they represent, but only expose a variaty of methods for sending messages to the Actor, which will then be delivered to and consumed by the Actor through its `onReceive` method [@Sub11].

This has the benefit that no direct contact with an Actor instance object is possible, preventing both visbibility and accessibility to any fields, or method calls. Additionally, the communication through an `ActorRef`{language:java} proxy enables *location transparency* [which must have been explain in some chapter previously]{.mind}.

Yet preventing visibility of Actor fields and methods is not sufficient for guaranteeing the required strong state encapsulation on the JVM. The method signature `void onReceive(Object message)`{language:java} indicates that messages are received with type `Object`{language:java}. Though Java has pass-by-value method parameters, any variable for a non primitive type (`byte`{language:java}, `int`{language:java}, `char`{language:java}, etc.) is actually a reference variable, storing the address to an object. Thus, a passed by value parameter contains a copy of the address of the object it represents [^fn-java-pass-by-value]. This means that any message sent between Actors is a reference to an object representing the message. In general, this reference may point to *one and the same* object, for Akka only serializes messages in case both counterparts are not within the same JVM [@Sub11]. In this case, given object is therefore in the scope of both the sending and the receiving Actor, introducing shared state, which is in contrast to the strong state encapsulation requirement.

However, messages are ment to represent snapshot information of a state at a given point in time. Therefore, shared state is not a problem if it referes to immutable snapshotes, such that the facts it represents cannot be modified by any of the holders. Thus the encapsulation requirement explicitly referes to *mutable* strong state. One option for Scala is to use `case class`{language:scala} constructs, which are immutable by default except for the transient state introduced through constructor parameters [irgendwo stand das. zitieren!]{.mind}. Java offers less syntactic support for immutability. It is required to have `final`{language:java} fields only which need to be instantiated through constructor arguments. We've found that libraries utilizing source-level annotation processing[^fn-java-immutables] provide useful abstraction for generating consistent value objects. Such use annotated `interface`{language:java} declarations to generate consistent implementations offering builders and factory methods for instantiation. 

[^fn-java-pass-by-value]: This causes the confusion that Java has pass-by-reference parameters. It does not.
[^fn-java-immutables]: Such as <https://immutables.github.io> for example.

<!-- WO STAND DAS NOCHMAL? ICH FIND SAS NICHT MEHR
Therefore, Akka recommends using Scala `case class`{language:scala} constructs for message sending only, with  this is actually only a prob
-->

## Synchronous and Asynchronous Communication

~LitNote
howto channel types (point-to-point, pub/sub), specialized channels (dead letters, guaranteed delivery --> siehe "Akka in Action"); easy to get pub/sub or MQ routing behaviour via Routers (mostly same Actor as Supervisor); why not use JMS (it would offer both MQ/PubSub behaviour, but is not open and not lightweight)
~

## Data Coupling

~LitNote
Messages are always "state at a specific point in time", but when the receiver gets it, it might already be outdated --> just live with it, no ACID; messages are transported via Actor System (e.g. Akka) and therefore data is coupled via the access to the API (e.g. only Scala/Java and compatible languages  - Groovy - may join the system); avoid any pattern that needs to wait for consensus between Actors -> they should be able to make progress individually (vgl RegisterEpisodeIfNew, hier könnte auch der parser beim catalog nachfragen); message immutability (den ganzen aufwand den ich getrieben habe um die DTOs immutable zu kriegen, denn Akka macht pass by reference wen die nachricht innerhalb der selben JVM zugestellt wird --> und das macht probleme)
~

## Persistence

~LitNote
* Database (Postgres/Lucene) owning based on isolation, Subactor Handlers for DB access: many workers for one "logical" store because the backend data stores (DB, search index) can handle multiple connections --> breaking the "own your state exclusively paradigm"; Polyglot Persistance
* consider using non-blocking IO/DB APIs (if available), the futures will crowed up the thread pool, therefore use dispatchers for bulkheading (= the thread pool becomes an implicit backpressure)
* if blocking IO has to be done, use dispatchers for bulkheading too, and delegate blocking operations to child Actors/workers. This is demonstrated in the Echo implementation
~

## Mailbox, Dispatcher and Backpressure (= Load balancing)

~LitNote
Mailbox, Dispatcher, Command-query separation for stores (CQS, siehe wikipedia, definiert von Bertrand Meyer; create/update/delete = command messages need to be sent to all stores, read = query messages need only to be sent to one store --> **das hier vll eher ein Thema zu Event sourcing?**); Router and Routing Logic (Broker, RoundRobin)
~

## Fault Tolerance

## Supervision and Error Kernel (= Resilience)

~LitNote
* Supervision and Error Kernel
* Circruit Breaker kurz anreißen und darauf hinweisen, dass die in Unterkapitel von MS genauer erklärt werden, da MS deutlich mehr darauf angewiesen sind (benötigen höhere Fault Tolerance einzelner Services, da Ausfall der Componente vergleichsweise teurer)
~

## Scalability

## Elasticity



## Clustering and Mobility

~LitNote
* Cluster / Remoting of Akka, built in discovery system among nodes  
* Cluster Singleton, Cluster Sharding
~

## Deployment

~LitNote
Mostly of no concern, bit of configutation for cluster setup (seed nodes for peer to peer discovery), cluster singleton and cluster sharding for complex deployment setups
~

## Availability

~LitNote
* siehe: [@Agh85b]
~

## Extensibility

~LitNote
* siehe: [@Agh85b]
* hier allgemein zu Actor subtyping und substituion schreiben etc 
~

## Configuration, logging, etc

## Performance measurement of Actors