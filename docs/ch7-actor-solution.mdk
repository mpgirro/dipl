
Actor-based Scenario Implementation {#ch-actor-solution}
===============================



In this chapter, we will discuss a practical implementation of the problem scenario outlined in chapter [#ch-problem-scenario] using an Actor-based programming model approach. When talking about the practical application of the Actor model, it is importent to realize that though there is *the* conceptual model, there are numerous system implementations available through variouse forms of interfaces, either integrated into the programming language (Erlang), as a library (Scala Actors, JetLang), a framework or platform (Akka, ???) [@Kos16]. In chapter [#ch-actor-model] we discussed the theoretical concept of Actors proposed by Hewitt [citation needed]{.mind} as well as the possibilities the Actor semantics opens up. The actual Actor systems available are based upon this semantics and resulting possibilities, but vary in terms of features, sophistication and [???]{.mind}. Therefore it is important to mind the specific Actor system variant used when discussing any Actor based system. Our scenario solution is conceived through the Akka Actor flavour. 

~LitNote
* [@Kar09] Actor Frameworks for the JVM Platform: A Comparative Analysis
~

## Akka {#sec-akka}

Akka [@Akka17] is an Actor implementation available for the *Java Virtual Machine* (JVM) that was later ported to the .NET ecosystem [citation needed]{.mind}. The .NET variant (called *Akka.NET*) is at the moment not able to interweave with the original JVM version [citation required?]{.mind}. Because our solution solely relies on the JVM, therefore all following discussions will refere to the capabilities of Akka's original JVM variant.

Akka is based on Aghas vision of the Actor model, where is harnesses the potential for distributed problem solving [@Kos16].

Akka is designed as a toolkit collection consisting of several libraries, able to be used in arbitrary combination based on actual need of them. In its core it implements the Actor model with the intent to be close to Armstrongs Actor implementation that is found in the Erlang language [citation needed]{.mind}. Currently it offers bindings for Scala and Java. Since Scala 2.10 it replaces the default Actor implementation offered by Scala [citation needed]{.mind}. Among the reasons were [??? paar sachen aufzählen]{.mind}

As we already mentioned, different Actor implementations have different capabilities. This effects the execution semantics [ist das das wort das ich hier verwenden will?]{.mind} that results from applying the Actor programming model. In section [#sec-distributed-objects] we outlined the combination along with additional concurrency abstractions by giving an example for handling Active Object method dispatch semantics through utilizing Future constructs. At that point we did not discuss the implications the used Actor implementation would have on the correct behaviour. Assuming the given class is changed to use the Active Object abstraction Akka provides (called *TypedActor* for it offers type safty for message passing) by changed it to `class Fnord extends TypedActor`{language:java}, the desired non-blocking behaviour actually depends on the `Future`{language:java} used for wrapping the `Int`{language:java} result. Akka supports asynchronous dispatch only for the `scala.concurrent.Future`{language:java} trait. If class `Fnord`{language:java} uses its Java friendly `akka.dispatch.Futures`{language:java} interface, the intended behaviour is guaranteed. However, the standard `java.util.concurrent.Future`{language:java} interface would result in undesired blocking behaviour [@AkkaFuture]. When refering to futures from now on, we will always assume the prior ones (depending on the Akka API binding used).

~LitNote
* Beschreiben, dass viele Actors existieren können, und diese ab und zu auf einem Thread innerhalb eines viel kleineren Thread Pools laufen. Threads sind teurer als Actors, daher viel weniger
* Die originalen Scala Actors hatten 2 verschiedene Arten von Actors, jene die auf theads ausgeführt werden (receive) und jene die nur als Callback durch einen closure ausgeführt werden (react). Letztere sind viel leichtgewichtiger, können aber nicht mehr auf den state zugreifen [@Kos16; @Hal09] --> vll sollte ich dies in einem allgemeineren Kapitel weiter oben beschreiben? Dort wo ich dann auch was zu Erlang schreibe? Vll in den Commonalities, bzgl was die schwergewichtung von Prozessen/Threads bzw dann nur callback-clojures betrifft.
* Akkas Erweiterungen des Actor models kurz anteasern? Oder das erst in den kapiteln tun, in denen diese gebraucht werden (die anderen einfach unterschlagen)
* [@AkkaJMM] beschreibt das Akka garantiertieren muss, wie sich das abarbeiten von nachrichten verhält, weil die actors ja auf threads laufen, aber nicht zwingend 2 nachrichten hintereinander auf dem selben thread ausgeführt werden
    * "The actor send rule: the send of the message to an actor happens before the receive of that message by the same actor."
    * "The actor subsequent processing rule: processing of one message happens before processing of the next message by the same actor."
~ 

## Ensuring Isolation {#sec-ensuring-actor-isolation}

How the Isolated Turn Principle is ensured depends on the language paradigm used. Purely functional languages usually can only modify Actor state by changing the behaviour. The imperative paradigm however presents some challanges in order to guarantee isolation [@Kos16].

Akka offers interfaces for Scala and Java. Both languages support object-orientation in an imperative programming style - even though Scala is intended to be a functional programming language. Thus, as is with most library-based Actor systems running on execution environments supporting shared-memory multithreading like the JVM, Akka cannot ensure isolation by itself [@Kos16].

Therefore it is especially interresting how the Isolated Turn Principle has to be handled with Akka, because, as was outlined in section [#sec-actor-messaging-encapsulation], internal state of an Actor must only be allowed to be modified from within the Actor itself to preserve the model semantics.

As was pointed out, Akkas Actor system is capable of providing a transparent interface for component communication that might exist within the same local scope (same process) or remote scope (distinct processes). In the first case, different notions of state have to be taken into account. Kniesel defines *weak state* as the state given through an objects instance variables. *Strong state* is the combination of *local state* (the objects instance variables) and *transient state* (the state of objects referenced by instance variables) [@Kni96]. 

Actor semantics implies the need for a strict concept of encapsulation where the strong state is exclusive to the Actor, i.e. no mutable local state must be exposed outside nor mutable transient state imported into the scope of the Actor. Violation of this requirement leads to overlaping (shared) mutable state, which is in contrast to the message passing semantic of the model [citation needed? sund besser formulieren]{.mind}.

Section [#sec-commonalities-isolation] discussed the potential issues with object-oriented Actors. Visibility was given as a concern for encapsulation. Java for example offers multiple granularities for visibility of class fields. The following code snippet illustrates the resulting problem:

``` {language:java}
public class Foo extends UntypedActor { 

    public String bar; // visible outside actor scope!

    public static Props props() {
        return Props.create(Foo.class, () -> new Foo());
    }

    @Override
    public void onReceive(Object message) {  
        // handle message
    } 
}
```

Field `bar` in class `Foo`{language:java} has been given *external visibility* by declaring it to be `public`{language:java}. Thus it is part of any object of type `Foo`{language:java}s external interface and therefore influencing the objects encapsulation [@Kni96]. Because visibility and accessibility are orthogonal, `bar` is also accessible from outside the scope of `Foo`{language:java}, and - for it is not delared `final`{language:java} - may be modified the same way too. This violates Actor semantic requirements. 

Any Java-based Actor implementation therefore faces the potential problem where custom written Actor classes might easily break the required model semantic. In order to cope with this, object-oriented implementations often offer APIs where interaction with an Actor instance is not issued directly through the instances method interfaces, but instead via constructs like:

``` {language:java}
final ActorRef foo = system.actorOf(Foo.props());
```

An instance of `Foo`{language:java} is not created using the `new`{language:java} keyword as is custom in Java, but by using a factory method `actorOf` that hides the actual instantiation. Using `props()` is common to wrap the instantiating Java 8 lambda. Only a proxy object of type `ActorRef`{language:java} is exposed to the user. `ActorRef`{language:java} instances do not have the external interface of the Actor class they represent, but only expose a variaty of methods for sending messages to the Actor, which will then be delivered to and consumed by the Actor through its `onReceive` method [@Sub11].

This has the benefit that no direct contact with an Actor instance object is possible, preventing both visbibility and accessibility to any fields, or method calls. Additionally, the communication through an `ActorRef`{language:java} proxy enables *location transparency* [which must have been explain in some chapter previously]{.mind}.

Yet preventing visibility of Actor fields and methods is not sufficient for guaranteeing the required strong state encapsulation on the JVM. The method signature `void onReceive(Object message)`{language:java} indicates that messages are received with type `Object`{language:java}. Though Java has pass-by-value method parameters, any variable for a non primitive type (`byte`{language:java}, `int`{language:java}, `char`{language:java}, etc.) is actually a reference variable, storing the address to an object. Thus, a passed by value parameter is a copy of the address of the object it represents [@Gos15]. This means that any message sent between Actors contains a reference to an object representing the message[^fn-java-pass-by-value]. In general, this reference may point to *one and the same* object, for Akka only serializes messages in case both counterparts are not within the same JVM [@Sub11]. In this case, given object is therefore in the scope of both the sending and the receiving Actor, introducing shared state, which is in contrast to the strong state encapsulation requirement.

However, messages are ment to represent snapshot information of a state at a given point in time. Therefore, shared state is not a problem if it referes to immutable snapshotes, such that there is no memory with read-write or write-write access by two distrinct Actors [@Kos16], i.e. the facts cannot be modified by any of the holders. Thus the encapsulation requirement explicitly referes to *mutable* strong state. Immutability avoids what Akka calls the *shared mutable state trap* [@AkkaJMM]. 

One option for Scala is to use `case class`{language:scala} constructs, which are immutable by default except for the transient state introduced through constructor parameters [@AkkaActor]. Java offers less syntactic support for immutability. It is required to have `final`{language:java} fields only which need to be instantiated through constructor arguments. We've found that libraries utilizing source-level annotation processing[^fn-java-immutables] provide useful abstraction for generating consistent value objects. Such use annotated `interface`{language:java} declarations to generate consistent implementations offering builders and factory methods for instantiation. 

[^fn-java-pass-by-value]: This causes the illusion that Java has pass-by-reference parameters. It does not.
[^fn-java-immutables]: Such as <https://immutables.github.io> for example.

These restrictions still cannot even prevent all obstacles Java offers to break model semantic. Nothing can prevent an Actor from sending its own `this`{language:java} reference to another Actor. This alone is to be refrained at all times per se. But Java access modifiers are on class-level instead of object-level. Therefore, if the recipient is of the same dynamic type as the `this`{language:java} reference sender, then the recipient - after  appropriatethe corresponding typecast - has access to all `private`{language:java} fields of the message. This breaks the design by contract principle [habe ich das schon vorher irgendwo eingeführt?]{.mind}, but is intended by Javas encapsulation principle. 

## Mixing Concurrency Concepts

~Todo
* Hier sollte ich ein beispiel bringen das wenn man einen Future innerhalb eines Actors verwendet, man aufpassen muss keinen mutable state innerhalb des Futures zu verwenden. Denn es gibt keinen synchronized access, und dies kann wieder zu probleme führen.
* Außerdem kann ich dann wieder darauf zurückkommen, dass das *Visibility* Concept hier das eigentliche problem ist (weil Actor state im Future visible sein kann)
* [@AkkaJMM] "Akka and the Java Memory Model"
    * "The completion of a Future “happens before” the invocation of any callbacks registered to it are executed."
    * "We recommend not to close over non-final fields (final in Java and val in Scala), and if you do choose to close over non-final fields, they must be marked volatile in order for the current value of the field to be visible to the callback."
~ 

## Synchronous and Asynchronous Communication

~LitNote
howto channel types (point-to-point, pub/sub), specialized channels (dead letters, guaranteed delivery --> siehe "Akka in Action"); easy to get pub/sub or MQ routing behaviour via Routers (mostly same Actor as Supervisor); why not use JMS (it would offer both MQ/PubSub behaviour, but is not open and not lightweight)
~

~Todo
* den einfachen tell befehlt erklären, also `!` ; zitieren [@AkkaActor]
~

The Actor model is soley built on the concept of message passing, therefore by definition asynchronous communication. As such, no synchronous communication is intended. However, many real life scenarios expect communication to be synchronouse, i.e. to only proceed processing once an answer has been received and to not due any processing inbetween.

*Echo:Actor* faces this problem whenever a user is requesting information. This cannot be postponed to an asynchronous information flow, with unknown traveling time of messages [schlechte bezeichnung]{.mind}. 

[grafik hier einfügen]{.mind}

Fortunatelly, any synchronous communication can be modeled via asynchronous communication.

### Ask Pattern and Future Result (Extra Pattern)

Akka provides a mechanism to deal with synchronous information flow. In addition to the asynchronous *tell* command semantic, it also offers the *ask* pattern abstracted in the `?` method of `ActorRef`{language:scala} [@AkkaActor]. It can be used to model request/reply-style communication [@Hal09]. Such method calls resemble the `!` in that they dispatch the method argument as a message to the Actor behind the reference. However it offers a result value, respectivly the expected result of a synchronous call wrapped in a `Future`{language:scala}. Thus, the caller may either proceed with some further processing, or go directly into blocking until the `Future`{language:scala} is resolved.

Resolving any `Future`{language:scala} inside an Actor could either be done in a waiting fashion, which would cause the Actor to block and prevent it from processing any other request until an answer from an Index was received. Such should be avoided if the instance is expected to process messages in reasonable time, like the Searcher.

Section [#sec-distributed-objects] demonstrated how the `Future`{language:scala} abstraction can be utilized to prevent unnecessary sequences of blocking operations, by utilizing its monadic methods. This can also be combined when dispatching multiple synchronous messages in Actors. Scala even offers specialized syntax through the so-called *for-comprehension*:

```{language:scala}
val f1: Future[Int] = actor1 ? msg1
val f2: Future[Int] = actor2 ? msg2
val f3: Future[Int] = actor3 ? msg3

val r = for {
   r1 <- f1
   r2 <- f2
   r3 <- f3
} yield (r1 + r2 + r3)
```

It is important however, that the messages are dispatched prior to the `for {...} yield`{language:scala} block scope. Otherwise it will enforce sequential composition, if the ask-calls are inlined into the block scope [@AkkaFuture]. This is because for comprehension is unfolded by the compiler to monadic `flatMap` and `map` usage, which is sequential by nature. The example above becomes:

```{language:scala}
val r = f1.flatMap(r1 => f2.flatMap(r2 => f3.map(r3 => r1 + r2 + r3)))
```

It is clear to see that if the ask calls would be inlined into the `for`{language:scala} block, then the second message would only get dispatched once the first future has been resolved. Yet if used correctly, Futures can be harnessed to preserve the single-threaded semantics of Actors and still leveraged parallel computation inside an Actor.

However useful, this approach has two downsides. First it is a load on resources, for any `Future`{language:scala} also stresses the Actor's thread pool. Secondly, futures always pose the risk of accidentially passing the Actors internal, mutable state into the scope of the future, thus introducing race conditions [@Sub11]. The ask pattern per se is therefore not ideal in any case. 

### Transparent Asynchronous Composition (Cameo Pattern)

Basic Actor model semantics states that any Actor can spawn new Actors. This operation should be cheap, for it is expected to be used intensively [citation needed]{.mind}. One instance where spawing new Actors just for temporary usage would be such synchronous request handling. 

The result handling is delegated to a dedicated newly spawned child Actor. Its sole purpose is to pose as the original sender of a simple tell-style message and eventually receive an answer in a purely asynchronous fashion to the query. Upon message receival, it then passes the result on and deconstructs.

```{language:scala}
val handler = context.actorOf(ReponseHandler.props())
index.tell(msg, handler)
```

Using `context.actorOf` instead of `system.actorOf` makes the response handler a direct decendent of the current Actor. Providing the obtained `ActorRef`{language:scala} as a second argument to `tell` (the Java API method) sets the response handler as the official sender of the message. Thus it will be able to receive a response.

This allows for an asynchronous composition style to handle synchronous communication requirements. It is also a more implementation independent approach, if no handy concept like future combination is available [brauche ich hier eine citation? hab ich mir selber ausgedacht]{.mind}

In any case, it is important that the messages in a synchronous information flow scenario are processes swiftly. The models mailbox construct however buffers all incomming message to an Actor, and has it process each message in a strict FIFO (**F**irst **I**n **F**irst **O**ut) order [citation needed]{.mind}. Large mailboxes (that is with many messages queued up) deplay eager message processing. 

In order to prevent such fallities [ist das das wort das ich hier will?]{.mind}, Akka offers the concept of a *priority mailbox*. Basically it alters mailbox behaviour into a priority queue. 

```{language:scala}
class CustomMailbox(settings: ActorSystem.Settings, config: Config) 
        extends UnboundedPriorityMailbox(
    // lower value means higher priority
    PriorityGenerator {
        case GetA(_)     => 0
        case ProcessB(_) => 1
        case _           => 2
    })
```

### Timeouts

~Todo
Hier beschreiben wie timeouts modelliert werden können
~

Any synchronous information flow should provide some sort of timeout, to prevent starvation [citation  needed]{.mind}. When using futures, this has to be done explicitly using language specific constructs. The already demonstrated for-comprehension syntax of Scala for examples makes it difficult however to introduces timeouts.

Another advantage of the cameo pattern [andere bezeichnung?]{.mind} is that the child Actors can easily simulate timeouts. When spawned, they register to receive a timeout message after a given time period and and define an appropriate message handling behaviour. When they receive the expected response message of the synchronous information flow, they simply chancel the timeout message. If however this timeout message is received prior to the response message, then the timeout occures and [dann muss halt der timeout gehandled werden]{.mind}  

It is of interrest how such timed messages can be introduced into the Actor abstraction. Timers require some sort of concurrent timer thread that constantly checks the current time and perform registered trigger actions [habe ich allgemeine literatur wie timer gehen? hat akka da ein paper verlinkt?]{.mind}. This is somewhat opposed to the Actor model and message passing in general, where any action happens as a reaction to a received message, decoupled from any notion of time [was zitieren? dieses buch von Boner?]{.mind}.

To avoid interference of any outside threads with Actor states, Akka provides a special `Scheduler` instance that is unique for each system. Internally it is based on the so-called *Timing Wheels* by Varghese and Lauck [@Var87].

Actors can register a message sending operation to be triggered after a certain period of time:

```{language:scala}
val timeoutMessager: Cancellable = context.system.scheduler.
    scheduleOnce(5.seconds) { 
        self ! IndexRetrievalTimeout
    }
```

The provided `Chancellable`{language:scala} reference allows to prevent the trigger from fireing through `timeoutMessager.cancel`{language:scala}. This introduces a notion of timing into the Actor semantic, that is natural to the model [@AkkaScheduler]. In combination with the cameo pattern, it is possible to abstract synchronous information flow semantic including timeout boundries by using purely asynchronous message passing operations. 

## Data Coupling

~LitNote
Messages are always "state at a specific point in time", but when the receiver gets it, it might already be outdated --> just live with it, no ACID; messages are transported via Actor System (e.g. Akka) and therefore data is coupled via the access to the API (e.g. only Scala/Java and compatible languages  - Groovy - may join the system); avoid any pattern that needs to wait for consensus between Actors -> they should be able to make progress individually (vgl RegisterEpisodeIfNew, hier könnte auch der parser beim catalog nachfragen); message immutability (den ganzen aufwand den ich getrieben habe um die DTOs immutable zu kriegen, denn Akka macht pass by reference wen die nachricht innerhalb der selben JVM zugestellt wird --> und das macht probleme)
~

## Persistence and IO

~LitNote
* Database (Postgres/Lucene) owning based on isolation, Subactor Handlers for DB access: many workers for one "logical" store because the backend data stores (DB, search index) can handle multiple connections --> breaking the "own your state exclusively paradigm"; Polyglot Persistance
* consider using non-blocking IO/DB APIs (if available), the futures will crowed up the thread pool, therefore use dispatchers for bulkheading (= the thread pool becomes an implicit backpressure)
* if blocking IO has to be done, use dispatchers for bulkheading too, and delegate blocking operations to child Actors/workers. This is demonstrated in the Echo implementation
~

Actors encapsulate their state. 

## Mailbox, Dispatcher and Backpressure (= Load balancing)

~LitNote
* Mailbox, Dispatcher, Command-query separation for stores (CQS, siehe wikipedia, definiert von Bertrand Meyer; create/update/delete = command messages need to be sent to all stores, read = query messages need only to be sent to one store --> **das hier vll eher ein Thema zu Event sourcing?**); Router and Routing Logic (Broker, RoundRobin)
* [@Kos16] beschreibt "Actor System Properties", u.a. zu Message Reception die Eigenschaften: Interface, Flexibility, Number of Interfaces, Order
    * Order: zB kann durch einen PriorityMailbox die Order beeinflusst werden.
~

## Fault Tolerance

## Supervision and Error Kernel (= Resilience)

~LitNote
* Supervision and Error Kernel
* Circruit Breaker kurz anreißen und darauf hinweisen, dass die in Unterkapitel von MS genauer erklärt werden, da MS deutlich mehr darauf angewiesen sind (benötigen höhere Fault Tolerance einzelner Services, da Ausfall der Componente vergleichsweise teurer)
~

## Scalability

## Elasticity



## Clustering and Mobility

~LitNote
* Cluster / Remoting of Akka, built in discovery system among nodes  
* Cluster Singleton, Cluster Sharding
~

## Deployment

~LitNote
Mostly of no concern, bit of configutation for cluster setup (seed nodes for peer to peer discovery), cluster singleton and cluster sharding for complex deployment setups
~

## Availability

~LitNote
* siehe: [@Agh85b]
~

## Extensibility

~LitNote
* siehe: [@Agh85b]
* hier allgemein zu Actor subtyping und substituion schreiben etc 
~

## Configuration, logging, etc

## Performance measurement of Actors


## Summary {#actor-solution-summary}

In this chapter, we discussed the impact of implementational defails on the theoretical concept of Actors: 

* True isolation can in general not be ensured as strictly as hard process boundries do. Special care has to be taken by the user in order to have decent enought Actors state encapsulated inside the same JVM to prevent breaking the model semantic. 
* Futures can be used to abstract synchronous information flow, without blocking the unterlying thread. More idiomatic and Future-independet is the utilization custom spawned child Actors to act as response handlers with single purpose lifetime and to 
* Futures can be harnessed to preserve the single-threaded semantics of Actors and still leveraged parallel computation inside an Actor., all without blocking the unterlying thread.
