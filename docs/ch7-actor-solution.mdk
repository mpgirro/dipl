
Actor-based Scenario Implementation {#ch-actor-solution}
===============================



In this chapter, we will discuss a practical implementation of the problem scenario outlined in chapter [#ch-problem-scenario] using an Actor-based programming model approach. When talking about the practical application of the Actor model, it is importent to realize that though there is *the* conceptual model, there are numerous system implementations available through variouse forms of interfaces, either integrated into the programming language (Erlang), as a library (Scala Actors, JetLang), a framework or platform (Akka, ???) [@Kos16]. In chapter [#ch-actor-model] we discussed the theoretical concept of Actors proposed by Hewitt [citation needed]{.mind} as well as the possibilities the Actor semantics opens up. The actual Actor systems available are based upon this semantics and resulting possibilities, but vary in terms of features, sophistication and [???]{.mind}. Therefore it is important to mind the specific Actor system variant used when discussing any Actor based system. Our scenario solution is conceived through the Akka Actor flavour. 

~LitNote
* [@Kar09] Actor Frameworks for the JVM Platform: A Comparative Analysis
~

## Akka {#sec-akka}

Akka [@Akka17] is an Actor implementation available for the *Java Virtual Machine* (JVM) that was later ported to the .NET ecosystem [citation needed]{.mind}. The .NET variant (called *Akka.NET*) is at the moment not able to interweave with the original JVM version [citation required?]{.mind}. Because our solution solely relies on the JVM, therefore all following discussions will refere to the capabilities of Akka's original JVM variant.

Akka is based on Aghas vision of the Actor model, where is harnesses the potential for distributed problem solving [@Kos16].

Akka is designed as a toolkit collection consisting of several libraries, able to be used in arbitrary combination based on actual need of them. In its core it implements the Actor model with the intent to be close to Armstrongs Actor implementation that is found in the Erlang language [citation needed]{.mind}. Currently it offers bindings for Scala and Java. Since Scala 2.10 it replaces the default Actor implementation offered by Scala [citation needed]{.mind}. Among the reasons were [??? paar sachen aufzählen]{.mind}

As we already mentioned, different Actor implementations have different capabilities. This effects the execution semantics [ist das das wort das ich hier verwenden will?]{.mind} that results from applying the Actor programming model. In section [#sec-distributed-objects] we outlined the combination along with additional concurrency abstractions by giving an example for handling Active Object method dispatch semantics through utilizing Future constructs. At that point we did not discuss the implications the used Actor implementation would have on the correct behaviour. Assuming the given class is changed to use the Active Object abstraction Akka provides (called *TypedActor* for it offers type safty for message passing) by changed it to `class Fnord extends TypedActor`{language:java}, the desired non-blocking behaviour actually depends on the `Future`{language:java} used for wrapping the `Int`{language:java} result. Akka supports asynchronous dispatch only for the `scala.concurrent.Future`{language:java} trait. If class `Fnord`{language:java} uses its Java friendly `akka.dispatch.Futures`{language:java} interface, the intended behaviour is guaranteed. However, the standard `java.util.concurrent.Future`{language:java} interface would result in undesired blocking behaviour [@AkkaFuture]. When refering to futures from now on, we will always assume the prior ones (depending on the Akka API binding used).

~LitNote
* Beschreiben, dass viele Actors existieren können, und diese ab und zu auf einem Thread innerhalb eines viel kleineren Thread Pools laufen. Threads sind teurer als Actors, daher viel weniger
* Die originalen Scala Actors hatten 2 verschiedene Arten von Actors, jene die auf theads ausgeführt werden (receive) und jene die nur als Callback durch einen closure ausgeführt werden (react). Letztere sind viel leichtgewichtiger, können aber nicht mehr auf den state zugreifen [@Kos16; @Hal09] --> vll sollte ich dies in einem allgemeineren Kapitel weiter oben beschreiben? Dort wo ich dann auch was zu Erlang schreibe? Vll in den Commonalities, bzgl was die schwergewichtung von Prozessen/Threads bzw dann nur callback-clojures betrifft.
* Akkas Erweiterungen des Actor models kurz anteasern? Oder das erst in den kapiteln tun, in denen diese gebraucht werden (die anderen einfach unterschlagen)
* [@AkkaJMM] beschreibt das Akka garantiertieren muss, wie sich das abarbeiten von nachrichten verhält, weil die actors ja auf threads laufen, aber nicht zwingend 2 nachrichten hintereinander auf dem selben thread ausgeführt werden
    * "The actor send rule: the send of the message to an actor happens before the receive of that message by the same actor."
    * "The actor subsequent processing rule: processing of one message happens before processing of the next message by the same actor."
~ 

## Ensuring Isolation {#sec-ensuring-actor-isolation}

How the Isolated Turn Principle is ensured depends on the language paradigm used. Purely functional languages usually can only modify Actor state by changing the behaviour. The imperative paradigm however presents some challanges in order to guarantee isolation [@Kos16].

Akka offers interfaces for Scala and Java. Both languages support object-orientation in an imperative programming style - even though Scala is intended to be a functional programming language. Thus, as is with most library-based Actor systems running on execution environments supporting shared-memory multithreading like the JVM, Akka cannot ensure isolation by itself [@Kos16].

Therefore it is especially interresting how the Isolated Turn Principle has to be handled with Akka, because, as was outlined in section [#sec-actor-messaging-encapsulation], internal state of an Actor must only be allowed to be modified from within the Actor itself to preserve the model semantics.

### Data hiding

As was pointed out, Akkas Actor system is capable of providing a transparent interface for component communication that might exist within the same local scope (same process) or remote scope (distinct processes). In the first case, different notions of state have to be taken into account. Kniesel defines *weak state* as the state given through an objects instance variables. *Strong state* is the combination of *local state* (the objects instance variables) and *transient state* (the state of objects referenced by instance variables) [@Kni96]. 

Actor semantics implies the need for a strict concept of encapsulation where the strong state is exclusive to the Actor, i.e. no mutable local state must be exposed outside nor mutable transient state imported into the scope of the Actor. Violation of this requirement leads to overlaping (shared) mutable state, which is in contrast to the message passing semantic of the model [citation needed? sund besser formulieren]{.mind}.

Section [#sec-commonalities-isolation] discussed the potential issues with object-oriented Actors. Visibility was given as a concern for encapsulation. Java for example offers multiple granularities for visibility of class fields. The following code snippet illustrates the resulting problem:

``` {language:java}
public class Foo extends UntypedActor { 

    public String bar; // visible outside actor scope!

    public static Props props() {
        return Props.create(Foo.class, () -> new Foo());
    }

    @Override
    public void onReceive(Object message) {  
        // handle message
    } 
}
```

Field `bar` in class `Foo`{language:java} has been given *external visibility* by declaring it to be `public`{language:java}. Thus it is part of any object of type `Foo`{language:java}s external interface and therefore influencing the objects encapsulation [@Kni96]. Because visibility and accessibility are orthogonal, `bar` is also accessible from outside the scope of `Foo`{language:java}, and - for it is not delared `final`{language:java} - may be modified the same way too. This violates Actor semantic requirements. 

Any Java-based Actor implementation therefore faces the potential problem where custom written Actor classes might easily break the required model semantic. In order to cope with this, object-oriented implementations often offer APIs where interaction with an Actor instance is not issued directly through the instances method interfaces, but instead via constructs like:

``` {language:java}
final ActorRef foo = system.actorOf(Foo.props());
```

An instance of `Foo`{language:java} is not created using the `new`{language:java} keyword as is custom in Java, but by using a factory method `actorOf` that hides the actual instantiation. Using `props()` is common to wrap the creating Java 8 lambda. For Java lambdas are basically functional closures[^fn-clojure], they only allow to access effectively `final`{language:java} fields inside the lambda scope, preventing the exposure of mutable state to any constructor.

[^fn-clojure]: Not to be confused with *Clojure*, a dialect of the programming language Lisp for the JVM.

Only a proxy object of type `ActorRef`{language:java} is exposed to the user. `ActorRef`{language:java} instances do not have the external interface of the Actor class they represent, but only expose a variaty of methods for sending messages to the Actor, which will then be delivered to and consumed by the Actor through its `onReceive` method [@Sub11].

This has the benefit that no direct contact with an Actor instance object is possible, preventing both visbibility and accessibility to any fields, or method calls. Additionally, the communication through an `ActorRef`{language:java} proxy enables *location transparency* [@AkkaActor] [which must have been explain in some chapter previously]{.mind}.

### References and Immutability 

Preventing visibility of Actor fields and methods is not sufficient for guaranteeing the required strong state encapsulation on the JVM. The method signature `void onReceive(Object message)`{language:java} indicates that messages are received with type `Object`{language:java}. Though Java has pass-by-value method parameters, any variable for a non primitive type (`byte`{language:java}, `int`{language:java}, `char`{language:java}, etc.) is actually a reference variable, storing the address to an object. Thus, a passed by value parameter is a copy of the address of the object it represents [@Gos15]. This means that any message sent between Actors contains a reference to an object representing the message[^fn-java-pass-by-value]. In general, this reference may point to *one and the same* object, for Akka only serializes messages in case both counterparts are not within the same JVM [@Sub11]. In this case, given object is therefore in the scope of both the sending and the receiving Actor, introducing shared state, which is in contrast to the strong state encapsulation requirement.

However, messages are ment to represent snapshot information of a state at a given point in time. Therefore, shared state is not a problem if it referes to immutable snapshotes, such that there is no memory with read-write or write-write access by two distrinct Actors [@Kos16], i.e. the facts cannot be modified by any of the holders. Thus the encapsulation requirement explicitly referes to *mutable* strong state. Immutability avoids what Akka calls the *shared mutable state trap* [@AkkaJMM]. 

One option for Scala is to use `case class`{language:scala} constructs, which are immutable by default except for the transient state introduced through constructor parameters [@AkkaActor]. Java offers less syntactic support for immutability. It is required to have `final`{language:java} fields only, which need to be instantiated through constructor arguments. We've found that libraries utilizing source-level annotation processing[^fn-java-immutables] provide useful abstraction for generating consistent value objects. Such use annotated `interface`{language:java} declarations to generate consistent implementations offering builders and factory methods for instantiation. 

[^fn-java-pass-by-value]: This causes the illusion that Java has pass-by-reference parameters. It does not.
[^fn-java-immutables]: Such as <https://immutables.github.io> for example.

These restrictions still cannot even prevent all obstacles Java offers to break model semantic. Nothing can prevent an Actor from sending its own `this`{language:java} reference to another Actor. This alone is to be refrained at all times per se. But Java access modifiers are on class-level instead of object-level. Therefore, if the recipient is of the same dynamic type as the `this`{language:java} reference sender, then the recipient - after the corresponding typecast - has access to all `private`{language:java} fields of the message. This breaks the design by contract principle [habe ich das schon vorher irgendwo eingeführt?]{.mind}, but is intended by Javas encapsulation principle. 

## Integration of other Concurrency Constructs

Section [#sec-actor-concurrency-combination] motivated why the Actor model may be combined with other abstractions of concurrency, as long as these do not break Actor semantic.

Akka offered multiple such constructs, although version 2.3 dropped support for combining Actors with Software Transactional Memory into so-called *Transactors*. In principle, they've been useful for coordinating computations which span over the scope of multiple Actors and require consensus between all of them [@Sub11]. However, transactional memory usage has never been able to abstract distribution transparently in Akka, and thus was dropped eventually.

Besides STM, much more prominetly used is the Future construct. Its somewhat special meaning has already been teasered at the beginning of this chapter. It allows to define concurrent computation *inside* an Actor [@AkkaFuture]. However, Futures are not without perils of their own. The following example illulstrates such:

```{language:scala}
var a = 0
def receive = {
  case _ =>
    implicit val ec = context.dispatcher
    Future { a += 1 }
    a -= 1
    println(a)
}
```

First of all, Akka requires a so-called `ExecutionContext`{language:scala} in scope to run a Future. In the example the Actor's `Dispatcher`{language:scala}, which represents the thread-pool the Actor is running on, is being used, but another could be specified instead [@AkkaFuture].

Most importantly however, Futures can be misused to introduce non-determinism into the scope of an Actor. The example defines some mutable state variable. Upon receiving an arbitrary message, a `Future`{language:scala} is being dispatched with the task of incrementing the state. Concurrently, the Actor will continue processing the message, and attempt to decrement the very same state variable. Due to the non-deterministic nature of the underlying thread-pool, multiple orders of execution are possible, and thus also multiple results for the output statement.

If we recall the Isolated Turn Principle, it must be guaranteed that nothing may interfere with any internal state except the Actor itself, at the very least while processing a message. Yet as the example demonstrates, Futures have the potential to violate this constraint, thus breaking the Actor semantic. Once again, Akka can neither check nor prevent this, for the programming languages visibility concept simply allows passing mutable state into the Futures scope. It is up to the user to ensure that only *immutable* state in introduced from outside the scope of the Future into it [@Sub11; @AkkaJMM].

There are other cases where Futures may come into play. The following section will continue discussing Future usage in the light of communication.

## Synchronous and Asynchronous Communication

~LitNote
howto channel types (point-to-point, pub/sub), specialized channels (dead letters, guaranteed delivery --> siehe "Akka in Action"); easy to get pub/sub or MQ routing behaviour via Routers (mostly same Actor as Supervisor); why not use JMS (it would offer both MQ/PubSub behaviour, but is not open and not lightweight)
~

~Todo
* den einfachen tell befehlt erklären, also `!` ; zitieren [@AkkaActor]
~

The Actor model is soley built on the concept of message passing, therefore by definition asynchronous communication. As such, no synchronous communication is intended. However, many real life scenarios expect communication to be synchronouse, i.e. to only proceed processing once an answer has been received and to not due any processing inbetween.

*Echo:Actor* faces this problem whenever a user is requesting information. This cannot be postponed to an asynchronous information flow, with unknown traveling time of messages [schlechte bezeichnung]{.mind}. 

[grafik hier einfügen]{.mind}

Fortunatelly, any synchronous communication can be modeled via asynchronous communication.

### Future-typed Messaging Style

Akka provides a mechanism to deal with synchronous information flow. In addition to the asynchronous *tell* command semantic, it also offers the *ask* pattern abstracted in the `?` method of `ActorRef`{language:scala} [@AkkaActor]. It can be used to model request/reply-style communication [@Hal09]. Such method calls resemble the `!` in that they dispatch the method argument as a message to the Actor behind the reference. However it offers a result value, respectivly the expected result of a synchronous call wrapped in a `Future`{language:scala}. Thus, the caller may either proceed with some further processing, or go directly into blocking until the `Future`{language:scala} is resolved. This resembles the future type message passing of Active Objects.

Resolving any `Future`{language:scala} inside an Actor could either be done in a waiting fashion, which would cause the Actor to block and prevent it from processing any other request until an answer from an Index was received. Such should be avoided if the instance is expected to process messages in reasonable time, like the Searcher.

Section [#sec-distributed-objects] demonstrated how the `Future`{language:scala} abstraction can be utilized to prevent unnecessary sequences of blocking operations, by utilizing its monadic methods. This can also be combined when dispatching multiple synchronous messages in Actors. Scala even offers specialized syntax through the so-called *for-comprehension*:

```{language:scala}
val f1: Future[Int] = actor1 ? msg1
val f2: Future[Int] = actor2 ? msg2
val f3: Future[Int] = actor3 ? msg3

val r = for {
   r1 <- f1
   r2 <- f2
   r3 <- f3
} yield (r1 + r2 + r3)
```

It is important however, that the messages are dispatched prior to the `for {...} yield`{language:scala} block scope. Otherwise it will enforce sequential composition, if the ask-calls are inlined into the block scope [@AkkaFuture]. This is because for comprehension is unfolded by the compiler to monadic `flatMap` and `map` usage, which is sequential by nature. The example above becomes:

```{language:scala}
val r = f1.flatMap(r1 => f2.flatMap(r2 => f3.map(r3 => r1 + r2 + r3)))
```

It is clear to see that if the ask calls would be inlined into the `for`{language:scala} block, then the second message would only get dispatched once the first future has been resolved. Yet if used correctly, Futures can be harnessed to preserve the single-threaded semantics of Actors and still leveraged parallel computation inside an Actor.

However useful, this approach has two downsides. First it is a load on resources, for any `Future`{language:scala} also stresses the Actor's thread pool - or another if such was specified explicitely. Secondly, futures always pose the risk of accidentially passing the Actors internal, mutable state into the scope of the future, thus introducing race conditions [@Sub11]. The ask pattern per se is therefore not ideal in any case. 

### Delegation-based Messaging Style

On of the basic Actor primities allows any Actor to spawn new Actors. This operation should be cheap, for it is expected to be used intensively [citation needed]{.mind}. One instance where spawing new Actors just for temporary usage would be such synchronous request handling. 

The result handling is delegated to a dedicated newly spawned child Actor. Its sole purpose is to pose as the original sender of a simple tell-style message dispatch and eventually receive an answer in a purely asynchronous fashion. Upon message receival, it passes on the result and deconstructs. Creating such a child and setting it as the reply destination is done in Akka via:

```{language:scala}
val handler = context.actorOf(ReponseHandler.props())
index.tell(msg, handler)
```

Using `context.actorOf` instead of `system.actorOf` makes the response handler a direct decendent of the current Actor. Providing the obtained `ActorRef`{language:scala} as a second argument to `tell` (the Java API method) sets the response handler as the official sender of the message. Thus it will be able to receive the response. Altering the reply destination this way is a form of the *delegation* concept known from Object-orientation [@Yon86].

This allows for an asynchronous composition style to handle synchronous communication requirements. It is also a more implementation independent approach, if no handy concept like Future to be combined with are offered by the Actor System [brauche ich hier eine citation? hab ich mir selber ausgedacht]{.mind}

In any case, it is important that the messages in a synchronous information flow scenario are processes swiftly. The models mailbox construct however buffers all incomming message to an Actor, and has it process each message in a strict FIFO (**F**irst **I**n **F**irst **O**ut) order [citation needed]{.mind}. Large mailboxes (that is with many messages queued up) deplay eager message processing. 

In order to prevent such fallities [ist das das wort das ich hier will?]{.mind}, Akka offers the concept of a *priority mailbox*. Basically it alters mailbox behaviour into a priority queue. 

```{language:scala}
class CustomMailbox(settings: ActorSystem.Settings, config: Config) 
        extends UnboundedPriorityMailbox(
    // lower value means higher priority
    PriorityGenerator {
        case GetA(_)     => 0
        case ProcessB(_) => 1
        case _           => 2
    })
```

### Timeouts

Any synchronous information flow should provide some sort of timeout, to prevent starvation [citation  needed]{.mind}. When using futures, this has to be done explicitly using language specific constructs. The already demonstrated for-comprehension syntax of Scala for examples makes it difficult however to introduces timeouts.

Another advantage of the cameo pattern [andere bezeichnung?]{.mind} is that the child Actors can easily simulate timeouts. When spawned, they register to receive a timeout message after a given time period and and define an appropriate message handling behaviour. When they receive the expected response message of the synchronous information flow, they simply chancel the timeout message. If however this timeout message is received prior to the response message, then the timeout occures and [dann muss halt der timeout gehandled werden]{.mind}  

It is of interrest how such timed messages can be introduced into the Actor abstraction. Timers require some sort of concurrent timer thread that constantly checks the current time and perform registered trigger actions [habe ich allgemeine literatur wie timer gehen? hat akka da ein paper verlinkt?]{.mind}. This is somewhat opposed to the Actor model and message passing in general, where any action happens as a reaction to a received message, decoupled from any notion of time [was zitieren? dieses buch von Boner?]{.mind}.

To avoid interference of any outside threads with Actor states, Akka provides a special `Scheduler` instance that is unique for each system. Internally it is based on the so-called *Timing Wheels* by Varghese and Lauck [@Var87].

Actors can register a message sending operation to be triggered after a certain period of time:

```{language:scala}
val timeoutMessager: Cancellable = context.system.scheduler.
    scheduleOnce(5.seconds) { 
        self ! IndexRetrievalTimeout
    }
```

The provided `Chancellable`{language:scala} reference allows to prevent the trigger from fireing through `timeoutMessager.cancel`{language:scala}. This introduces a notion of timing into the Actor semantic, that is natural to the model [@AkkaScheduler]. In combination with the cameo pattern, it is possible to abstract synchronous information flow semantic including timeout boundries by using purely asynchronous message passing operations. 

### Type-safe Messaging

One of the basic Actor primitives allows Actors to send messages to any other Actors it knows about. However, in general this does not define any restrictions on the types of messages that are being sent. They may be of arbitrary nnature and a receiving Actor only decides if it can handle a messages once it processes it, i.e. at runtime.

As we've already discussed, the Active Object concept aims to provide a higher-level abstraction that fixes this flaw, but at the cost of introducing new pitfalls through the leaky abstraction it shares with Distributed Objects. Therefore, current developments in Akka try to address the challenge of offering some level of type safety for Actor messaging without using its *TypedActor* abstrction for Active Objects. The APIs for this are sumarized under the name *Akka Typed* [@AkkaTyped].

One part of Akkas strategy to harden the isolation of Actors is to never expose a reference to an actual Actor instance directly. Instead, all communication happens via the messaging interfaces of `ActorRef`{language:scala} proxies (tell, ask). These interfaces take arbitrary types as messages. The basic idea of *Akka Typed* now is simple. By introducing a generic type parameter to the address abstraction, i.e. `ActorRef[U]`{language:scala}, the range of acceptable message types may be limited. Thus, the signatures of the messaging methods change from e.g. `tell(msg: Any)`{language:scala} to `tell(msg: U)`{language:scala}.

It is worth mentioning that in Scala general messages may be of type `Any`{language:scala}, while in Java received messages are of type `Object`{language:java}. This is somewhat counterintuitive for Akka offers compatible bindings for both languages. However Scala's type system deviates from Java. The later destinguishes between reference types with top type `Object`{language:java} and primitive types (`int`{language:java}, `char`{language:java}, etc.) which are not subtypes of `Object`{language:java}. Thus primitive types cannot be used as messages. In Scala on the other hand, all variables have `Any`{language:scala} as their common supertype. Its direct decendent `AnyVal`{language:scala} is the supertype of all value types (`Int`{language:scala}, `Char`{language:scala}, etc.), while `AnyRef`{language:scala} corresponds to Java's `Object`{language:java} and is therefore also supertype to all non-value types. If an `AnyVal`{language:scala} is sent from a Scala to a Java Actor, the corresponding primitive types wrapper class (`Integer`{language:java}, `Character`{language:java}, etc.) will be received [sollte ich für den absatz was zitieren? zumindest die Java Spec?]{.mind}.

In any case, type parameters for Actor addressed are not without their drawbacks however. The third basic model primitive states that Actors may change their behaviour. When accepted messages are restricted by an `ActorRef[U]`{language:scala} that is hiding such changes transparently, any new behaviour is constrained to also process messages of type `U`{language:scala}. Otherwise the address of the Actor represented by the `ActorRef[U]`{language:scala} would break the semantic and thus become invalid [@AkkaTyped]. In order to be able to ensure this at compile time, the behavior function of Actors must be typed too:

```{language:scala}
val behavior: Behavior[U] = Actor.immutable[U] { 
    (_, msg) =>
        // process msg
        Actor.same
    }
```

Here, the typization `msg:U`{language:scala} is guaranteed. The example also demonstrates how Actor behaviors can be expressed in a purely functional way. The behavior is constructed with the `immutable`{language:scala} factory, therefore may not hold nor pass over mutable state [@AkkaTyped]. It always has to explicitly specify the replacement behavior for the next message, in this case the same, as is declared by `Actor.same`{language:scala}.

Though this concept provides static type safe messaging, it still has its limits. For example, it is not able to ensure at compile time that a behavior is in a certain state. Actor addresses and behaviors are associated at runtime. This is a fundamentally dynamic property of the theoretical Actor model [@AkkaTyped]. In contrast, higher-order types [sind die wirklich higher-order?]{.mind} - so-called *Process Types* - are able to express such constraints [citation, irgendwas vom Franz!]{.mind}, and as such they are not compatible with the Actor model [stimmt das? hab ich da irgendwo literatur wo das so gesagt wird?]{.mind}.

However useful this message saftey restrictions pose to be, the *Akka Typed* library is in the current Akka version 2.5 still under active research and marked as "may change". Thus, despite we consider it a very promising concept that most other Actor Systems lack, we do not consider it to be stable, and *Echo:Actor* refrains from using this feature at this point. 

## Information Routing and Delivery Reliability

~LitNote
Point-to-point communication and Pub/Sub
~

## Data Coupling

~LitNote
Messages are always "state at a specific point in time", but when the receiver gets it, it might already be outdated --> just live with it, no ACID; messages are transported via Actor System (e.g. Akka) and therefore data is coupled via the access to the API (e.g. only Scala/Java and compatible languages  - Groovy - may join the system); avoid any pattern that needs to wait for consensus between Actors -> they should be able to make progress individually (vgl RegisterEpisodeIfNew, hier könnte auch der parser beim catalog nachfragen); message immutability (den ganzen aufwand den ich getrieben habe um die DTOs immutable zu kriegen, denn Akka macht pass by reference wen die nachricht innerhalb der selben JVM zugestellt wird --> und das macht probleme)
~

## Persistence and IO

~LitNote
* Database (Postgres/Lucene) owning based on isolation, Subactor Handlers for DB access: many workers for one "logical" store because the backend data stores (DB, search index) can handle multiple connections --> breaking the "own your state exclusively paradigm"; Polyglot Persistance
* consider using non-blocking IO/DB APIs (if available), the futures will crowed up the thread pool, therefore use dispatchers for bulkheading (= the thread pool becomes an implicit backpressure)
* if blocking IO has to be done, use dispatchers for bulkheading too, and delegate blocking operations to child Actors/workers. This is demonstrated in the Echo implementation
~

Actors encapsulate their state. 

## Mailbox, Dispatcher and Backpressure (= Load balancing)

~LitNote
* Mailbox, Dispatcher, Command-query separation for stores (CQS, siehe wikipedia, definiert von Bertrand Meyer; create/update/delete = command messages need to be sent to all stores, read = query messages need only to be sent to one store --> **das hier vll eher ein Thema zu Event sourcing?**); Router and Routing Logic (Broker, RoundRobin)
* [@Kos16] beschreibt "Actor System Properties", u.a. zu Message Reception die Eigenschaften: Interface, Flexibility, Number of Interfaces, Order
    * Order: zB kann durch einen PriorityMailbox die Order beeinflusst werden.
~

## Fault Tolerance, Supervision and Resilience

In section [#sec-actor-systems] we've pointed out that Actor Systems try to provide higher-level constructs than the low-level basic model primitives. One example for such higher-level abstractions are the different messaging styles Akka facilitates. 

Another important reason for providing more expressive constructs is for such are required to model adequat encapsulation of faults [@Agh90].


## Supervision and Error Kernel (= Resilience)

~LitNote
* Supervision and Error Kernel
* Circruit Breaker kurz anreißen und darauf hinweisen, dass die in Unterkapitel von MS genauer erklärt werden, da MS deutlich mehr darauf angewiesen sind (benötigen höhere Fault Tolerance einzelner Services, da Ausfall der Componente vergleichsweise teurer)
~

## Scalability

## Elasticity



## Clustering and Mobility

~LitNote
* Cluster / Remoting of Akka, built in discovery system among nodes  
* Cluster Singleton, Cluster Sharding
~

## Deployment

~LitNote
Mostly of no concern, bit of configutation for cluster setup (seed nodes for peer to peer discovery), cluster singleton and cluster sharding for complex deployment setups
~

## Availability

~LitNote
* siehe: [@Agh85b]
~

## Extensibility

~LitNote
* siehe: [@Agh85b]
* hier allgemein zu Actor subtyping und substituion schreiben etc 
~

## Configuration, logging, etc

## Performance measurement of Actors


## Summary {#actor-solution-summary}

In this chapter, we discussed the impact of implementational defails on the theoretical concept of Actors: 

* True isolation can in general not be ensured as strictly as hard process boundries do. Special care has to be taken by the user in order to have decent enought Actors state encapsulated inside the same JVM to prevent breaking the model semantic. 
* Futures can be used to abstract synchronous information flow, without blocking the unterlying thread. More idiomatic and Future-independet is the utilization custom spawned child Actors to act as response handlers with single purpose lifetime and to 
* Futures can be harnessed to preserve the single-threaded semantics of Actors and still leveraged parallel computation inside an Actor., all without blocking the unterlying thread.
