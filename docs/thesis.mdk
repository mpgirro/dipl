[INCLUDE=style/marticle]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
<!--Title        : Concurrent Programming Languages and Microservice Architectures-->
Title        : Concurrent Programming for Microservice Architectures
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2017
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : alpha
Cite All     : False

Package      : mathptmx

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Tex Header   : 
  \epigraphsize{\small\itshape}
  \setlength\epigraphwidth{8cm}
  \setlength\epigraphrule{0pt}
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { 
  background-color: LightGray;
  padding: 1ex;
}
.Todo { 
  background-color: Aqua; 
  padding: 1ex;
}

@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : webpaginated.css
  Script*       : webpaginated.js
}
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }



~ Begin HtmlOnly
[TITLE]
~ Begin SidePanel
[TOC]
~ End SidePanel
~ End HtmlOnly
<!-- We open an HTML class here, which we'll need to close at the end -->
~ Begin MainPanel

<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->


# Danksagung { -; toc:clear; }

TODO

<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

# Kurzfassung { -; toc:clear; }

~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~

# Introduction

~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

## Methodology used

## Road Map

# Microservice Architectures

~ Epigraph { caption: "Higgs Boson (2012 -- present)" }
Don't give up on your dreams, keep on sleeping.
~

~ LitNote
* <https://martinfowler.com/articles/microservices.html>

* keywords for microservices challenges from [@AAE16]:
  * Communication/Integration (API, REST, sockets, TCP, gateway, circuit breakers, load balancer, proxy)
  * Service discovery (API gateways, etc)
  * Performance ( QoS, performance, SLA, speed, simulation)
  * Fault-tolerance
  * Security
  * Tracing and Logging
  * Application Performance Monitoring
  * Deployment operations
* eventueller Vergleich mit Komponentenbasiertem Softwareentwurf? "Bei einem komponentenorientierten Softwareentwurf sind Softwaresysteme in möglichst unabhängig wartbare und wiederverwendbare Softwarekomponenten zu zerlegen. Diese Ziele lassen sich verfolgen, indem bei der Definition von Softwarekomponenten dem Entwurfsprinzip der maximalen Kohäsion bei gleichzeitig minimalen Abhängigkeiten gefolgt wird [Szyperski et al. 2002, S. 40; Parnas 1972]" -> http://www.enzyklopaedie-der-wirtschaftsinformatik.de/lexikon/is-management/Systementwicklung/Hauptaktivitaten-der-Systementwicklung/Softwareentwurf/Komponentenorientierter-Softwareentwurf/index.html
~

## Componentization via Services (geklaut von M.Fowler)

~ TODO
Kapitel vll eher "Evolution of the Components" nennen? Das Service deren Weiterentwicklung sind?
~

~ TODO
Case Study: Concurrency in ABCL/1 [@Yon86a]

* "Each object in our computation model has its own (auto- nomous) processing power and it my have its local persistent memory,thecontentsofwhichmpcesentitsstate. Anobjectis always in one of three modes: dormant, active, or waiting. An object is initially dormant. It becomes active when it receives a message that satisfies one of the specified patterm and con- straints."

* "When an active object completes the sequence of actions that are performed in response to an accepted message, if no subsequent messages have arrived, it becomes dormant again. An object in the active mode sometimes needs to stop its current activity in order to wait for a message with specified patm'ns to arrive. In such a case, an active object changes into the waiting mode. An object in the waiting mode becomes active again when it receives a n~quired message."

=> vgl mit REST API und wenn ein Service einen anderen Service synchron anspricht
~

## Smart endpoints and dumb pipes (geklaut von M.Fowler)

## Failure is inevitable

## API gateways, circuit breakers and discovery

Case study: Hysterix library

Case study: Akka provides a circuit breaker implementation [@MW16]

## Concurrency considerations

~ LitNote
* Microservices sind ja per Design Concurrent, da eigene Programme (Service = Component). Und wenn man MS skaliert (mehrere Instanten gleichzeitig startet) dann ist diese Component auch parallel. Also falls man auf mehreren Maschinen deployed
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@FL17]
~

## Development, Debugging and Maintenance

~ Epigraph { caption: "Filipe Fortes" }
Debugging is like being the detective in a crime movie where you're also the murderer.
~


## Summary

# Concurrency, Distributed Programming and Scalability

## Summary

# Concurrency Concepts


## Actor-based Concurrency

## Dataflow Programming

## Communicating sequential processes

<https://en.wikipedia.org/wiki/Communicating_sequential_processes>

## Summary

# Object Oriented Design Principles vs. Microservice Architectures

* bzgl OOP: siehe <https://sanaulla.info/2008/06/26/cohesion-and-coupling-two-oo-design-principles/>

## Summary

# Concurrency Concepts, Distributed Programming and Microservice Architectures


## Implicit Concurrency through (Framekworks|Inversion of Control)

~ TODO
Über Concurrency die einem zB Spring Framework gibt
~

## MSA and the Unix Philosophy

> Text streams are to Unix tools as messages are to objects in an object-oriented setting

quelle: "Rule of Composition: Design programs to be connected with other programs." <http://catb.org/esr/writings/taoup/html/ch01s06.html#id2877684> (müsste bereits eine ordentliche Literaturreferenz existieren): [Raymond, Eric S. (2003), "1.6.3 Rule of Composition: Design programs to be connected with other programs", The Art of Unix Programming, Addison-Wesley, pp. 15–16, ISBN 978-0-13-142901-7.]

## Summary

# TODO

## Concurrent by Design Objects

> OrcO: Concurrency First Approach on Objects

## Foundational Issues of concurrent systems

* [@AH85] zu foundational issues in the design of programming languages for concurrent systems
  * shared resources: may chance their internal state while shared 
  * dynamic reconfiguration: dealw ith creation of new objects in the evolution of the system; must be a mechanism to for communicating the existance of such new objects or processes to already existing ones
    * in MSA ist genau das die kernaufgabe der gateway
  * inherent parallelism: programming model should exhibit inherent parallelism in the sense that the amount of available concurrency should be determined as mich as possible from the structure of the programs written
    * also MSA nutzt parallelism inherent, da jeder MS ein prozess, und daher die nebenläufigkeit des OS herangezogen wird (ggf mit multicore-paralllelität); bei aufteilung auf mehr maschinen, sowieso parallel

## Comparisons (welche Elemente lassen sich vergleichen)

### MSA

* [@MW16]
  * components of an application are autonnomous services that execute independently
  * communicate via message passing
  * message passing introduces the possiilities of communnication failures and timeouts among components
    * vgl.: im Actor Model ist die Zustellung von Nachrichten garantiert
  * inspired by SOA
  * key difference between SOA and MS lies in granularity (in SOA, all services are parts of a monolith)
  * components can e deployed separately
  * new versions can be gradually introduced into a system  
    * vgl. Subtyping Idee
  * Components can be more specialized, since they can be written in different techologies
  * services may become overloaded (too many concurrent client requests) or resources kept busy
  * this may easily trigger disastrous cascading failures
  * failure in an MSA is inevitale and should embraced with precaution rather than ignored
  * Failing service may have other services depending on it (what if it becomes unresponsive?)
    * -> circuit breaker pattern; fail fast
    * mit Circuit Breaker State Diagram p.2 !
  * Circuit Breaker: 
    * Hysterix Library
    * Server-side Circuit Breaker
    * Client-side Circuit Breaker
    * Proxy Circuit Breaker
      * introduces Network bottle neck
  * Service Discovery
    * Location of MS may not be statically known at design time
    * using Service registry
      * adopted from SOA
      * = a service that can be used y other components to retrieve ending information about other components
      * in SOA, service discovery part of enterprise service bus
      * in MSA, service discovery as non-standard custom implementations
    * Gateways:
      * single entry point for many APIs
      * since it is an entry point, it is natural to equip it with e.g. service discovery load-balancing, monitoring, security, etc
  * "being essentially distributed, microservices is founded on the well-known mechanism of message passing"
  * all internal services are subjects to potential communciation failures and overloads
  * choreography does not require central control. a critical feature for the scalability of MSA
* [@AAE16]
  * Mache ich auch eine "Mapping Study"?
  * The microservices architecture has become a dominant architectural style choice in the service oriented software industry. Microservices is a style of architecture which puts the emphasis on dividing the system into small and lightweight services that are purposely built to perform a very cohesive business function, and is an evolution of the traditional service oriented architecture style
  * a distributed application where all its modules are microservices
  * commonly agreed benefits:
    * increase in agility
    * developer productivity
    * resilience
    * scalability* reliability
    * maintainability
    * separation of concerns
    * ease of development
  * Even though microservices have emerged from the software industry and have been the focus of practitioners in the last decade[28][22], academic researchers have not kept with the pace
  * Relevante keywords (werden auch für mich irgendwie relevant sein)
    * Communication/Integration
    * Service discovery
    * Performance
    * Fault-tolerance
    * Security
    * Tracing and Logging
    * Application Performance Monitoring* Deploying operations
  * Quality Attributes:
    * Scalability: expandable, evolutionary
    * Interestingly, it has been noticed that there was no distinction between component diagrams and container diagrams in the literature
    * Maintainability: reducing complexity, isolation, loose coupling , decouple, distributed, containerization, autonomy
    * Deployment: expandable, adaptability, changeability, flexible implementation, dynamically changing
    * Health management: resilience, reliability, disaster recovery, no single point of failure
    * Modularity: single responsibility, reduce complexity, separate business concern, specialization, customizable
    * Manageability: self-managed, decentralized management, audibility
    * Performance: response times, transaction duration, throughput, efficiency
    * Reusability: pluggable
    * Technology heterogeneity: portability, freedom to choose a lot of technologies or programming languages
    * Independence: reducing complexity, isolation, loose coupling , decouple, distributed, containerization, autonomy
    * Technology heterogeneity: portability, freedom to choose a lot of technologies or programming languages
    * Agility: iterative, incremental, continuous delivery
    * Security
    * Load balancing: workload intensity distribution
    * Organizational alignment: cross-functional team, reduce the conflict between developers and testers
    * Open interface: microservices should provide an open description of their APIs, GUIs and communication messages format

### MSA: timeouts

* see "Laura Bocchi, Julien Lange, and Nobuko Yoshida. Meeting deadlines together. In CONCUR, pages 283–296, 2015"

### MSA: faults

* see "Sara Capecchi, Elena Giachino, and Nobuko Yoshida. Global escape in multiparty sessions. Mathematical Structures in Computer Science, 26(2):156–205, 2016"
* see "Marco Carbone. Session-based choreography with exceptions. Electr. Notes Theor. Comput. Sci., 241:35–55, 2009"

### MSA: dynamic binding

* important!
* see "Fabrizio Montesi and Nobuko Yoshida. Compositional choreographies. In CONCUR, pages 425–439, 2013"

### MSA: parametric behaviour

* important!
* see "Marco Carbone, Sam Lindley, Fabrizio Montesi, Carsten Schürmann, and Philip Wadler. Coherence generalises duality: A logical explanation of multiparty session types. In CONCUR, 2016. To appear"
* see "Nicolas Tabareau, Mario Südholt, and Eric Tanter. Aspectual session types. In MODULARITY, pages 193–204, 2014"

### Curcuit breakers

* laut [@MW16]
  * have been popularised in (book) "Release it! Design and Deploy Production-Ready Software (Pragmatic Programmers). 2007"
  * Akka provides a circuit breaker implementation that supports basic configuration parameters
    * => hat somit Scala (und vll Spring Boot) ebenfalls inherent einen Curcuit Breaker eingebaut im Actor Modell?
  * Hysterix is much more flexible and currently one of the reference solutions; it supports rolling statistics, fallback mechanisms, resource control and control over the states and transitions of circuit breakers

### Service Discovery

* see [@MW16] for example solutions/implementations/technologies 

### Actors vs MS

* [@AH85] basic actor constructs:
  * actor = agents which carries out its actions in response to accepting a Communication
  * actions are:
    * send Communication
      * tun MS auch
    * create more actors
      * ist jetzt eher unüblich, außer vll von irgendeinem scaling process
    * specify the *replacement behaviour* (replecement implements local state change while preserving referential transparency; replacement process is intrinsically concurrent)
      * MS ???
  * order of communications are delivered nondeterministic
  * actor-based architecture, only constraint on the speed of execution stem from the logical dependencies is rhe computation and the limitations imposed by the hardware resources
  * all actors in a system carry out their actions concurrently
    * MS in MSA auch alle concurrent
  * has the implications that message passing can be used to spawn concurrency
  * in the actor model, the delivery of all communications is guaranteed
  * the problem of shared resources with changing local state is dealt with by providing an object.oriented environment without the sequential bottle-neck caused by assignment commands
  * "it is reasonable to expect that large-scale parallel systems will be composed of independently developed and maintained modules. Such systems will be open-ended and continually undergoing change"
    * im prinzip sind die MS jetzt relativ genau das was da beschrieben ist
  * characteristics of open systems:
    * continuous availability: a system may receive communications from the external environment at any point in time. there is no closed-world hypothesis
      * bei REST ja, bei anderem kommunikationsmodell (zB space, queue) an sich nicht zwingend, denn hier entnehmen die MS ja aktiv nachrichten
    * Modularity: the inner workings of one subsystem are not available to any other system; the behaviour of a system must be characterized only in terms of its interaction with the outside
      * MS nur via REST interface (oder was auch immer verwendet wird) ansprechbar
    * extensibility: it is possible for a system to grow. in particular, it is possible to compose different systems in order to define larger systems
      * genau das prinzip von MSA, wo mehrere MS zusammengehängt werden 

### Objects vs MS programs

* "Essential concepts" of Objects in [@Sny93; @Bla13]:
  * obj. embodies an abstraction
    * MS tun das auch
  * obj. provides services
    * liegt bei MS im namen
  * clients issue requests for those services
    * MS werden angesprochen für ihre services, zB via REST
  * obj. are encapsulated
    * MS sind programme, daher encapsulated
  * requests identify operations
    * MS der zB via REST angesprochen wird, muss request die operation in der URL + PUT/GET/etc codieren
  * requests identify objects
    * Request muss irgendwie MS beschreiben, von dem angefordert wird (zumindest abstrakt via nicht-eindeutigen namen, damit dann ggf von Gateway auf einen konkreten dispatched werden kann)
  * new obj. can be created
    * neue MS anlegen, automatisch oder manuell
  * same operation of distinct objects can have different implementations and observably different behaviour
    * neue Programmversion von MS bringt natürlich neue Impl., und kann auch beobachtbar anderes Verhalten zeigen (zB zusätzliche aufrufe anderer Services, etc); muss halt immer noch die selbe erwartete Dienstleistung bringen, dann beeinfluss es das Gesamtsystem nicht, genau wie bei Untertypen
  * obj. can be classified in terms of their services (interface hierarchy __?__)
    * MS ???
  * obj. can share a common implementation (multiple instances)
    * mehrere instanzen des selben MS für horizontale skalierung, benötigt Gateway; essentielles argument für MSA!
  * obj. can share partial impl. (impl. inheritance or delegation)
    * delegation in MS ist service composition!
* [@Giv14]
  * Programmig objects can be interpreted as processes (example via new Operator in C++, creating Object on remote Machine)
  * Encapsulation, which is an important feature of object-oriented programming, clarifies relationships between objects, facilitating parallelization of method execution across distinct objects
    * MS sind encapsulated, und deren Methoden (= services) können durch dieses Wissen ebenfalls leicht parallelisiert werden

### Active Objects vs MS (inkl Gateways)

* [@LS95] definiert Active Object pattern als: "decouples method execution from method invocation in order to simplify synchronized access to a shared resource bymethods invoked in different threads of control"
  * genau dass, was auch in MSA passiert. 1) der MS an sich, denn auch hier bietet die REST schnittstelle eine Entkoppelung
  * Weiters wird in dem Artikel noch diese Erklärung gebracht: "To illustrate the Active Object pattern, consider the design of a connection-oriented Gateway. A Gateway decouples cooperating components in a distributed system and allows them to interact without having direct dependencies among each other"
    * Wieder genau MSA: connection-oriented gateway; decouples cooperating components in DS; interact without direct dependencies
  * Im Artikel werden noch konkrete Beispiele (zB Input/Output Handler etc) gebracht -> gut für mehr Text
* [@LS95] Use the Active Object pattern when
  * The design and implementation of a concurrent program can be simplified
    * Mein these ist auch, dass MSA hinsichtlich Concurrency leichter zu erdenken sind als andere Modelle
  * Multiple threads of control require synchronized access to shared data
    * Datastore-MS bieten ebenfalls einen synchronized data access (deren DB sind ja jeweils shared data)
  * The order of method execution can differ from the order of method invocation
    * Bei einem REST-based (zB Spring) MS, kann ich mich nicht darauf verlassen, dass der erste REST aufruf auch der erste ist der ausgeführt wird (je nachdem was im internen Spring Concurrency Modell zuerst dran kommt)
  * The operations on a shared object are relatively coarse-grained
    * coarse-grained ist eine gewünschte Eigenschaft von MSA
* [@LS95] The Active Object pattern offers the following benefit
  * Enhance application concurrency while reducing synchronization complexity
    * Wieder genau MS
  * Leverage parallelism available from the hardware and software platform
    * Auch wieder MS, "inherente Parallelität" wie ich das gerne nenne, wenn die Hardware Multi-core bzw Multi-Maschine
* [@LS95] The Active Object pattern has the following drawbacks
  * It potentially increases context switching, data movement, and synchronization overhead
  * It may be difficult to debug programs containing active objects due to the concurrency and non-determinism of the Scheduler 
* Neue Service-oriented Languages bauen auf der Idee von Active Objects auf (und diese Sprachen bauen ja im Prinzip MS auf Sprachebene nach). **In welchen Quellen stand das?**
* [@GB99] beschreibt aspekte von active objects:
  * Proactivity: an agent (= active object) has a goal; it does not simply act in response to messages from other agents (im gegensatz zum Actor model)
    * manche MS sind auch genau dafür da, während andere nur reaktiv sind (eine genaue unterscheidung gibts hier meines wissens nach in der literatur noch nicht)
  * Sociability: agents can interact by speaking different languages (hier ist was komisch-altes gemeint)
    * aber in MSA können die MS auch 1) in verschiedenen sprachen geschrieben sein, und 2) via verschiedene kommunikationsmodelle reden (REST, message queues, spaces, etc)
  * Adaptability: komisches zeugs


### Subtyping vs neue MS Version

* Subtyping: Ein Typ ist dann ein Untertyps eines Obertyps, wenn er überall dort verwendet werden kann, wo der Obertyp erwartet wird
* Vorteil von MSA: Es kann jederzeit eine neue Instanz (Update auf neue Programversion) eines MS gestartet werden, ohne das Gesamtsystem der MSA durcheinanderzubringen, solange sich der MS bzgl seiner Schnittstelle genau so verhält wie seine alte Version
* Update von MS <=> Subtype von Klassen/Objekten/etc
* Praktischer Vergleich: Dependency Injection
  * In Java Enterprise / Spring kann mittels XML basierter DI die verwendete Implementierung eines Interface Typs ausgetauscht werden, ohne das Gesamtsystem neu zu kompilieren, dh __Austausch (= Update) der Funktionalität__ ohne die gesamte Application zu ändern
  * Update und re-deploy eines MS, welcher die selbe Aufgabe erfüllt, wie zB

### Inheritance

* [@Giv14]
  * "Having defined processes as programming objects, it is now straighforward to derive new processes using previously defined processes"


## Concurrency and Parallelism in Microservice Architectures

MSA per design Concurrent

Wenn Service richtig geschrieben, kann ich diese Scalieren indem von jedem Service entsprechend mehr Instanzen laufen (Parallel). Benötigt natürlich API Gateway um Aufgaben zu verteilen, was aber über den Scope dieser Arbeit hinaus geht.

Dh. MSA sowohl Concurrent wie auch Parallel. MSA lösen also wieder nur Konzepte die auch ProgLang lösen (traditionell eher concurrent als parallel, aber das ist eine Sache der Sprachen).

-> Ergo nur deswegen MSA, weil Sprachen diese Konzepte nicht gut genug umsetzen

-> Tatsächlich ist in traditionellen Sprachen Concurrency noch eher umsetzbar, tatsächlich parallele Ausführung von Teilen (zB Actor == MicroService) sehr schwer, schon gar keine Verteilung im Netzwerk.
  -> könnten hier VMs aushelfen
  -> nennt man das Location-Transparency

## Summary

# Prototypical Comparison of a Concurrency-based and a Microservice-based implementation for the same Scenario

## Scenario

Anforderungen an das Szenario; welche Showcases müssen demonstriert werden können:

* Update von Funktionalität ohne Änderung des Gesamtsystems
  * Deployment einer einzigen neuen MS-Programversion
  * Update durch neuen Untertyp und Deployment mittels Dependency Injection
* Synchronized access to shared data (zB die Fabrikshalle)
  * Datastore MS, der von mehrere MS gleichzeitig benutzt werden kann
  * Actor/ActiveObj/WasAuchImmer, welches die Sync to irgendeinem Datenspeicher übernimmt
* Coarse grained operations on shared "objects" (in active objects), bzw auf services allgemein
  * Kommunikation mit einem Roboter ist wohl ein einfaches Beispiel (via Object oder via Service Kommunikation)
* Kein shared state
  * Alle Actors/ActiveObbj/WasAuchImmer hat eigenen Datenspeicher
  * MS haben eigenen State (und möglicherweise sogar eigene DB)
  * Gemeinsame Datenspeicher via DataStore "pattern" (ist das irgendwie als echtes Pattern festgehalten?)
* reusing, orchestration, aggrgation
  * "every MS can be reused, orchestrated and aggregated with others"
    * reuse: mehrere instanzen des selben MS starten
    * orchestration: ?
    * aggregation: ?
  * passendes gegenstück zu concurrency model/objecten/etc?
    * reuse
    * orchestration
    * aggregation
* Bounded context
  * MS: "Related functionalities are combined into a single business capability; implemented as a service"
  * OOP: __Wie lauten die genauen definitionen, zB aus dem Buch von Meyer??__: 1) sich nur um eine Concern kümmern; 2)
* Size
  * OOP: nicht zu groß, sonst mehrere klassen; für maintainability; OOP generell für extendibility
* Technology heterogeneity
  * in MSA können unterschiedliche MS in unterschiedlichen programmiersprachen geschrieben werden: wäre interessant für implementierung, einen service nicht in Java (zB Scala, Clojure, Ruby, irgendwas anderes) zu schreiben; idealerweise einen der nicht aufwändig ist!
  * nicht machbar in OOP etc


~TODO
Hier beschreibe ich kurz die "Angabe" zu meinen Implementierungen. Es soll durch eine Geschichte motiviert werden
~

In order to base our implementations on a realistic scenario, we motivate the generel setting the implementations could actually be put to their use in a short summary:

~ {font-style: italic; width: 40%; margin: 2ex;}
A long time ago in a galaxy far, far away....

The Republic is crumbling under attacks by the ruthless Sith Lord, Count Dooku. His Separatist Droid Army is produced automatically inside Smart Factories somewhere in the Outer Rim. All production steps are performed by autonomouse droids. This highly concurrent system will lead to the ultimate victory over the Jedi....
~

In this scenario, we simulate the production processes of such a *smart factory*. A variaty of coordination problems therefore have to be handled. The following actors (here, we mean the "droid" actors, not actors as in the actor model) are involved:

* customers (separatist leaders ordering battle-droids)
* management droids
* logistic droids
* assembly droids
* quality-assurance droids
* delivery droids

The following poducts (battle droid models) can be produced inside the smart factory:

~TODO
droids siehe: http://starwars.wikia.com/wiki/Separatist_Droid_Army
~

* B1 battle droid
* B2 super battle droid
* Droideka
* Super tactical droid


We created two prototypical impelementations simulating the descripated *smart factory*. One implementation is written in Erlang using its actor model. The other implementation is written with a microservice architecture, in [**Java ?**] / [**Go ?**]

## Actors vs. autonomous Agents

In microservive architectures, it is not usual for services to act as autonomous *active* agents. Some of the described droids in our scenario show activate (**TODO** hier ein wort für "selbst aktiv werdend") behaviour. For example, the logistic droids decide themselves which work step they will [**TODO** auswählen/als nächstes verfolgen/sowas in der art] perform next. 

On the other hand, the actor model is considered to consist of *passive*, that is *reactive*, components. 

[**TODO** Hier sollte ich dann irgendwie probleme zwischen actor model actors und agents besprechen, und dabei die literatur irgendwie etwas miteinbebziehen] The movements from active objects towards *active agents* has be discussed in [@GB99]. The problem we are facing is, that 



# Recommendations


# Discussion


# Outlook

~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

# Conclusion

[BIB]

<!-- TODO glossar, nomenclature, index -->

<!-- We need to close the HTML class we opened right at the top -->
~ End MainPanel
