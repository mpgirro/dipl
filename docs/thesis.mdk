[INCLUDE=style/marticle]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
<!--Title        : Concurrent Programming Languages and Microservice Architectures-->
Title        : Concurrent Programming for Microservice Architectures
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2017
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : alpha
Cite All     : False

Package      : mathptmx

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Tex Header   : 
  \epigraphsize{\small\itshape}
  \setlength\epigraphwidth{8cm}
  \setlength\epigraphrule{0pt}
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { 
  background-color: LightGray;
  padding: 1ex;
}
.Mind {
  background-color: #cbffcb;
  before="[";
  after="]"
}
.Todo { 
  background-color: Aqua; 
  padding: 1ex;
}

@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : webpaginated.css
  Script*       : webpaginated.js
}
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }



~ Begin HtmlOnly
[TITLE]
~ Begin SidePanel
[TOC]
~ End SidePanel
~ End HtmlOnly
<!-- We open an HTML class here, which we'll need to close at the end -->
~ Begin MainPanel

<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->


# Danksagung { -; toc:clear; }

TODO

<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

# Kurzfassung { -; toc:clear; }

~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~

# Introduction

~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

## Methodology used


* the assumptions/theses/laws/etc on MSA presented in chapter "MSA" were identified through thorough literature research

## Road Map

# The Microservice Architecture Style

# Programming Paradigms: a selected Overview

## Imperative, Structured and Procedual Programming


## Object-oriented Programming

* Data Abstraction and Modularity

### History of Objects: Simula and Smalltalk

## Functional Programming


## Event-Driven and Flow-Driven Programming



## Logic and Constraint Programming


# Programming Services as a Paradigm 

(aka Commonalities between Programming Paradigms and Microservices)

# Models of Concurrent Computation

## Basic Concepts in Concurrency

### Execution Order and Nondeterminism

* see chapter 14 in "Concepts in Programming Languages" by Mitchell

## Threads, Locks and Shared State

### Case Study of the Java Concurrency Model


## Software Transactional Memory


## Actors and Active Objects

### Case Study of the Scala Concurrency Model


## Event-driven Concurrency


### Case Study of the JavaScript/node.js Concurrency Model


## Other Approaches and Concurrency Primitives


# Concurrency Models for Service-oriented Programming

* Distributed Programming ?
* die Überschrift passt nicht wirklich
  * Distributed Programming with classical Programming Paradigms
  * Distributed Programming through Microservices
* hier sollen die Modelle beschrieben werden, welche sich am besten für die Gemeinsamkeiten eignen (ausgewählt basierend auf den identifizierten Attributen)

# 

# Recommendations

# Discussion

# Outlook

# Conclusion

---

# Microservices and Microservice Architecture

~ Epigraph { caption: "Higgs Boson (2012 -- present)" }
Don't give up on your dreams, keep on sleeping.
~

~ LitNote
* <https://martinfowler.com/articles/microservices.html>

* keywords for microservices challenges from [@AAE16]:
  * Communication/Integration (API, REST, sockets, TCP, gateway, circuit breakers, load balancer, proxy)
  * Service discovery (API gateways, etc)
  * Performance ( QoS, performance, SLA, speed, simulation)
  * Fault-tolerance
  * Security
  * Tracing and Logging
  * Application Performance Monitoring
  * Deployment operations
* eventueller Vergleich mit Komponentenbasiertem Softwareentwurf? "Bei einem komponentenorientierten Softwareentwurf sind Softwaresysteme in möglichst unabhängig wartbare und wiederverwendbare Softwarekomponenten zu zerlegen. Diese Ziele lassen sich verfolgen, indem bei der Definition von Softwarekomponenten dem Entwurfsprinzip der maximalen Kohäsion bei gleichzeitig minimalen Abhängigkeiten gefolgt wird [Szyperski et al. 2002, S. 40; Parnas 1972]" -> http://www.enzyklopaedie-der-wirtschaftsinformatik.de/lexikon/is-management/Systementwicklung/Hauptaktivitaten-der-Systementwicklung/Softwareentwurf/Komponentenorientierter-Softwareentwurf/index.html
~

## Software Architectures and Concurrent Systems

### From the early days to Object-oriented design patterns [title from DGL17]

* [@DGL17] This spike of interest contributed to an increase in the number of existing software architecture patterns (or generally called styles), so that some form of classification was then required. This problem was tackled in one of the most notable works in the field, the book “Software Architecture: Perspectives on an Emerging Discipline” by Garlan and Shaw
* [@DGL17] The classic by Gamma et al. [36] covers the design of object-oriented software and how to translate it into code presenting a collection of recurring solutions, called patterns.

### Service-oriented Architectures

#### Service-level design principles

Services are:

* Services are reusable
* Services share a formal contract
* Services are loosely coupled
* Services abstract underlying logic
* Services are composable
* Services are autonomous
* Services are stateless
* Services are discoverable
* Services have a network-addressable interface
* Services are location transparent

### Componentization via Services (geklaut von M.Fowler)

~ TODO
Kapitel vll eher "Evolution of the Components" nennen? Das Service deren Weiterentwicklung sind?
~

~ TODO
Case Study: Concurrency in ABCL/1 [@Yon86a]

* "Each object in our computation model has its own (auto- nomous) processing power and it my have its local persistent memory,thecontentsofwhichmpcesentitsstate. Anobjectis always in one of three modes: dormant, active, or waiting. An object is initially dormant. It becomes active when it receives a message that satisfies one of the specified patterm and con- straints."

* "When an active object completes the sequence of actions that are performed in response to an accepted message, if no subsequent messages have arrived, it becomes dormant again. An object in the active mode sometimes needs to stop its current activity in order to wait for a message with specified patm'ns to arrive. In such a case, an active object changes into the waiting mode. An object in the waiting mode becomes active again when it receives a n~quired message."

=> vgl mit REST API und wenn ein Service einen anderen Service synchron anspricht
~

## Flexibility vs Efficiency

über knowledge sharing (copy state durch message passinng vs shared memory)

~LitNote
* see "Iheritence and Synchronization in Concurrent OOP"
~

## Quality Attributes

### Performance

Case Study: JSON in Service as a Performance factor (siehe [@OBM05] p.15)

## Smart endpoints and dumb pipes (geklaut von M.Fowler)

## Failure is inevitable

## API gateways, circuit breakers and discovery

Case study: Hysterix library

Case study: Akka provides a circuit breaker implementation [@MW16]

## Concurrency considerations

~ LitNote
* Microservices sind ja per Design Concurrent, da eigene Programme (Service = Component). Und wenn man MS skaliert (mehrere Instanten gleichzeitig startet) dann ist diese Component auch parallel. Also falls man auf mehreren Maschinen deployed
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@FL17]
~

## Development, Debugging and Maintenance

~ Epigraph { caption: "Filipe Fortes" }
Debugging is like being the detective in a crime movie where you're also the murderer.
~

* [DGL17]: microservices implement a limited amount of functionalities, which makes their code base small and inherently limits the scope of a bug.Moreover, since microservices are independent, a developer can directly test and investigate their functionalities in isolation with respect to the rest of the system

## Summary

# Concurrency, Distributed Programming and Scalability

## Summary

# Concurrency Concepts

## Actor-based Concurrency

## Dataflow Programming

## Communicating sequential processes

<https://en.wikipedia.org/wiki/Communicating_sequential_processes>

## Summary

# Object Oriented Design Principles vs. Microservice Architectures

* bzgl OOP: siehe <https://sanaulla.info/2008/06/26/cohesion-and-coupling-two-oo-design-principles/>

## Summary

# The Microservice Architecture Style


## Implicit Concurrency through (Framekworks|Inversion of Control)

~ TODO
Über Concurrency die einem zB Spring Framework gibt
~

## MSA and the Unix Philosophy

> Text streams are to Unix tools as messages are to objects in an object-oriented setting

quelle: "Rule of Composition: Design programs to be connected with other programs." <http://catb.org/esr/writings/taoup/html/ch01s06.html#id2877684> (müsste bereits eine ordentliche Literaturreferenz existieren): [Raymond, Eric S. (2003), "1.6.3 Rule of Composition: Design programs to be connected with other programs", The Art of Unix Programming, Addison-Wesley, pp. 15–16, ISBN 978-0-13-142901-7.]

## Summary

# TODO

## Concurrent by Design Objects

> OrcO: Concurrency First Approach on Objects

## Foundational Issues of concurrent systems

## Concurrency and Parallelism in Microservice Architectures

MSA per design Concurrent

Wenn Service richtig geschrieben, kann ich diese Scalieren indem von jedem Service entsprechend mehr Instanzen laufen (Parallel). Benötigt natürlich API Gateway um Aufgaben zu verteilen, was aber über den Scope dieser Arbeit hinaus geht.

Dh. MSA sowohl Concurrent wie auch Parallel. MSA lösen also wieder nur Konzepte die auch ProgLang lösen (traditionell eher concurrent als parallel, aber das ist eine Sache der Sprachen).

-> Ergo nur deswegen MSA, weil Sprachen diese Konzepte nicht gut genug umsetzen

-> Tatsächlich ist in traditionellen Sprachen Concurrency noch eher umsetzbar, tatsächlich parallele Ausführung von Teilen (zB Actor == MicroService) sehr schwer, schon gar keine Verteilung im Netzwerk.
  -> könnten hier VMs aushelfen
  -> nennt man das Location-Transparency


# Prototypical Comparison of a Concurrency-based and a Microservice-based implementation for the same Scenario

## Scenario

Anforderungen an das Szenario; welche Showcases müssen demonstriert werden können:

* Update von Funktionalität ohne Änderung des Gesamtsystems
  * Deployment einer einzigen neuen MS-Programversion
  * Update durch neuen Untertyp und Deployment mittels Dependency Injection
* Synchronized access to shared data (zB die Fabrikshalle)
  * Datastore MS, der von mehrere MS gleichzeitig benutzt werden kann
  * Actor/ActiveObj/WasAuchImmer, welches die Sync to irgendeinem Datenspeicher übernimmt
* Coarse grained operations on shared "objects" (in active objects), bzw auf services allgemein
  * Kommunikation mit einem Roboter ist wohl ein einfaches Beispiel (via Object oder via Service Kommunikation)
* Kein shared state
  * Alle Actors/ActiveObbj/WasAuchImmer hat eigenen Datenspeicher
  * MS haben eigenen State (und möglicherweise sogar eigene DB)
  * Gemeinsame Datenspeicher via DataStore "pattern" (ist das irgendwie als echtes Pattern festgehalten?)
* reusing, orchestration, aggrgation
  * "every MS can be reused, orchestrated and aggregated with others"
    * reuse: mehrere instanzen des selben MS starten
    * orchestration: ?
    * aggregation: ?
  * passendes gegenstück zu concurrency model/objecten/etc?
    * reuse
    * orchestration
    * aggregation
* Bounded context
  * MS: "Related functionalities are combined into a single business capability; implemented as a service"
  * OOP: __Wie lauten die genauen definitionen, zB aus dem Buch von Meyer??__: 1) sich nur um eine Concern kümmern; 2)
* Size
  * OOP: nicht zu groß, sonst mehrere klassen; für maintainability; OOP generell für extendibility
* Technology heterogeneity
  * in MSA können unterschiedliche MS in unterschiedlichen programmiersprachen geschrieben werden: wäre interessant für implementierung, einen service nicht in Java (zB Scala, Clojure, Ruby, irgendwas anderes) zu schreiben; idealerweise einen der nicht aufwändig ist!
  * nicht machbar in OOP etc


~TODO
Hier beschreibe ich kurz die "Angabe" zu meinen Implementierungen. Es soll durch eine Geschichte motiviert werden
~

In order to base our implementations on a realistic scenario, we motivate the generel setting the implementations could actually be put to their use in a short summary:

~ {font-style: italic; width: 40%; margin: 2ex;}
A long time ago in a galaxy far, far away....

The Republic is crumbling under attacks by the ruthless Sith Lord, Count Dooku. His Separatist Droid Army is produced automatically inside Smart Factories somewhere in the Outer Rim. All production steps are performed by autonomouse droids. This highly concurrent system will lead to the ultimate victory over the Jedi....
~

In this scenario, we simulate the production processes of such a *smart factory*. A variaty of coordination problems therefore have to be handled. The following actors (here, we mean the "droid" actors, not actors as in the actor model) are involved:

* customers (separatist leaders ordering battle-droids)
* management droids
* logistic droids
* assembly droids
* quality-assurance droids
* delivery droids

The following poducts (battle droid models) can be produced inside the smart factory:

~TODO
droids siehe: http://starwars.wikia.com/wiki/Separatist_Droid_Army
~

* B1 battle droid
* B2 super battle droid
* Droideka
* Super tactical droid


We created two prototypical impelementations simulating the descripated *smart factory*. One implementation is written in Erlang using its actor model. The other implementation is written with a microservice architecture, in [**Java ?**] / [**Go ?**]

## Actors vs. autonomous Agents

In microservive architectures, it is not usual for services to act as autonomous *active* agents. Some of the described droids in our scenario show activate (**TODO** hier ein wort für "selbst aktiv werdend") behaviour. For example, the logistic droids decide themselves which work step they will [**TODO** auswählen/als nächstes verfolgen/sowas in der art] perform next. 

On the other hand, the actor model is considered to consist of *passive*, that is *reactive*, components. 

[**TODO** Hier sollte ich dann irgendwie probleme zwischen actor model actors und agents besprechen, und dabei die literatur irgendwie etwas miteinbebziehen] The movements from active objects towards *active agents* has be discussed in [@GB99]. The problem we are facing is, that 



# Recommendations


# Discussion


# Outlook

~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

# Conclusion

[BIB]

<!-- TODO glossar, nomenclature, index -->

<!-- We need to close the HTML class we opened right at the top -->
~ End MainPanel
