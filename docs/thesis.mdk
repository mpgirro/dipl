[INCLUDE=style/marticle]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
<!--Title        : Concurrent Programming Languages and Microservice Architectures-->
Title        : Concurrent Programming
               and the Microservice Architecture Style
Subtitle     : Hier könnte Ihre Werbung stehen!
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2018
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : style/keynat.bst
Cite All     : False

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Tex Header   : 
  \epigraphsize{\small\itshape}
  \setlength\epigraphwidth{8cm}
  \setlength\epigraphrule{0pt}
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { 
  background-color: LightGray;
  padding: 1ex;
}
.Mind {
  background-color: #cbffcb;
  before="[";
  after="]"
}
.Todo { 
  background-color: Aqua; 
  padding: 1ex;
}

<!-- TODO brauch ich das hier?
@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : style/webpaginated.css
  Script*       : style/webpaginated.js
}
-->
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  @import url(https://fonts.googleapis.com/css?family=Crimson+Text);
  body.madoko {
    font-family: "Crimson Text", serif;
  }
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }
  .a, a:visited {
    color: #0000EE;  
  }

[TITLE]

<!--
~ HtmlOnly
A PDF Version of this thesis is available at [max.irro.at/pub/thesis/dipl.pdf](http://max.irro.at/pub/thesis/dipl.pdf)
~
-->




<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->


~HtmlOnly
[TOC]
~


<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

In recent time, a new architectural style called *microservice architecture* gain popularity in the scientific community and industrial applications. In this time, applications are composed of small independent and isolated components called *microservices* communicating via lightweigt communication mechanism. This inherent distributed components result in an concurrent nature of the overall application. In this thesis, we explore the interrelations of the microservice architecture style with programming concurrent applications. We argue that the microservice components have much similarity to the actor model, and that many of todays actor implementations are extensions of the theoretical actor model by characteristics shared by the principle ideas behind microservices. It remains to ask if microservice architectures have aspects exalted to those of actor-based software architectures, or else actor-based concurrent could would/should/could have been the answer to the needs that lead to microservices in the first place. 
We test our findings on the implementations of the architecture of a domain specific search engine.

# Kurzfassung { -; toc:clear; }

# Danksagung { -; toc:clear; }

TODO

# Preface / Authors Note { -; toc:clear; }

Back in early 2016, I came across a comment thread discussion[^fn-hackernews] on the famouse "HackerNews" (*news.ycombinator.com*) where someone eventually claimed: "*You'll never hear an Erlang programmer even talk about microservices because they are a solution to a problem that doesn't exist in Erlang, or any sufficiently concurrent language for that matter*". First I thought this was asking for a "`[citation needed]`"[^fn-xkcd], but it was followed by a second statement that instead started to intrigued me:

> "The architecture of an idiomatic Erlang-based system is essentially a microservice architecture."

But is it really? I was wondering. It would have some fundamental implications. Erlang is an interresting language (and we will motivate some of the reasons why), and one of its basic building blocks are what it defines as *processes*. They are Erlangs version of the Actor model for concurrent programming. If the claim that any Erlang system is a microservice architecture, than these processes would mirror the microservices. And the name "process" already motivates why this might be the case. Any microservices most essential property is that it is contained within a single, dedicated (operating-system) process, and these are by nature concurrently executed on the OS level. One thing that I thought was odd though (back then at least), was that Erlangs processes are Actors, and Actors are for concurrency (like threads), while a microservice by its nature is really a component of a distributed system. And if concurrency primitives can meet the concerns a distributed system architecture style can, then why bother with all the hassles that usually come with distributed programming anyway?

Having been passionate about microservice architectures as an alternative to ever growing monoliths for some time back then, this idea would remain in the back of my head and pop up occasionally to think about when there was time to think about such things - like on public transport.  

Over a year later, I've read an article[^fn-qcon] about a presentation given by Joe Duffy, former Director of Engineering for languages and compilers at Microsoft, that stated:

> "Duffy expects to see a return of distributed programming with increasingly fine-grained distributed systems that will make systems look more and more like classic concurrent systems."

Now, these fine grained distributed systems Duffy is speaking about are what we have dubbed microservice architectures at the moment, and based on the previous claim, the "classic concurrent systems" they resemble would look like idiomatic Erlang systems, that is Actor-based concurrent systems in general.

Now, from the first claim and the principles of microservice design, we can argue that microservice architectures qualify for such fine grained distributed systems Duffy is speaking about. And this would mean that the "classic concurrent systems" these distributed systems resemble would look like idiomatic Erlang systems, that is Actor-based concurrent systems in general.

And this, I thought, was worth some further investigation. The results of this investigation is this thesis. May it spark in you the idea that you might not want another microservice architecture for your next project so easily.

Vienna, June 2018

Maximilian Irro

[^fn-hackernews]: https://news.ycombinator.com/item?id=8665690
[^fn-xkcd]: https://xkcd.com/285/
[^fn-qcon]: https://www.infoq.com/news/2017/03/distributed-programming-qcon

~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~


Introduction
============



~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

In this thesis, we will take a close look at two concept, the Actor programming model, and the microservice style, and compare them to each other.

## Methodology used

* the assumptions/theses/laws/etc on MSA presented in chapter "MSA" were identified through thorough literature research
* literature review for chapter: concurrency, actor model, microservice paradigm, similarities and differences
* practical work for actor solution, microservice solution

## Road Map



Concurrent Programming
======================

~LitNote
* [@Agh85] describes 3 "foundational issues" of concurrent systems
    * Shared resources
    * Dynamic Reconfiguration
    * Inherent Parallelism
~


## Execution Order and Nondeterminism


## Synchronization and Coordination as Concurrency Control


* Threads, Locks and Shared State
* Message passing


## Concurrency at the Programming Language Level {#sec-concurrency-language-level}

~ LitNote
allgemeines über die Abstraktionen von Nebenläufigkeit, zB Threads and Locks, Futures, STM, etc
~

## Concurrency at the Operating System Level {#sec-concurrency-os-level}

~LitNote
* The Process, Inter-process Communication, inherent concurrency
* C like fork-join pattern was always a basic a way of write concurrency (outsourcing the concurrency aspect to the OS) --> Literatur?!
* Middlewares/Virtual machines can provide a transparent way to distribute threads to multiple cores --> Literatur?!
~

## Concurrency at the Network Level {#sec-concurrency-network-level}

~ LitNote
* "Distributed is truely concurrent"
    * Networked programs are always concurrent due to the isolation and completely independent execution of their resources
    * networked can also mean a network communication of programs on the same machine / same OS, so concurrency is OS level, abstracted to the network level
* **this chapter should explain why distribution is just another form of concurrency within a system**
~


The Actor Model {#ch-actor-model}
===============



~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~

## Basic Actor Idea

## Isolation

~LitNote
every actor owns its state exclusively (should also have unique DB -> bad performance, discuss in Actor-Impl chapter)
~

## Immutable Message Passing

## Typed Actors/Active Objects {#sec-active-objects}

~LitNote
* active objects are basically actors with a different API
    * realized with a proxy object
* vorteil: typsicherheit zur compile time, dass nachrichten an das object (den dahinterliegenden generierten actor) auch wirklich verarbeitet werden können
~

``` {language:java}
class Foo {
    private int a = 1;
    void add(int b) {
        a += b;
    }
    int get() {
        return a;
    }
}
```

Using the above class `Foo`, we can create the following simple program:

``` {language:java}
1 void doSomething() {
2   Foo f = ...; // get reference to a Foo instance
3   f.add(1);
4
5   print(f.get()); 
6 }
```

In a single threaded program, once line `4` is reached, it is save to assume that the the addition has been executed and the internal field `a` was altered. The returned value by the `get()` call in line `5` will result in `2`. 

Altering the definition to `class Foo extends ActiveObject {...}`{language:java}, with some arbitrary base class `ActiveObject` that will turn `Foo` into an active object implementation, this observation does not hold any more. When reaching line `4`, there is no guarantee that the addition has actually been executed. Line `3` only dispatched the message, and returned to leave `doSomething` to its own flow of controll. Line `5` will block (because `get` has a return value) and therefore wait until the message has been dispatched and an answer arrived. But be cannot assume that we will receive the value `2`, because other messages could have reached 


## Combining Actor with other Concurrency Models

### Futures

### Software Transactional Memory (STM)

## Object-Oriented Perspective

### Data Abstractions

Encapsulation and Information Hiding

### SOLID design principles

### Design by Contract

### Substitution and Behaviour



The Microservice Paradigm {#ch-microservice-paradigm}
=========================



At the beginning of our current decade, a new architectural term called *Microservice Architecture* emerged. This concept was originally born from the industrial need to break the scalability barrier that monolithic applications inevidently reach [citation needed]{.mind}. Only later the scientific community gained interrest in this paradigm, which lead to an explosion of scientific contributions on this concept. Yet, academia still has some trouble to settle on a common basic definition on the overall concept(s) determining the microservice paradigm. Fowler [@Fow14] gave the first overall review to the microservice concept, and is the original source most scientists refere to. But he focuses on describing the common characteristics from a more practical engineering perspective. [@Dra17a] tried to give a more general, conceptial description, and therefore we will be founding our discussion of this paradigm on the definitions they provide.

Historically, software systems often have always been implemented in a so-called *monolithic* setup, where all the source code is compiled into one single artifact that can be executed on a machine. This is based on the level of abstraction mainstream programming languages provide to break down complexity of the programming task: *modules*. They allow to logically separate concerns ["of ???" - diesen Teil kann ich sicher etwas ausschmücken und auf B. Meyer verweisen]{.mind}, yet the transformation from the abstraction of program code to machine code leads to a result where the different module components are merged into one unified construct: the (monilithic) *executable*. [@Dra17a] defines:

~ Definition {#def-monolith; caption: "Monolith"}
A monolith is a software application whose modules cannot be executed independently.
~   

* Microservice
 : A microservice is a cohesive, independent process interacting via messages      

## Microservice Principles

~ Epigraph { caption: "Groucho Marx"}
These are my principles. If you don't like them, I have others.
~

No shared state, etc

## Communication Channels {#sec-ms-communication}

~LitNote
Open/well-defined Communication Interface
~


Any communication between microservices has to happen accross the boundries of the service processes. This is called *inter-process communication* (IPC) [citation needed]{.mind}. Variouse forms of IPC channels exists. Examples of simple IPC mechanisms are a shared memory section between two processes within the same operating system, or Unix pipes.

The microservice idiom specifies the following requirements on service IPC:

1. Messages between services should be immutable [citation needed]{.mind} 
2. Communication channels should be light-weighted [citation needed]{.mind} 
3. Communication channels should only act as message routers, and therefore should not introduce data processing logic of their own [citation needed]{.mind} . Fowler calls this characteristic "smart endpoints and dumb pipes" [@Fow14]

From the two example IPC mechanisms above, Unix pipes and shared memory, only the pipes qualify for a valid microservice communication channel. Unix pipes transport text strings between processes. The strings represent serialized data (= state information) of one service and is transported in an immutable way between the opposite endpoint of the pipe[^fn-unix-pipes]. Raymond describes this in his Unix *Rule of Composition* as [@Ray03]:

> "Text streams are to Unix tools as messages are to objects in an object-oriented setting. The simplicity of the text-stream interface enforces the encapsulation of the tools". 

This satisfies the channel requirements given above. Therefore pipes are a valid communication mechanism. Shared memory on the other hand faces multiple conceptional problems regarding a microservice communication mechanism. First, messages between services are being send by modifying memory both services have access to. It is not guaranteed in general that these messages are being receiving by the indented recipient unmodified, for a third party entity also having access to the memory could get a lock and make modifications to the data beforehand. Additionally, shared memory validates the no shared resources between services principle already defined.

[^fn-unix-pipes]: Unix pipes are often used in a *pipe and filter* combination. This can cause the impression that pipes are able to perform data transformation (= filter) operations when multiple filters are chained up, and are therefore not guaranteed to transport data unmodified. However, the pipe itself is not applying any processing logic, only endpoints are doing data transformation. A chain of pipes will therefore in general present a modifying communication route, but each single pipe is transporting immutable data. 

## Inherent Concurrency and Distribution

Any microservice within an MSA is by design a dedicated process. As we discussed in section [#sec-concurrency-os-level], processes are inherently concurrent on the operating system level, which facilitates parallelization by default. Any microservice architecture is therefore an inherently concurrent system.

In section [#sec-ms-communication] we discussed the requirements on a communication channel between services. Any mechanism has to be able to send data between processes. Some valid channels (like Unix pipes) are also only capable of sending messages between processes on the same operating system. Alternatively, a generally more safe alternative

Any form of communication has to happen via an inter-process communication mechanism. Some choices for such mechanism include messaging via a form of network interface like REST (__RE__presentational __S__tate __T__ransfer) or AMQP (__A__dvanced __M__essage __Q__ueue __P__rotocol) 


Channels for distributed communication are more likely to provide options to apply some data operation of their own, which would stress the third requirement on microservice communication channels. [citation needed - außer ich argumentiere hier mehr anstatt einfach zu behaupten, zB über spaces wie XVSM]{.mind} 

## Service Granularity (Size, Scope and Granularity)

~LitNote
* "micro should refere to the scope of responsibility, not the lines of code"
* Size vs. Number of Services
~

...

Bonér criticizes the term "micro" for it encourages debating the actual size of a service [@Bon17]. Any size definition requires a metric to be able to make comparisons and argue up two which limit an application may be called "microservice". Therefore, developers focus on metrics like *Lines of Code* up to more obscure ones, e.g. the reported *Two Pizza Team* size, where a service is written and maintained but a team that can be fed by two pizzas[^fn-two-pizza-team] [@Fow14]. These discussions are missleading.

[^fn-two-pizza-team]: Assuming an arbitrary pizza size, this either suggest very small teams, or really big pizzas (ed. note).

## Polyglot Programming

## Object-Oriented Perspective



Commonalities and Differences of Actors and Microservices
=========================================================



~ Epigraph { caption: "Pamela Zave"}
The purpose of software engineering is to control complexity, not to create it.
~

~LitNote
* Diskussion: MS behandeln ebenfalls die 3 "foundational issues" die laut [@Agh85] concurrency modelle lösen sollten
* Weiters zitiert [@Agh85]: "It is reasonable to expect that large-scale parallel systems will be composed of independently developed and maintained modules. Such systems will be open-ended and continually undergoing change (Hewitt and de Jong 85)."
    * und "Actor languages are intended to provide linguistic support for such open systems" -> dh Actor werden als sprachfeature für das verwendet werden, was MS im prinzip sind.
~

## State Encapsulation

~LitNote
* "promise behaviour via API/protocol" --> design by contract
* [@Kan12] 4 four important semantic properties of our
extension based on actor systems: encapsulation, fairness, location transparency and mobility [16 --> Actor Frameworks for the JVM Platform: A Comparative Analysis]
* [@Bon17] "This simple fact has huge implications. It means that data can be strongly consistent only within each service but never between serv‐ ices, for which we need to rely on eventual consistency and abandon transactional semantics"
~

## Communication and Data Coupling

~LitNote
* Sync vs Async, Immutable Messages
* Point to Point, Publish/Subscribe, 
* [@Kan12]: "Safe Messaging: Message passing should have call- by-value semantics to avoid sharing state between actors"
~

## Isolation

~LitNote
* [@Bon17] "Isolation makes it easier to scale each service, as well as allowing them to be monitored, debugged, and tested independently"
~

## Autonomy

~LitNote
* [@Bon17] 
    * "Isolation is a prerequisite for autonomy. Only when services are iso‐ lated can they be fully autonomous and make decisions independ‐ ently, act independently, and cooperate and coordinate with others to solve problems"
    * "Working with autonomous services opens up flexibility around ser‐ vice orchestration, workflow management, and collaborative behav‐ ior, as well as scalability, availability, and runtime management, at the cost of putting more thought into well-defined and composable APIs"
~

## Fair scheduling

~LitNote
* [@Kan12]: Actor model defines fair scheduling that a message is eventually delivered to destination actor except for its permanent “disability”, and no actor can be permanently starved
* MS werden vom OS garantiert das der process drankommt, aber die verteilung von messages (zB bei MQ broker) ist sache des verwendeten kanals, daher keine globale garantie
~

## Internal and external Component Concurrency

~LitNote
* Hier möchte ich einen gewissen Gedanken diskutieren, aber habe keine gute Idee in welchem Kontext (Überschrift bzw einordnung in einem anderen Kapitel) ich das am besten tun sollte. Somit ist es erstmals hier.
* Ich sollte anmerken, dass beide Ansätze per se einmal gar nicht zwingend für Concurrency sind/sein müssen (Actors sind auch ein allg. Programming model). Nur ihre **semantik** führt automatisch zu einer nebenläufigen, ggf auch automatisch zu einer parallelen, Ausführung 
~

In chapter [#ch-actor-model] we discussed the actor model explicitely as a *concurrency model*. Yet this claim is worth debating. In the basic semantic of an actor we discussed, there is no notion of concurrency at all. It is a strictly linear component, that follows a clear, non-concurrent execution schema [hier sollte ich etwas zitieren, und den pseudocode von jemand anderen heranziehen]{.mind}:

```
WHILE TRUE:
    GET next message from mailbox
    process message
    repeat 
```

Nothing wihin an actor expects a concurrent access to its state, or [??? irgendwas zweites]{.mind}. An actor itself is a non-concurrent entity *internally*. Therefore, the actor model is sometimes refered to as simply a *programming model* [citation needed]{.mind}, an approach to writing software components. The most basic case is a single actor. It only knows about itself, therefore can only receive messages from itself, process them, and send messages to itself. The semantic of this behaviour is a simple loop, where no state information leaves the scope of the actor. It results in a simple, single threaded program. 

The title of chapter [#ch-actor-model] features a famouse quote of Carl Hewitt: "*One actor is no actor. Actors come in systems*". The overall idea of - and driving reason to use - the actor programming model is to have more than one actor in place. The models semantic allows to send messages freely between actors within a system. While each actor itself is a non-concurrent entity, this exchange of (immutable) messages semantically allows actors to be executed in a concurrent fashion by the system. 

Actors by themselfs are not concurrent, but their semantic allows them to be executed *externally* in a concurrent manner, within a system. If the actor semantic is preserved at all time - how this can be guaranteed is up to the actual actor system implementation - then an actor does not have to have any awareness of any concurrent processing at all [citation needed]{.mind}. Of course, this does not mean that actor systems are free from the concurrent problems that are introduced by any form of indeterminism, respectivly by message passing. [hier könnte ich noch irgendwas brauchbares aus dem Paper das die Concurrency Bugs behandelt zum besten geben]{.mind}   

A microservice on the other hand has the basic abstraction of a process. Any system process for itself is, from an external point of view, not especially concurrent [??]{.mind}. But within a system, these processes form, just like actors, concurrent nature due to the semantic properties of proccesses. 

Through the basic process semantic [hier sollte ich diese semantik aufzählen: isolation, messages, fair scheduling + quelle]{.mind}, just like with actors, any system of processes lead to a concurrent system. The services external concurrency is always either on the operating system level or the network level (or both). Yet their notion of internal concurrency is divergent from that of an actor. Though it also receives messages of some kind via its public API, and reacts to them, the flexibility in the design of microservices allows to create services that react to multiple messages concurrently. They can have internal notion of concurrent processing. This allows a service to make a synchronouse call (and blocking wait for an answer within the routines code), without blocking as a whole. A microservice therefore can behave as a concurrently accessible resource within the system. The drawback of this degree of freedom is the set of issues any concurrent resource access inherently has. A basic example is locking. When an actor processes a message, it is guaranteed to have unqiue access to its internal state, therefore must no handle any locking and may savely assume its state as up to date. When a microservice accesses any kind of internal resource (state), this resource might currently be locked by an internal transaction mechanism, granting read access, but not guaranteeing that the state is actually up to date. [dirty read? irgendwas allgemeines zu locking und read zitieren]{.mind} 

Programming with microservices does not, unlike actors, free one from the many hassles of internal component concurrency problems per se. Depending on the model used, the pains of threads, locks, transactions, coroutines, etc. are still to be dealt with. But the services size - based on its scope of responsibility - is limiting the complexity of the services internal concurrency considerations relative to the overall systems [citation needed? hab ich da eine? ist ja eigentlich mein eigener beitrag]{.mind}. 

## Location Transparency and Distribution

~LitNote
* Actors und MS ist es an sich egal ob sie lokal oder verteilt ausgeführt werden, beide können dies gut abstrahieren
* [@Reh13] defines requirements on distributed actors:
    * R1: Distributability: Non-distributed applications must be easy to be migrated to clustered set-ups.
    * R2: API-uniformity: The distribution API must be similar for intra-node as well as inter-node applications
    * R3: Compatibility: An application that works locally on one node should also work distributed in a cluster.
    * R4: Flexibility: Beside actors that have access to specific hardware, the developer should freely decide which actor runs on which node of the cluster.
    * R5: Configurability: Simple configuration of the clustering subsystem and the distribution layout.
* [@Kan15] (über distributed/cloud actors)
    * "There (actor) distinctive features make it suitable to support distributed memory parallelism, and it has been widely used in many industrial languages such as Erlang[2], Scala [3], Akka [4]"
    * "However, most related works focus on multi-core environment. Neither inter-parallelism or task parallelism can be easy applied in dynamic distributed environment, because actors distributing over cluster may be- have indeterminable interrelationship, such as uncertain com- munication, dependency and failure"
* [@Kan12] (über distributed actors)
    * Computers connect by network, which makes the environment distributed, disparate, mutable and unreliable
    * According to classifications of parallel programming models in process interaction, mechanisms of which make the parallel processes able to communication with each other, the most common forms of interaction are shared memory, message passing, and implicit [4]
    * In Actor model, location transparency means the actual location of an actor does not affect its name. That is to say, if one actor knows another, they can communicate only by names instead of specific address --> kommunikating via ActorRef instead of pointer; bei MS muss das zB für REST extra ein Service Discovery übernehmen, der dies abstrahiert; 
    * Obviously, State encapsulation is a desirable consequence of location transparency. Location transparency facilitates runtime migration of our computing elements to different nodes, which brings good mobility. Moreover, migration enables runtime optimizations for load-balance and fault-tolerance
~

### The leaky Abstraction of Distributed Objects

~LitNote
* Lokation transparency ist super und alles, wenn es richtig gemacht wird. die Verteilten Objekte machen das auch, und führen zu massiven Probleme --> hier hab ich diesen einen Artikel "A Note on Distributed Computing" oder so. An dieser stelle sollte ich diskutieren wieso Actors und MS diese Probleme nicht haben, bzw was zu beachten ist um es zu vermeiden
~

*Distributed Objects* (DO) was a concept of some 20 years ago. It is an extension to the original object concept. Here, objects did not have to exists within the same program boundary, but could be distributed across multiple programs and therefore host machines. For every DO a proxy object is created, which wrappes the method calls to the actual distributed object, which then does not necessarily has to be located within the same program boundry [quelle für den absatz, wiederholung von "program boundry"]{.mind}. This allows for location transparent method calls. Examples of such  DOs are Java RMI or CORBA [quelle, richtig?]{.mind}. They seem to share many conceptual similarities that we are discussing here. On the one hand, the design goals of Microservices seem to aim towards the single-purpose, minimal and slim skeleton that distributed objects have compared to full-fletched monolithic applications. On the other hand, their distributed nature inherently leads toward the possibilities of transparent concurrent/parallel execution, like actors or active objects do. 

However, the abstraction the distributed object concept provides was found to be be "leaky" due to conceptual problem [citation needed - note on distributed computing]{.mind}. The transparent method call they offer is hiding to much context do be able to handle the many faults that come with any distributed programming setup. A simple example: 

~Todo
hier das beispiel mit dem 1000 methoden aufrufe für die simme von .getSize()
~

We already discussed the analogies of actors and microservices to the notion of objects. Now, with these similarities and the fact that actors (or active objects) and microservices each provide mechanisms for location transparent messaging too, we should discuss weither they qualify as distributed objects themselves. This would mean they face the same problems as DO too. 

#### Do Microservices qualify as Distributed Objects? (ÜBERSETZEN!)

~Todo
Nein. Beim Konzept der vert. Obj wird der Ort des Obj versteckt. Dh bei einem Methodenaufruft ist mir nicht bekannt, ob das Obj lokal oder remote liegt. Da vert. Obj die selbe API wie "normale" (= lokale Obj) haben, habe ich keinerlei Hemmungen low-level API methoden anzuwenden. Bsp: Aufsummieren einer Eigenschaft "Size" über alle meine Objekte einer Kategorie. Bei lokalen Objekte iteriere ich über alle Objekte, rufe o.getSize() auf und summiere die Werte auf. Bei vert. Obj ist mir nicht bekannt ob die Objekte lokal oder remote liegen, deshalb sieht hier die Summenbildung entsprechend gleich aus. Bei angenommen 1000 Objekten führt dies im Worst Case zu 1000 separaten RPCs.
Bei Microservices würde man eine derartige API vermeiden, denn hier ist immer klar, welche Aufrufe lokal (innerhalb des MS) sind, und welche einen RPC (also den aufruf eines anderen MS) bewirken, da man aktiv zB die REST-Schnittstellen ansprechen muss. Um beim Summenbeispiel zu bleiben würde man hier entweder über lokale Elemente iterieren, oder einen ensprechenden Endpoint einrichten, welcher die Summe über alle Elemente eines entfernten MS anfordert.

=> MS != distr. Obj.
~

#### Do Actors qualify as Distributed Objects? (ÜBERSETZEN!)

~Todo
Nein. Hier gilt im Prinzip das selbe Argument wie bei MS. Einen anderen Actor anzusprechen ist eine dedizierte Operation, die sich vom Aufruft der API eines "normalen" Objekts unterscheidet (am Ende läuft es auf den konkreten Syntax der Actor Implementierung hinaus, aber es sollte jedenfalls so sein - Akka macht es einem aus genau diesem Grund sehr sehr schwer einen Actor direkt mittels `new` zu instanzieren - was besonders bei der Java API auffällt - und verlangt stattdessen, dass man via einer `ActorRef` kommuniziert, welche ausschließlich das Senden von Actor-Nachrichten erlaubt, und alle direkten Methodenaufrufe verhindert).
Bzgl des Simmenbeispiels würde man entweder innerhalb des Actors alle Objekte durchiterieren, oder eine Nachricht an einen anderen Actor schicken, dass dieser über alle Objekte die dort vorhanden sind iteriert. Idealerweise sollte dieser dann auch gleich mit dem Ergebnis weiterarbeiten können, sodass der aktuelle Actor nicht auf eine Antwort warten muss. Somit ist auch bei Actors der lokale und der nebenläufige (ggf verteilte) Aufruft nicht zu verwechseln
~

#### Do Active Objects qualify as Distributed Objects? (ÜBERSETZEN!)

In section [#sec-active-objects] we gave a example of the concurrent semantic the API of active objects provide. The method call is separated from the message execution. We demonstrated how the behaviour in case of method APIs with and without return values. Lets consider another example:

``` {language:java}
1 List<Foo> fs = ....; // list of 1000 references
2 int sum = 0;
3 for (Foo f : fs) {
4     sum += f.get();
5 }
6 println(sum);
```

The program iterates over all elements and makes a blocking call to retrieve the value. This has two fundamental issues:

1. The programs will block 1000 times for each element separately
2. If some, or in the worst case all, of the elements are not within the local scope of the program but transparently distributed, this will cause up to 1000 separate remote procedure calls with as many opportunities of any fault a synchronous network call can result in.

The first issue is a result out of bad coding. The second issue is based on the same leaky abstraction distributed objects offer. The `get()` method could be called without the programmer being aware that it actually offers a result value. The abstraction hides too much. Such calls are always blocking, and through the tight coupling they introduce [...was sind hier die katastrophen? Boner erzählt davon ja dauernd]{.mind}

Both issues [wird issue 2 wirklich so gefixt? gehen typed actors in akka so?]{.mind} could be fixed by having `get()` return a `Future[Int]`{language:scala} instead. In functional languages like Scala, handling futures can often be done in an elegant syntactic way due to the data transformation approch that comes natural in functional programming styles, e.g.:

``` {language:scala}
1 Future.sequence(fs.map(_.get))
2  .map(_.sum) 
3  .onComplete {
4    case Success(sum) => println(sum)
5    case Failure(_)   => println("error")
6  }
```

This is an example where it is efficient to combine other abstractions of concurrent computation that integrate well with the actor semantic. Line `1` transforms `fs: List[Foo]`{language:scala} first into a `List[Future[Int]]`{language:scala} and then into a `Future[List[Int]]`{language:scala}. The actor system's dispatcher can then wait [hibernate? dispense? the actor]{.mind} until this future's completion without blocking the underlying thread. The call stack starting in line 2 is only applied upon completion, finalizing the intended result. 

We see, active objects have the potential to be used in the same problematic way distributed object are. If not used with utmost care, method calls can easily introduce remote procedure call semantic in a transparent way, causing bottlenecks, deadlock, [...]{.mind} and having negative impacts on scalability, [...]{.mind} 

~Todo
Possibly. Worin unterscheiden sich aktive Objekte von Actors? In der API. Es wird der Methodenaufruf von der Methodenausführung getrennt. Mit anderen Worten, in der Zeile nachdem man `actObj.doSomething()` aufgerufen hat, ist diese Methode noch nicht umbedingt garantiert fertig (ja es kann gut sein, dass sie noch nicht einmal angefangen wurde auszuführen). Aktive Objekte (jedenfalls in Akka) sind intern via Actors implementiert. Während man einem Aktor jede beliebige Nachricht schicken kann, und dieser **zur Laufzeit** unterscheidet ob er diese versteht/bearbeiten kann, ist bei einem aktiven Objekt durch die Ansprache des aktiven Objekts über eine Methode via das Typsystem **zur Compiletime** sichergestellt, dass der interne Actor die Nachricht auch verarbeiten kann (daher werden aktive Objekte in Akka auch "Typed Actors" genannt). Asynchron ist ein aufruf nur, wenn die Methoden alle `void` als Rückgabewert haben. Ansonsten handelt es sich beim Methodenaufrufs eines Typed Actors um einen synchronen Aufruft (!), und im Falle einer Ortsverteilung der beiden Akteure auch wieder nur um einen RPC. Daher können aktive Objekte in die selben Probleme laufen, wie sie vert. Objekte haben. 
~

## Mobility

~LitNote
* Laut jones Bonér folgt mobility aus location transparency
* [@Kan12] (über distributed erlang actors)
    * Mobility is defined as the ability of processes moving from one node to another. It is classified into two types. Strong Mobility means supporting movement of both code and execution state, while weak mobility only allows movement of code
    * At the system level, mobility is important for load balancing, fault-tolerance and reconfiguration. 
    * [25] = [@Pan94] has shown that mobility is essential for achieving scalable performance.
~

## Single Responsibility

~LitNote
* Unix philosophy
* [@Bon16]
* [@Bon17] "This idea was later brought into the Object-Oriented Programming community by Robert C. Martin and named the Single Responsibil‐ ity Principle2 (SRP), which states that a class or component should “have only one reason to change"
~

## Persistance

~LitNote
Polyglot Persistance, Event/Command Sourcing (??? brauche ich das? - vll für mehrere parallele Stores, wenn einer nachträglich online geht)
~

## Scalability

~LitNote
* 
~

## Load balancing

* Server and Client Side LB

## Elasticity

~LitNote
* Done in MSA which Cloud Management Framework, all components must support dynamic adding and removing of components (requires Service Discovery, etc.)
* Actors can easily be created and kill by messages. A system must support elastic mechanism itself. question is from which components is this command issues? also a management framework? or is the system this detected by itself. in case of cluster, are new actors spawned on random node, or some metric for node with most free resources?
    * interessesting are cases for Stores, because DB/Index resources need to be present, and how are they being brought up to current state --> Event sourcing
* IDEE: Ich werde elasticity nur theoretisch unterstützen. 
    * die MS sind an sich darauf vorbereitet, müsste nur eine neue abstraktionsebene hinzugefügt werden (management framework) die das regelt; event sourcing subsystem für stores fehlt
    * actors impl unterstützt prinzipiell beliebig viele componenten, nur müsste der mechanismus selbst gebaut werden; event sourcing subsystem für das neuaufbauen von directory/index fehlt
~

## Fault tolerance

~LitNote
"failure isolation"
~

## Resilience

~LitNote
"ability to heal from failure" - break free from strong coupling of synchron comm.; circuit breakers

Location transparency, elasticity = "move around in isolation"
~

## Availability

~LitNote
* Actors, siehe: [@Agh85]
~

## Extensibility

~LitNote
* Actors, siehe: [@Agh85]
* gradual/separate replacement of MS
* substitution and subtyping für actors
~


A Concurrent, Parallel and Distributed Problem Scenario {#ch-problem-scenario}
=======================================================



In this chapter we will motivate a problem scenario that requires to be solves in a concurrent manner. It also opens up the opportunities to salvage the benefits that come with parallelization and distribution:  scalability, reliability, etc. To takle the tasks, chapters ? and ? will describe how it can be solved using the programming models of actors and microservices in orther to satisfy the concurrent requirements.

The proposed search engine is dubbed *Echo*[^fn-echo-name]. For easier destinction, the respective implementations will be referenced to as *Echo:Actors* and *Echo:Microservices*.

[^fn-echo-name]: The name "Echo" was choosen for its wonderful characteristics of providing a short namespace and its analogy to *recalling spoken words*.  

## Why is a search engine a concurrent/parall./distr. task?

~LitNote
* Search Engines appears as a closed monolithic system (frontend), but is actually composed of many components that act in an decoupled and asynchronouse manmer (if the searc engine should perform)
* search engine construction in science the field of *information retrieval*, that focuses on *precision* and *recall*, which we will not pay attention to in this work (we will only use some simple scoring methods and trust that the results will be fine)
~

## Domain Description

Podcasts = Decentralized media syndication

## Components

## Information Flow

## Concurrent Tasks

Fetching data (feeds/websites), parsing data (feeds,websites), registering new entities (podcast/feeds, episodes), extending stores directory/index, serving search requests

## Scalability Opportunities

### Scalability through ??? (scaling up = changing allocated resources: memory, CPU)

### Scalability through Parallelization and Distribution (scaling out)

## Elasticity Considerations

## Polyglot Persistence (based on Isolation)



An Actor-based Problem Solution {#ch-actor-solution}
===============================



In this chapter, we will discuss a practical implementation of the problem scenario outlined in chapter [#ch-problem-scenario] using an actor-based programming model approach. When talking about the practical application of an actor model, it is importent to realize that there is not *the* actor model per se, but a big variaty of implementations available through variouse forms of interfaces, either integrated into the programming language (Erlang), as a library (Scala Actors, JetLang), a framework or platform (Akka, ???) [citation needed]{.mind}. In chapter [#ch-actor-model] we discussed the theoretical concept of actors proposed by Hewitt [citation needed]{.mind} as well as the possibilities the actor semantics opens up. The actual actor implementations available are based upon this semantics and resulting possibilities, but vary in terms of features and [???]{.mind}. Therefore it is important to state the specific actor variant used when discussing any actor based system. Our scenario solution is conceived through the Akka actor model. 

## Akka {#sec-akka}

Akka [@Akka17] is an actor implementation available for the JVM that was later ported to the .NET ecosystem [citation needed]{.mind}. The .NET variant (called Akka.NET) is at the moment not able to interweave with the original JVM version [citation required?]{.mind}. Because our solution is solely based on the JVM, therefore all following discussions will refere to the capabilities of Akka's original JVM variant.

Akka is designed as a toolkit collection consisting of several libraries, able to be used in arbitrary combination based on actual need of them. In its core it implements the actor model with the intent to be close to Armstrongs actor implementation that is found in the Erlang language [citation needed]{.mind}. Currently it offers bindings for Scala and Java. Since Scala 2.10 it replaces the default actor implementation offered by Scala [citation needed]{.mind}. Among the reasons were [??? paar sachen aufzählen]{.mind}

~Todo
* Akkas Erweiterungen des Actor models kurz anteasern? Oder das erst in den kapiteln tun, in denen diese gebraucht werden (die anderen einfach unterschlagen)
~ 

## Isolation

State + Behaviour

## Synchronous and Asynchronous Communication

~LitNote
howto channel types (point-to-point, pub/sub), specialized channels (dead letters, guaranteed delivery --> siehe "Akka in Action"); easy to get pub/sub or MQ routing behaviour via Routers (mostly same Actor as Supervisor); why not use JMS (it would offer both MQ/PubSub behaviour, but is not open and not lightweight)
~

## Data Coupling

~LitNote
Messages are always "state at a specific point in time", but when the receiver gets it, it might already be outdated --> just live with it, no ACID; messages are transported via Actor System (e.g. Akka) and therefore data is coupled via the access to the API (e.g. only Scala/Java and compatible languages  - Groovy - may join the system); avoid any pattern that needs to wait for consensus between actors -> they should be able to make progress individually (vgl RegisterEpisodeIfNew, hier könnte auch der parser beim catalog nachfragen); message immutability (den ganzen aufwand den ich getrieben habe um die DTOs immutable zu kriegen, denn Akka macht pass by reference wen die nachricht innerhalb der selben JVM zugestellt wird --> und das macht probleme)
~

## Persistence

~LitNote
* Database (Postgres/Lucene) owning based on isolation, Subactor Handlers for DB access: many workers for one "logical" store because the backend data stores (DB, search index) can handle multiple connections --> breaking the "own your state exclusively paradigm"; Polyglot Persistance
* consider using non-blocking IO/DB APIs (if available), the futures will crowed up the thread pool, therefore use dispatchers for bulkheading (= the thread pool becomes an implicit backpressure)
* if blocking IO has to be done, use dispatchers for bulkheading too, and delegate blocking operations to child actors/workers. This is demonstrated in the Echo implementation
~

## Load balancing

~LitNote
Mailbox, Dispatcher, Command-query separation for stores (CQS, siehe wikipedia, definiert von Bertrand Meyer; create/update/delete = command messages need to be sent to all stores, read = query messages need only to be sent to one store --> **das hier vll eher ein Thema zu Event sourcing?**); Router and Routing Logic (Broker, RoundRobin)
~

## Fault Tolerance

Supervision and Error Kernel

## Resilience

## Scalability

## Elasticity



## Clustering and Mobility

~LitNote
Cluster / Remoting of Akka, built in discovery system among nodes  
~

## Deployment

~LitNote
Mostly of no concern, bit of configutation for cluster setup (seed nodes for peer to peer discovery), cluster singleton and cluster sharding for complex deployment setups
~

## Availability

~LitNote
* siehe: [@Agh85]
~

## Extensibility

~LitNote
* siehe: [@Agh85]
* hier allgemein zu actor subtyping und substituion schreiben etc 
~

## Configuration, logging, etc

## Performance measurement of Actors



A Microservice-based Problem Solution {#ch-ms-solution}
=====================================



In this chapter, we will discuss a practical implementation of the problem scenario outlined in chapter [#ch-problem-scenario] using a microservice architecture approach.

## Isolation

~LitNote
State + Behaviour, Database (Postgres/Lucene) owning, Spring Thread Pool for DB access
~

## Synchronous and Asynchronous Communication

~LitNote
howto Point to Point, Publish/Subscribe, REST and other lightweight stuff, async kafka (but offers only pub/sub), the case for AMQP/RabbitMQ for async jobs (leightweight, open protocol = polyglot, not like JMS) --> use PubSub/Kafka for DataStores (all stores need to update the data records) and MQ/AMQP for Workers (each job needs to be done by one worker)
~

## Data Coupling

~LitNote
No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
~       

## Persistence

~LitNote
* One DB per MS (e.g. PostgreSQL for directory/catalog) and lucene for index
* PostgreSQL accessed by multiple threads concurrently *within* the MS
~

## Load balancing    

~LitNote
to be done manually in API gateway, or via MQ, cliend side LB (Ribbon) or server side LB (zB Zuul - was ich (noch?) nicht habe)
~

## Service discovery

~LitNote
* Was kann ich hier **allgemein** dazu sagen?; Entkopplung von fixen Adressen (Location Transparency)
* requires Discovery mechanism of clients, Consol (alternativ ZooKeeper, Eureka, etc) 
~

## Fault Tolerance

~LitNote
Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 
~

## Resilience

## Scalability

## Mobility

~LitNote
* follows from isolation and location transparency
~

## Elasticity

~LitNote
* benötigt ein (oder in Kombination mehrere) sog. Cloud Management Framework(s)
* Last muss gemessen werden
* MS müssen damit umgehen können dynamisch dem system hinzugefügt oder entfernt zu werden
    * problemlos bei stateless MS workern, insofern isolation + location transparency gegeben ist
    * problematisch bei stateful actors, konkret bei den stores, weil der state (also DB/Index) auf den aktuellen stand gebracht werden muss --> wie? Event sourcing zB
~

## Deployment

~LitNote
depending on specific need, some sort of cloud management framework (or a combination of more) is required. multiple instances easy with container technology (e.g. Docker), but no guarantee for singleton usage
~

## Availability



## Extensibility

~LitNote
* [@Mon16a]: "New versions of components can be gradually intro- duced in a system, by deploying them side to side with previous versions. This advantage can be incorporated in Continuous Integration"
~

## Configuration, logging, etc

## Performance measurement of Microservices



Evaluation
==========



## Software Quality Attributes

~LitNote
SOA qual. attr.

* Performance
* Scalability
* Availability
* Modifiability
* Development distributability (???)
* Deployability
* Portability (Mobility?)
~

## Quality Metrics

### Internal Quality Metrics

~LitNote
Coupling metrics, cohesion metrics, granularity metrics, complexity metrics, autonomy metrics, reusability metrics
~

### External Quality Metrics

## Performance Measurement



Discussion
==========



## The Case for Actors

~LitNote
- easy to write from the ground up
- has to be started as a small programm, and extended one by one (otherwise one gets totally lost in the messages)
- less to do (the actor framework/middleware does a lot for you), but has to live/work with the particula restrictions
- thread switching within an actor can get a problem, e.g. with locking (have seen it with lucene)
~

### Case Study: Why do Scala Programmers mix Actors with other Concurrency Constructs?

## The Case for Microservices

~LitNote
* "One reasonable argument we've heard is that you shouldn't start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn't ideal, since a good in-process interface is usually not a good service interface.)" [@Fow14]
* MS können gut sein wenn man einen bestehenden Monolithem refaktorisiert und aufspaltet (Literatur benötigt!)
* Jonas Boner beschreibt in einem Youtube Talk und im Podcast, dass MS in für große Unternehmen gut sein können, wo es wichtig ist die Code base aufzuspalten um produktiv zu bleiben
* good to break up large monoliths
* literature on project success, where it says that projects transforming monolith into MSA have a high success chance, while projects starting initially with an MSA tend way more to fail
* freedom to practically do whatever you want (if it works within a monolith, this particual function also works within a smaller program = MS)
~

## Empirical Indications

~LitNote
  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refactorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)
~



Outlook & Conclusion
=======



~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

~LitNote
* Services as First-Class Citizens
* [@Kan15] beschreibt eine distributed Actors in Erlang, mit Erweiterungen:
    * "This new model is designed for representing Cloud applications based on actors in a deterministic, expressive and scalable way. It can also solve certain categories of problems more productively than original actor model, and more advantageously in multi-computer ar- chitecture than other deterministic concurrency models such as task parallelism"
    * By introducing distask model, a number of constructs can now be supported. It provides a flexible set of primitives and runtime support to easily write various of distributed applications scaling over a dynamic changeable environment. New capabilities can be summed up for three main points, introduced below:
        * Deterministic Expression: The key powerful expressivity of deterministic concurrency allows programmers to encapsulate complicated communica- tion and synchronization protocols as first-class abstractions
        * Advanced Concurrency in Actors Internal: Internal parallelization, Join Calculus --> **internal parallelization ist genau das was MS mit ihrer internal concurrency auch haben -> das habe ich in einem unterkapitel auch angemerkt. sollte ich auf jeden falls hier zusammenbringen!**
        * Scalability & Fault Tolerance
~

In this thesis, we discussed the new microservices style and quite old principles of concurrent and distributed programming as if they were two competing approaches, and one will eventually emerge victorios. In this chapter, instead of rivalry, want to entertain the though of a unification of both towards a new style of programming. 
One the one hand, we analyzed microservices for their core concepts and found that their natural characteristics implied a high form of isolation. Combined with an asynchronouse communication mechanism, they become highly decoupled and the resulting architecture enjoys the principles of Actor based concurrency combined with the feature of distribution and mobility that agent based systems defined long ago. Yet programming a microservice architecture results in a significant overhead in terms of complexity, maintainability, etc. 
On the other hand, we discussed the classic concurrency model through actors, and found that if it gets extended by additional concepts, such as it is done in existing implementations today, the resulting artifacts yield similar benefits as the microservice approach to. For these implementations are integrated into many mainstream programming languages, they are naturally available to developers to use without increasing complexity and related software development concerns as microservices architectures do. It seems programming concurrency is still unnatural or at least not loved by programmers. The microservice apporach seems to let them better think and plan the separation of concerns inside their software architecture in a divide an conquer way that concurrency primitives of programming languages do.

On this observaton we want to motivate that it seems to be a good idea to integrate the concepts of the service as a principle component into programming languages (like objects) is a good approach. In fact, this is done in some projects already. As the most promising one, we see Jolie. This approach allows developers to write microservice styled programm architectures in a single codebase, while in principle they write software with and actor-based concurrency and distribution approach as we discussed in this thesis.

**Und dann noch weiteren blabla, aber das ist doch schon mal ein guter Ansatz das anzugehen, und den Outlook mit diesem Thema doch drinnen zu haben!**   

~LitNote
* "Programming Services as a new Paradigm"
  * Hier die Vision und die Gründe/Vorteile von einem neuen Paradigma beschreiben
  * Bsp der Datenbank-Services: 
    * Jeder MS sollte seine eigene DB haben. Kann man genau so mit zB Actors oder auch Threads handhaben. Aber beim Deployment gibt es hier Unterschiede. Beim starten eines neuen MS (= Program/Single-Executable-Artefact) ist es leicht auch eine neue DB zu starten (weil auch Programm). Über einen Mechanismus/Tool welches auf dieser konzeptionellen Ebene arbeitet (Programme im OS zu starten, zB Docker) lässt sich dies heute leicht automatisieren. Ein Thread (oder Actor/Active Obj/etc.) steht konzeptionell auf einer anderen Ebene. Es ist ein Konstrukt innerhalb des übergeordnetten Programms. Dh wenn ein neuer Thread erstellt wird ist dies in der Programmiersprache (oder Library/Framework) vorgesehen, aber die DB muss irgendwie extra über eine Interaktion mit dem unterliegenden OS (noch schwieriger in der Cloud, weil nicht umbedingt ein OS sichtbar/ansprechbar ist) gestartet werden. Java zB abstrahiert ja mit der JVM das OS so gut es geht weg (Plattformunabhängigkeit). Natürlich kann man mit dem System schon reden, aber es ist konzeptionell nicht vorgesehen dies als Standardmechanismus ständig zu verwenden. Die Datenbank muss anschließend auch noch irgendwie initialisiert werden, was zB wiederum das Laden eins Init-Scripts erforderlich macht. Dh das Deployment des Threads und das der Datenbank stehen auf konzeptionell unterschiedlichen Ebenen, ihr gemeinsames Deployment ist nicht vorgesehen und somit umständlich/schwierig. Bei MS ist dies konzeptionell auf die selbe Ebene gehoben. 
* in [@Dra17a] wir im Kapitel "Tomorrow" ein weiter Blick in zukünftige Möglichkeiten gegeben:
  * connecting behavioural types and choreographies to well-known logical models
  * a logical reconstruc- tion of behavioural types in classical linear logic that supports parametric polymorphism [83];
  * type theories for integrating higher-order process models with functional computation [79];
  * initial ideas for algorithms for extracting choreographies from separate service programs [18];
  * a logical characterisation of choreography-based behavioural types [19]; 
  * explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13];
  * formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems;
  * these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics;
~

[BIB]

<!-- TODO glossar, nomenclature, index -->

