[INCLUDE=style/marticle]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
<!--Title        : Concurrent Programming Languages and Microservice Architectures-->
Title        : Concurrent Programming
               and the Microservice Architecture Style
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2017
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : alpha
Cite All     : False

Package      : mathptmx

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Tex Header   : 
  \epigraphsize{\small\itshape}
  \setlength\epigraphwidth{8cm}
  \setlength\epigraphrule{0pt}
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { 
  background-color: LightGray;
  padding: 1ex;
}
.Mind {
  background-color: #cbffcb;
  before="[";
  after="]"
}
.Todo { 
  background-color: Aqua; 
  padding: 1ex;
}

@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : webpaginated.css
  Script*       : webpaginated.js
}
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }



~ Begin HtmlOnly
[TITLE]
~ Begin SidePanel
[TOC]
~ End SidePanel
~ End HtmlOnly
<!-- We open an HTML class here, which we'll need to close at the end -->
~ Begin MainPanel

<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->


# Danksagung { -; toc:clear; }

TODO

<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

# Kurzfassung { -; toc:clear; }

# Preface

In 2016, I was reading a thread on HackerNews, and one of the comments cought my eye: 

*Any ideomatic Erlang program is by design a microservices architecture* (link hier als fußnote)

This made me wonder: *Is it really?* And if so, thus would imply that MSA are unnecessary, or that the underlying concurrency model Erlang uses (a concept which we will discuss in this thesis) would be much supreme compared to the models I am used to use.

Having myself a bit of a crush on the Microservice Architecture Style, this did not let go of my grey cells, and I was thinking in the back of my brain that this should be analysed in detail. Having the masters thesis on my Todo list anyway, I was wondering how I cold make this my topic.


~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~

# Introduction

~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

## Methodology used

* the assumptions/theses/laws/etc on MSA presented in chapter "MSA" were identified through thorough literature research

## Road Map

# The Microservice Architecture Style

## Key Concepts

### Architecture Properties

### Architectural Elements

#### API Gateway: The Request Broker and Curcuit Breaker

##### Case Study: Hysterix and Akka

### Quality Issues

#### Software Quality Attributes

##### Performance

###### Case Study: JSON in Service as a Performance factor (siehe [@OBM05] p.15)

### Design Concerns

#### Smart endpoints and dumb pipes (geklaut von M.Fowler)

#### Failure is inevitable

#### Service Granularity: Size vs. Number of Services

#### Satisfaction of local vs. global Quality Properties

#### Polyglot Programming

### Patterns (Kapitel notwendig?)

#### Event-driven architecture

### Development, Debugging and Maintenance

~ Epigraph { caption: "Filipe Fortes" }
Debugging is like being the detective in a crime movie where you're also the murderer.
~

* [DGL17]: microservices implement a limited amount of functionalities, which makes their code base small and inherently limits the scope of a bug.Moreover, since microservices are independent, a developer can directly test and investigate their functionalities in isolation with respect to the rest of the system


# Programming Paradigms: A Selected Overview

## Imperative, Structured and Procedual Programming


## Object-oriented Programming

* Data Abstraction and Modularity

### History of Objects: Simula and Smalltalk

## Functional Programming


## Event-Driven and Flow-Driven Programming

## Logic and Constraint Programming

## Role-based Programming

## Other Programming Paradigms

# Programming Services as a Paradigm 

(aka Commonalities between Programming Paradigms and Microservices)

# Models of Concurrent Computation

## Basic Concepts in Concurrency

### Execution Order and Nondeterminism

* see chapter 14 in "Concepts in Programming Languages" by Mitchell

## Threads, Locks and Shared State

### Case Study: the Java Concurrency Model

## Actors and Active Objects

### Case Study: the Scala Concurrency Model

## Software Transactional Memory

### Case Study: the Clojure Concurrency Model

## Event-driven Concurrency

### Case Study: the JavaScript/node.js Concurrency Model

## Concurrency Models and Distributed Systems Similarities

## Other Approaches and Concurrency Primitives

# The Microservice Programming Paradigm: A Look at Analogies

## Data Abstraction

### Encapsulation

### Information Hiding

## Identity and Equality

* Identity = unique network address (may be abstracted behind gayteway proxy)
* Equality = multiple (stateless) instances of the same service executable 

## SOLID design principles

## Substitution and Behaviour

* Ersetzbarkeit von Services (zB durch neue Version)
  * Wenn Schnittstellen gleich
  * Wenn Verhalten (nach außen) gleich/kompatibel

## Delegation: The Object's Way of Knowledge Sharing

### Case Study: Delegation in JavaScript

## Message Passing: Avoiding Shared State

## Clients Request Services

~LitNote
In [@Sny93] steht zu den *essential concepts* von Objekten u.a. "**Clients request services from objects**". Die folgenden Unterpunkte sind gegeben:

1. Clients issue requests
2. Objects are encapsulated
3. Requests identify operations
4. Requests can identify objects

Diese 4 Punkte kann ich am konkreten Bsp eines MS durchspielen:

1. aufruft eines andere MS mittels REST call: einfach die REST URL angeben
2. Encapsulation ist trivial zu argumentieren: jeder MS eigenes Program
3. Die Operation wird identifiziert durch die REST Methode (PUT, GET, POST, DELETE) und den relativen Pfad (der hinter der Network-Addr.)
4. Die Identification wird über die URL (den Teil mit der Network-Addr) gezeigt

Punkt 2 ist etwas überflüssig, aber kann man ja argumentieren. Punkt 3 und 4 sind besser vertauscht zu zeigen
~

## Event-based View

## Flow-based View   

## The Service as a Process Types

# The Microservice Concurrency Model: A Conceptual View

## Concurrency Models for Service-oriented Programming

## oncurrency based on Message Passing

## Distributed Computation

## Concurrent Process Types for Services

# Scenario-based Experiment

## Scenario

Anforderungen an das Szenario; welche Showcases müssen demonstriert werden können:

* Update von Funktionalität ohne Änderung des Gesamtsystems
  * Deployment einer einzigen neuen MS-Programversion
  * Update durch neuen Untertyp und Deployment mittels Dependency Injection
* Synchronized access to shared data (zB die Fabrikshalle)
  * Datastore MS, der von mehrere MS gleichzeitig benutzt werden kann
  * Actor/ActiveObj/WasAuchImmer, welches die Sync to irgendeinem Datenspeicher übernimmt
* Coarse grained operations on shared "objects" (in active objects), bzw auf services allgemein
  * Kommunikation mit einem Roboter ist wohl ein einfaches Beispiel (via Object oder via Service Kommunikation)
* Kein shared state
  * Alle Actors/ActiveObbj/WasAuchImmer hat eigenen Datenspeicher
  * MS haben eigenen State (und möglicherweise sogar eigene DB)
  * Gemeinsame Datenspeicher via DataStore "pattern" (ist das irgendwie als echtes Pattern festgehalten?)
* reusing, orchestration, aggrgation
  * "every MS can be reused, orchestrated and aggregated with others"
    * reuse: mehrere instanzen des selben MS starten
    * orchestration: ?
    * aggregation: ?
  * passendes gegenstück zu concurrency model/objecten/etc?
    * reuse
    * orchestration
    * aggregation
* Bounded context
  * MS: "Related functionalities are combined into a single business capability; implemented as a service"
  * OOP: __Wie lauten die genauen definitionen, zB aus dem Buch von Meyer??__: 1) sich nur um eine Concern kümmern; 2)
* Size
  * OOP: nicht zu groß, sonst mehrere klassen; für maintainability; OOP generell für extendibility
* Technology heterogeneity
  * in MSA können unterschiedliche MS in unterschiedlichen programmiersprachen geschrieben werden: wäre interessant für implementierung, einen service nicht in Java (zB Scala, Clojure, Ruby, irgendwas anderes) zu schreiben; idealerweise einen der nicht aufwändig ist!
  * nicht machbar in OOP etc


~TODO
Hier beschreibe ich kurz die "Angabe" zu meinen Implementierungen. Es soll durch eine Geschichte motiviert werden
~

In order to base our implementations on a realistic scenario, we motivate the generel setting the implementations could actually be put to their use in a short summary:

~ {font-style: italic; width: 40%; margin: 2ex;}
A long time ago in a galaxy far, far away....

The Republic is crumbling under attacks by the ruthless Sith Lord, Count Dooku. His Separatist Droid Army is produced automatically inside Smart Factories somewhere in the Outer Rim. All production steps are performed by autonomouse droids. This highly concurrent system will lead to the ultimate victory over the Jedi....
~

In this scenario, we simulate the production processes of such a *smart factory*. A variaty of coordination problems therefore have to be handled. The following actors (here, we mean the "droid" actors, not actors as in the actor model) are involved:

* customers (separatist leaders ordering battle-droids)
* management droids
* logistic droids
* assembly droids
* quality-assurance droids
* delivery droids

The following poducts (battle droid models) can be produced inside the smart factory:

~TODO
droids siehe: http://starwars.wikia.com/wiki/Separatist_Droid_Army
~

* B1 battle droid
* B2 super battle droid
* Droideka
* Super tactical droid


We created two prototypical impelementations simulating the descripated *smart factory*. One implementation is written in Erlang using its actor model. The other implementation is written with a microservice architecture, in [**Java ?**] / [**Go ?**]

## Prototype using Standard Models of Concurrency

### Case Study: Why do Java Programmers like MSA?

## Prototype based on a Micorservice Architecture

## Findings

# Discussion

## Comparision of Attributes/Features/etc

## Comparison of the MSA-Concurrency-Model with the others

## Why Developers adopt MSA

## Problems of Developers with Concurrency Models

### Case Study: Why Do Scala Developers Mix the Actor Model with other Concurrency Models?

## Do Sufficiently Concurrent Programming Languages need MSA?

### Jolie

### Distributed Erlang

#### Scalability and Reliability

### Plattform and Middleware-based Approaches

#### XVSM/MozartSpaces

# Outlook

~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

* "Programming Services as a new Paradigm"
  * Hier die Vision und die Gründe/Vorteile von einem neuen Paradigma beschreiben
  * Bsp der Datenbank-Services: 
    * Jeder MS sollte seine eigene DB haben. Kann man genau so mit zB Actors oder auch Threads handhaben. Aber beim Deployment gibt es hier Unterschiede. Beim starten eines neuen MS (= Program/Single-Executable-Artefact) ist es leicht auch eine neue DB zu starten (weil auch Programm). Über einen Mechanismus/Tool welches auf dieser konzeptionellen Ebene arbeitet (Programme im OS zu starten, zB Docker) lässt sich dies heute leicht automatisieren. Ein Thread (oder Actor/Active Obj/etc.) steht konzeptionell auf einer anderen Ebene. Es ist ein Konstrukt innerhalb des übergeordnetten Programms. Dh wenn ein neuer Thread erstellt wird ist dies in der Programmiersprache (oder Library/Framework) vorgesehen, aber die DB muss irgendwie extra über eine Interaktion mit dem unterliegenden OS (noch schwieriger in der Cloud, weil nicht umbedingt ein OS sichtbar/ansprechbar ist) gestartet werden. Java zB abstrahiert ja mit der JVM das OS so gut es geht weg (Plattformunabhängigkeit). Natürlich kann man mit dem System schon reden, aber es ist konzeptionell nicht vorgesehen dies als Standardmechanismus ständig zu verwenden. Die Datenbank muss anschließend auch noch irgendwie initialisiert werden, was zB wiederum das Laden eins Init-Scripts erforderlich macht. Dh das Deployment des Threads und das der Datenbank stehen auf konzeptionell unterschiedlichen Ebenen, ihr gemeinsames Deployment ist nicht vorgesehen und somit umständlich/schwierig. Bei MS ist dies konzeptionell auf die selbe Ebene gehoben. 

# Conclusion

[BIB]

<!-- TODO glossar, nomenclature, index -->

<!-- We need to close the HTML class we opened right at the top -->
~ End MainPanel
