[INCLUDE=style/marticle]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
<!--Title        : Concurrent Programming Languages and Microservice Architectures-->
Title        : Concurrent Programming
               and the Microservice Architecture Style
Subtitle     : Hier könnte Ihre Werbung stehen!
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2018
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : style/keynat.bst
Cite All     : False

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Tex Header   : 
  \epigraphsize{\small\itshape}
  \setlength\epigraphwidth{8cm}
  \setlength\epigraphrule{0pt}
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { 
  background-color: LightGray;
  padding: 1ex;
}
.Mind {
  background-color: #cbffcb;
  before="[";
  after="]"
}
.Todo { 
  background-color: Aqua; 
  padding: 1ex;
}

<!-- TODO brauch ich das hier?
@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : style/webpaginated.css
  Script*       : style/webpaginated.js
}
-->
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  @import url(https://fonts.googleapis.com/css?family=Crimson+Text);
  body.madoko {
    font-family: "Crimson Text", serif;
  }
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }

[TITLE]

<!--
~ HtmlOnly
A PDF Version of this thesis is available at [max.irro.at/pub/thesis/dipl.pdf](http://max.irro.at/pub/thesis/dipl.pdf)
~
-->




<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->


~HtmlOnly
[TOC]
~


<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

In recent time, a new architectural style called *microservice architecture* gain popularity in the scientific community and industrial applications. In this time, applications are composed of small independent and isolated components called *microservices* communicating via lightweigt communication mechanism. This inherent distributed components result in an concurrent nature of the overall application. In this thesis, we explore the interrelations of the microservice architecture style with programming concurrent applications. We argue that the microservice components have much similarity to the actor model, and that many of todays actor implementations are extensions of the theoretical actor model by characteristics shared by the principle ideas behind microservices. It remains to ask if microservice architectures have aspects exalted to those of actor-based software architectures, or else actor-based concurrent could would/should/could have been the answer to the needs that lead to microservices in the first place. 
We test our findings on the implementations of the architecture of a domain specific search engine.

# Kurzfassung { -; toc:clear; }

# Danksagung { -; toc:clear; }

TODO

# Preface / Authors Note { -; toc:clear; }

Back in early 2016, I came across a comment thread discussion[^fn-hackernews] on the famouse "HackerNews" (*news.ycombinator.com*) where someone eventually claimed: "*You'll never hear an Erlang programmer even talk about microservices because they are a solution to a problem that doesn't exist in Erlang, or any sufficiently concurrent language for that matter*". First I thought this was asking for a "`[citation needed]`"[^fn-xkcd], but it was followed by a second statement that instead started to intrigued me:

> "The architecture of an idiomatic Erlang-based system is essentially a microservice architecture."

But is it really? I was wondering. It would have some fundamental implications. Erlang is an interresting language (and we will motivate some of the reasons why), and one of its basic building blocks are what it defines as *processes*. They are Erlangs version of the Actor model for concurrent programming. If the claim that any Erlang system is a microservice architecture, than these processes would mirror the microservices. And the name "process" already motivates why this might be the case. Any microservices most essential property is that it is contained within a single, dedicated (operating-system) process, and these are by nature concurrently executed on the OS level. One thing that I thought was odd though (back then at least), was that Erlangs processes are Actors, and Actors are for concurrency (like threads), while a microservice by its nature is really a component of a distributed system. And if concurrency primitives can meet the concerns a distributed system architecture style can, then why bother with all the hassles that usually come with distributed programming anyway?

Having been passionate about microservice architectures as an alternative to ever growing monoliths for some time back then, this idea would remain in the back of my head and pop up occasionally to think about when there was time to think about such things - like on public transport.  

Over a year later, I've read an article[^fn-qcon] about a presentation given by Joe Duffy, former Director of Engineering for languages and compilers at Microsoft, that stated:

> "Duffy expects to see a return of distributed programming with increasingly fine-grained distributed systems that will make systems look more and more like classic concurrent systems."

Now, these fine grained distributed systems Duffy is speaking about are what we have dubbed microservice architectures at the moment, and based on the previous claim, the "classic concurrent systems" they resemble would look like idiomatic Erlang systems, that is Actor-based concurrent systems in general.

Now, from the first claim and the principles of microservice design, we can argue that microservice architectures qualify for such fine grained distributed systems Duffy is speaking about. And this would mean that the "classic concurrent systems" these distributed systems resemble would look like idiomatic Erlang systems, that is Actor-based concurrent systems in general.

And this, I thought, was worth some further investigation. The results of this investigation is this thesis. May it spark in you the idea that you might not want another microservice architecture for your next project so easily.

Vienna, June 2018

Maximilian Irro

[^fn-hackernews]: https://news.ycombinator.com/item?id=8665690
[^fn-xkcd]: https://xkcd.com/285/
[^fn-qcon]: https://www.infoq.com/news/2017/03/distributed-programming-qcon

~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~


Introduction
============



~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

In this thesis, we will take a close look at two concept, the Actor programming model, and the microservice style, and compare them to each other.

## Methodology used

* the assumptions/theses/laws/etc on MSA presented in chapter "MSA" were identified through thorough literature research

## Road Map



Concurrent Programming
======================

~LitNote
* [@Agh85] describes 3 "foundational issues" of concurrent systems
    * Shared resources
    * Dynamic Reconfiguration
    * Inherent Parallelism
~


## Execution Order and Nondeterminism


## Threads, Locks and Shared State


## Concurrency at the Programming Language Level

~ Note
allgemeines über die Abstraktionen von Nebenläufigkeit, zB Futures, STM, etc
~

## Concurrency at the Operating System Level

~Note
The Process, Inter-process Communication, inherent concurrency
~

## Concurrency at the Network Level



The Actor Model {#ch-actor-model}
===============



~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~

## Basic Actor Idea

## Isolation

every actor owns its state exclusively (should also have unique DB -> bad performance, discuss in Actor-Impl chapter)

## Immutable Message Passing

## Typed Actors/Active Objects

## Combining Actor with other Concurrency Models

### Futures

### Software Transactional Memory (STM)

## OO-Perspective

### Data Abstractions

Encapsulation and Information Hiding

### SOLID design principles

### Design by Contract

### Substitution and Behaviour

### Are Actors (and Active Objects) just Distributed Objects?



The Microservice Paradigm {#ch-microservice-paradigm}
=========================



At the beginning of our current decade, a new architectural term called *Microservice Architecture* emerged. This concept was originally born from the industrial need to break the scalability barrier that monolithic applications inevidently reach [citation needed]{.mind}. Only later the scientific community gained interrest in this paradigm, which lead to an explosion of scientific contributions on this concept. Yet, academia still has some trouble to settle on a common basic definition on the overall concept(s) determining the microservice paradigm. Fowler [@Fow14] gave the first overall review to the microservice concept, and is the original source most scientists refere to. But he focuses on describing the common characteristics from a more practical engineering perspective. [@Dra17a] tried to give a more general, conceptial description, and therefore we will be founding our discussion of this paradigm on the definitions they provide.

Historically, software systems often have always been implemented in a so-called *monolithic* setup, where all the source code is compiled into one single artifact that can be executed on a machine. This is based on the level of abstraction mainstream programming languages provide to break down complexity of the programming task: *modules*. They allow to logically separate concerns ["of ???" - diesen Teil kann ich sicher etwas ausschmücken und auf B. Meyer verweisen]{.mind}, yet the transformation from the abstraction of program code to machine code leads to a result where the different module components are merged into one unified construct: the (monilithic) *executable*. [@Dra17a] defines:

~ Definition {#def-monolith; caption: "Monolith"}
A monolith is a software application whose modules cannot be executed independently.
~   

* Microservice
 : A microservice is a cohesive, independent process interacting via messages      

## Microservice Principles

~ Epigraph { caption: "Groucho Marx"}
These are my principles. If you don't like them, I have others.
~

No shared state, etc

## Communication Channels

Point to Point, Publish/Subscribe, Open/well-defined Communication Interface

## Service Granularity: Size vs. Number of Services

"micro should refere to the scope of responsibility, not the lines of code"

## Polyglot Programming

## OO-Perspective

### Are MS just Distributed Objects (done right)?



Commonalities of Actors and Microservices
=====================



~ Epigraph { caption: "Pamela Zave"}
The purpose of software engineering is to control complexity, not to create it.
~

~LitNote
* Diskussion: MS behandeln ebenfalls die 3 "foundational issues" die laut [@Agh85] concurrency modelle lösen sollten
* Weiters zitiert [@Agh85]: "It is reasonable to expect that large-scale parallel systems will be composed of independently developed and maintained modules. Such systems will be open-ended and continually undergoing change (Hewitt and de Jong 85)."
    * und "Actor languages are intended to provide linguistic support for such open systems" -> dh Actor werden als sprachfeature für das verwendet werden, was MS im prinzip sind.
~

## Isolation and autonomy

"promise behaviour via API/protocol" --> design by contract

## Communication and Data Coupling

Sync vs Async, Immutable Messages


## Internal and external Component Concurrency

~LitNote
Hier möchte ich einen gewissen Gedanken diskutieren, aber habe keine gute Idee in welchem Kontext (Überschrift bzw einordnung in einem anderen Kapitel) ich das am besten tun sollte. Somit ist es erstmals hier.
~

In chapter [#ch-actor-model] we discussed the actor model explicitely as a *concurrency model*. Yet this claim is worth debating. In the basic semantic of an actor we discussed, there is no notion of concurrency at all. It is a strictly linear component, that follows a clear, non-concurrent execution schema [hier sollte ich etwas zitieren, und den pseudocode von jemand anderen heranziehen]{.mind}:

```
WHILE TRUE:
    GET next message from mailbox
    process message
    repeat 
```

Nothing wihin an actor expects a concurrent access to its state, or [??? irgendwas zweites]{.mind}. An actor itself is a non-concurrent entity. Therefore, the actor model is sometimes refered to as simply a *programming model* [citation needed]{.mind}, an approach to writing software components. The most basic case is a single actor. It only knows about itself, therefore can only receive messages from itself, process them, and send messages to itself. The semantic of this behaviour is a simple loop, where no state information leaves the scope of the actor. It results in a simple, single threaded program. 

The title of chapter [#ch-actor-model] features a famouse quote of Carl Hewitt: "*One actor is no actor. Actors come in systems*". The overall idea of - and driving reason to use - the actor programming model is to have more than one actor in place. The models semantic allows to send messages freely between actors within a system. While each actor itself is a non-concurrent entity, this exchange of (immutable) messages semantically allows actors to be executed in a concurrent fashion by the system. 

Actors by themselfs are not concurrent, but their semantic allows them to be executed within a system in a concurrent manner. If the actor semantic is preserved at all time - how this has to be done and if it can be guaranteed is up to the actually used actor system implementation - then an actor does not have to have any awareness of any concurrent processing at all [citation needed]{.mind}. Of course, this does not mean that actor systems are free from the concurrent problems that are introduced by any form of indeterminism, respectivly by message passing.   

A microservice on the other hand can also be considered a concurrent component within a system, as we discussed either on the operating system level or the network level (or both). Yet it's notion of concurrency is divergent from that of an actor. Though it also received message of some kind via its public API, and reacts to them, the flexibility in the design of microservices allows to create services that react to multiple messages concurrently. They can have internal notion of concurrent processing. This allows a service to make a synchronouse call (and blocking wait for an answer within the routines code), without blocking as a whole. A microservice therefore can behave as a concurrently accessible resource within the system. The drawback of this degree of freedom is the set of issues any concurrent resource access inherently has. A basic example is locking. When an actor processes a message, it is guaranteed to have unqiue access to its internal state, therefore must no handle any locking and may savely assume its state as up to date. When a microservice accesses any kind of internal resource (state), this resource might currently be locked by an internal transaction mechanism, granting read access, but not guaranteeing that the state is actually up to date. [dirty read? irgendwas allgemeines zu locking und read zitieren]{.mind} 

Programming with microservices does not, unlike actors, free one from the many hassles of internal component concurrency problems per se. Depending on the model used, the pains of threads, locks, transactions, coroutines, etc. are still to be dealt with. But the services size - based on its scope of responsibility - is limiting the complexity of the services internal concurrency considerations relative to the overall systems [citation needed? hab ich da eine? ist ja eigentlich mein eigener beitrag]{.mind}. 

## Persistance

Polyglot Persistance, Event/Command Sourcing (??? brauche ich das? - vll für mehrere parallele Stores, wenn einer nachträglich online geht)

## Fault tolerance

"failure isolation"

## Resilience

"ability to heal from failure" - break free from strong coupling of synchron comm.; circuit breakers

## Scalability

## Load balancing
Server and Client Side LB

## Elasticity / Code Mobility

Location transparency, elasticity = "move around in isolation"

## Availability

* Actors, siehe: [@Agh85]

## Extensibility

* Actors, siehe: [@Agh85]



A Concurrent, Parallel and Distributed Problem Scenario
=======================================================



## Domain Description

Podcasts = Decentralized media syndication

## Components

## Information Flow

## Concurrent Tasks

Fetching data (feeds/websites), parsing data (feeds,websites), registering new entities (podcast/feeds, episodes), extending stores directory/index, serving search requests

## Scalability Opportunities

### Scalability through ??? (scaling up = changing allocated resources: memory, CPU)

### Scalability through Parallelization and Distribution (scaling out)

## Elasticity Considerations

## Polyglot Persistence (based on Isolation)



An Actor-based Problem Solution
===============================



When using the actor model in practice, it is important define which model is used. There is not *the* actor model, there is only the theoretical concept of the basic  

## Isolation

State + Behaviour

## Synchronous and Asynchronous Communication

Channel types (point-to-point, pub/sub), specialized channels (dead letters, guaranteed delivery --> siehe "Akka in Action"); easy to get pub/sub or MQ routing behaviour via Routers (mostly same Actor as Supervisor); why not use JMS (it would offer both MQ/PubSub behaviour, but is not open and not lightweight)

## Data Coupling

Messages are always "state at a specific point in time", but when the receiver gets it, it might already be outdated --> just live with it, no ACID; messages are transported via Actor System (e.g. Akka) and therefore data is coupled via the access to the API (e.g. only Scala/Java and compatible languages  - Groovy - may join the system); avoid any pattern that needs to wait for consensus between actors -> they should be able to make progress individually (vgl RegisterEpisodeIfNew, hier könnte auch der parser beim catalog nachfragen); message immutability (den ganzen aufwand den ich getrieben habe um die DTOs immutable zu kriegen, denn Akka macht pass by reference wen die nachricht innerhalb der selben JVM zugestellt wird --> und das macht probleme)

## Persistence

Database (Postgres/Lucene) owning based on isolation, Subactor Handlers for DB access: many workers for one "logical" store because the backend data stores (DB, search index) can handle multiple connections --> breaking the "own your state exclusively paradigm"; Polyglot Persistance

## Load balancing

Mailbox, Dispatcher, Command-query separation for stores (CQS, siehe wikipedia, definiert von Bertrand Meyer; create/update/delete = command messages need to be sent to all stores, read = query messages need only to be sent to one store --> **das hier vll eher ein Thema zu Event sourcing?**); Router and Routing Logic (Broker, RoundRobin)

## Fault Tolerance

Supervision and Error Kernel

## Resilience

## Scalability

## Elasticity / Code Mobility

Cluster / Remoting of Akka, built in discovery system among nodes  

## Deployment

Mostly of no concern, bit of configutation for cluster setup (seed nodes for peer to peer discovery), cluster singleton and cluster sharding for complex deployment setups

## Availability

* siehe: [@Agh85]

## Extensibility

* iehe: [@Agh85]

## Configuration, logging, etc

## Performance measurement of Actors



A Microservice-based Problem Solution
=====================================



## Isolation

State + Behaviour, Database (Postgres/Lucene) owning, Spring Thread Pool for DB access

## Synchronous and Asynchronous Communication

REST and other lightweight stuff, async kafka (but offers only pub/sub), the case for AMQP/RabbitMQ for async jobs (leightweight, open protocol = polyglot, not like JMS) --> use PubSub/Kafka for DataStores (all stores need to update the data records) and MQ/AMQP for Workers (each job needs to be done by one worker)

## Data Coupling

No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
        
## Persistence

One DB per MS

## Load balancing    

to be done manually in API gateway, or via MQ 

## Cluster / Remoting

Was kann ich hier **allgemein** dazu sagen?; Entkopplung von fixen Adressen (Location Transparency)

## Fault Tolerance

Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 

## Resilience

## Scalability

## Elasticity / Code Mobility

requires Discovery mechanism of clients, Consol (alternativ ZooKeeper, Eureka, etc) 

## Deployment

depending on specific need, some sort of cloud management framework (or a combination of more) is required. multiple instances easy with container technology (e.g. Docker), but no guarantee for singleton usage

## Availability



## Extensibility

* [@Mon16a]: "New versions of components can be gradually intro- duced in a system, by deploying them side to side with previous versions. This advantage can be incorporated in Continuous Integration"

## Configuration, logging, etc

## Performance measurement of Microservices



Evaluation
==========



## Software Quality Attributes

SOA qual. attr.

* Performance
* Scalability
* Availability
* Modifiability
* Development distributability (???)
* Deployability
* Portability (Mobility?)

## Quality Metrics

### Internal Quality Metrics

Coupling metrics, cohesion metrics, granularity metrics, complexity metrics, autonomy metrics, reusability metrics

### External Quality Metrics

## Performance Measurement



Discussion
=====================



## The Case for Actors

### Case Study: Why do Scala Programmers mix Actors with other Concurrency Constructs?

## The Case for Microservices

## Empirical Indications

  Es zeigt sich, dass MS Projekte eine hohe Chance haben zu funktionieren, wenn ein bestehender Monolith in eine MSA refactorisiert wird, hingegen hohe Chance zu scheitern, wenn sie von Anfang an als MSA geplant sind (--> zeigt sich auch in meiner Suchmaschine, viel viel viel Aufwändiger und komplexer, "added complexity"); Actor systeme hingegen müssen explorativ schritt für schritt erweitert werden (dafür gibt es ein fach-konzept, wo man kleine evolutionen durchführt), daher eignen sich Actors gut um ein neues Projekt damit zu beginnen, allerdings werden sie nur schwer in einen großen bestehenden Monolithen eingebaut werden können, und so einer schon gar nicht in ein Actor-System refaktorisiert werden (hier brauche ich Literatur dazu!)



Outlook & Conclusion
=======



~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

~Note
Services as First-Class Citizens
~

In this thesis, we discussed the new microservices style and quite old principles of concurrent and distributed programming as if they were two competing approaches, and one will eventually emerge victorios. In this chapter, we want to argue that instead of a rivalry, both approaches should instead be combined to define a new style of programming. 
One the one hand, we analyzed microservices for their core concepts and found that their natural characteristics implied a high form of isolation. Combined with an asynchronouse communication mechanism, they become highly decoupled and the resulting architecture enjoys the principles of Actor based concurrency combined with the feature of distribution and mobility that agent based systems defined long ago. Yet programming a microservice architecture results in a significant overhead in terms of complexity, maintainability, etc. 
On the other hand, we discussed the classic concurrency models of actors, and found that if it gets extended by additional concepts, such as it is done in existing implementations today, the resulting artifacts yield similar benefits as the microservice approach to. For these implementations are integrated into many mainstream programming languages, they are naturally available to developers to use without increasing complexity and related software development concerns as microservices architectures do. It seems programming concurrency is still unnatural or at least not loved by programmers. The microservice apporach seems to let them better think and plan the separation of concerns inside their software architecture in a divide an conquer way that concurrency primitives of programming languages do.

On this observaton we want to motivate that it seems to be a good idea to integrate the concepts of the service as a principle component into programming languages (like objects) is a good approach. In fact, this is done in some projects already. As the most promising one, we see Jolie. This approach allows developers to write microservice styled programm architectures in a single codebase, while in principle they write software with and actor-based concurrency and distribution approach as we discussed in this thesis.

**Und dann noch weiteren blabla, aber das ist doch schon mal ein guter Ansatz das anzugehen, und den Outlook mit diesem Thema doch drinnen zu haben!**   

* "Programming Services as a new Paradigm"
  * Hier die Vision und die Gründe/Vorteile von einem neuen Paradigma beschreiben
  * Bsp der Datenbank-Services: 
    * Jeder MS sollte seine eigene DB haben. Kann man genau so mit zB Actors oder auch Threads handhaben. Aber beim Deployment gibt es hier Unterschiede. Beim starten eines neuen MS (= Program/Single-Executable-Artefact) ist es leicht auch eine neue DB zu starten (weil auch Programm). Über einen Mechanismus/Tool welches auf dieser konzeptionellen Ebene arbeitet (Programme im OS zu starten, zB Docker) lässt sich dies heute leicht automatisieren. Ein Thread (oder Actor/Active Obj/etc.) steht konzeptionell auf einer anderen Ebene. Es ist ein Konstrukt innerhalb des übergeordnetten Programms. Dh wenn ein neuer Thread erstellt wird ist dies in der Programmiersprache (oder Library/Framework) vorgesehen, aber die DB muss irgendwie extra über eine Interaktion mit dem unterliegenden OS (noch schwieriger in der Cloud, weil nicht umbedingt ein OS sichtbar/ansprechbar ist) gestartet werden. Java zB abstrahiert ja mit der JVM das OS so gut es geht weg (Plattformunabhängigkeit). Natürlich kann man mit dem System schon reden, aber es ist konzeptionell nicht vorgesehen dies als Standardmechanismus ständig zu verwenden. Die Datenbank muss anschließend auch noch irgendwie initialisiert werden, was zB wiederum das Laden eins Init-Scripts erforderlich macht. Dh das Deployment des Threads und das der Datenbank stehen auf konzeptionell unterschiedlichen Ebenen, ihr gemeinsames Deployment ist nicht vorgesehen und somit umständlich/schwierig. Bei MS ist dies konzeptionell auf die selbe Ebene gehoben. 
* in [@Dra17a] wir im Kapitel "Tomorrow" ein weiter Blick in zukünftige Möglichkeiten gegeben:
  * connecting behavioural types and choreographies to well-known logical models
  * a logical reconstruc- tion of behavioural types in classical linear logic that supports parametric polymorphism [83];
  * type theories for integrating higher-order process models with functional computation [79];
  * initial ideas for algorithms for extracting choreographies from separate service programs [18];
  * a logical characterisation of choreography-based behavioural types [19]; 
  * explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13];
  * formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems;
  * these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics;
  

[BIB]

<!-- TODO glossar, nomenclature, index -->

