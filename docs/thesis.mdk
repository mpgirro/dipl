[INCLUDE=style/marticle]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
<!--Title        : Concurrent Programming Languages and Microservice Architectures-->
Title        : Concurrent Programming
               and the Microservice Architecture Style
Subtitle     : Approaches to Parallel, Scalable, Distributed, Fault Tolerance Software Systems demonstrated on a Domain Specific Search Engine
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2017
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : style/keynat.bst
Cite All     : False

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Tex Header   : 
  \epigraphsize{\small\itshape}
  \setlength\epigraphwidth{8cm}
  \setlength\epigraphrule{0pt}
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { 
  background-color: LightGray;
  padding: 1ex;
}
.Mind {
  background-color: #cbffcb;
  before="[";
  after="]"
}
.Todo { 
  background-color: Aqua; 
  padding: 1ex;
}

<!-- TODO brauch ich das hier?
@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : style/webpaginated.css
  Script*       : style/webpaginated.js
}
-->
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  @import url(https://fonts.googleapis.com/css?family=Crimson+Text);
  body.madoko {
    font-family: "Crimson Text", serif;
  }
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }

[TITLE]

<!--
~ HtmlOnly
A PDF Version of this thesis is available at [max.irro.at/pub/thesis/dipl.pdf](http://max.irro.at/pub/thesis/dipl.pdf)
~
-->

[TOC]


<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->





# Danksagung { -; toc:clear; }

TODO

<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

In recent time, a new architectural style called *microservice architecture* gain popularity in the scientific community and industrial applications. In this time, applications are composed of small independent and isolated components called *microservices* communicating via lightweigt communication mechanism. This inherent distributed components result in an concurrent nature of the overall application. In this thesis, we explore the interrelations of the microservice architecture style with programming concurrent applications. We argue that the microservice components have much similarity to the actor model, and that many of todays actor implementations are extensions of the theoretical actor model by characteristics shared by the principle ideas behind microservices. It remains to ask if microservice architectures have aspects exalted to those of actor-based software architectures, or else actor-based concurrent could would/should/could have been the answer to the needs that lead to microservices in the first place. 
We test our findings on the implementations of the architecture of a domain specific search engine.

# Kurzfassung { -; toc:clear; }

# Preface / Authors Note { -; toc:clear; }

Back in early 2016, I came across a comment thread discussion[^fn-hackernews] on the famouse "HackerNews" (*news.ycombinator.com*) where someone eventually claimed: "*You'll never hear an Erlang programmer even talk about microservices because they are a solution to a problem that doesn't exist in Erlang, or any sufficiently concurrent language for that matter*". First I thought this was asking for a "`[citation needed]`"[^fn-xkcd], but it was followed by a second statement that instead started to intrigued me:

> "The architecture of an idiomatic Erlang-based system is essentially a microservice architecture."

But is it really? I was wondering. It would have some fundamental implications. Erlang is an interresting language (and we will motivate some of the reasons why), and one of its basic building blocks are what it defines as *processes*. They are Erlangs version of the Actor model for concurrent programming. If the claim that any Erlang system is a microservice architecture, than these processes would mirror the microservices. And the name "process" already motivates why this might be the case. Any microservices most essential property is that it is contained within a single, dedicated (operating-system) process, and these are by nature concurrently executed on the OS level. One thing that I thought was odd though (back then at least), was that Erlangs processes are Actors, and Actors are for concurrency (like threads), while a microservice by its nature is really a component of a distributed system. And if concurrency primitives can meet the concerns a distributed system architecture style can, then why bother with all the hassles that usually come with distributed programming anyway?

Having been passionate about microservice architectures as an alternative to ever growing monoliths for some time back then, this idea would remain in the back of my head and pop up occasionally to think about when there was time to think about such things - like on public transport.  

Over a year later, I've read an article[^fn-qcon] about a presentation given by Joe Duffy, former Director of Engineering for languages and compilers at Microsoft, that stated:

> "Duffy expects to see a return of distributed programming with increasingly fine-grained distributed systems that will make systems look more and more like classic concurrent systems."

Now, these fine grained distributed systems Duffy is speaking about are what we have dubbed microservice architectures at the moment, and based on the previous claim, the "classic concurrent systems" they resemble would look like idiomatic Erlang systems, that is Actor-based concurrent systems in general.

Now, from the first claim and the principles of microservice design, we can argue that microservice architectures qualify for such fine grained distributed systems Duffy is speaking about. And this would mean that the "classic concurrent systems" these distributed systems resemble would look like idiomatic Erlang systems, that is Actor-based concurrent systems in general.

And this, I thought, was worth some further investigation. The results of this investigation is this thesis. 

Vienna, June 2018

Maximilian Irro

[^fn-hackernews]: https://news.ycombinator.com/item?id=8665690
[^fn-xkcd]: https://xkcd.com/285/
[^fn-qcon]: https://www.infoq.com/news/2017/03/distributed-programming-qcon

~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~



Introduction
============



~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

## Methodology used

* the assumptions/theses/laws/etc on MSA presented in chapter "MSA" were identified through thorough literature research

## Road Map



Programming Paradigms
=====================



## Imperative, Structured and Procedual Programming


## Object-oriented Programming

* Data Abstraction and Modularity

### History of Objects: Simula and Smalltalk

## Functional Programming


## Event-Driven and Flow-Driven Programming

## Logic and Constraint Programming

## Role-based Programming

## Other Programming Paradigms



Models of Concurrent Computation
================================



## Basic Concepts in Concurrency

### Execution Order and Nondeterminism

* see chapter 14 in "Concepts in Programming Languages" by Mitchell

### Concurrency at the Programming Language Level

Channel, Coroutine, Futures and promises

### Concurrency at the Operating System Level

Computer multitasking, Process, Thread

### Concurrency at the Network Level

laut wikipedia: "networked systems are generally concurrent by their nature, as they consist of separate devices"

## Threads, Locks and Shared State

### Case Study: the Java Concurrency Model

## Actors and Active Objects

### Case Study: the Scala Concurrency Model

## Software Transactional Memory

### Case Study: the Clojure Concurrency Model

## Event-driven Concurrency

### Case Study: the JavaScript/node.js Concurrency Model

## Parallel Architecture

~LitNote
* siehe [@But14] zu den 4 Teilen:
  * Bit-Level Parallelism
  * Instruction-Level Parallelism
  * Data Parallelism
  * Task_level Parallelism (das ist das für mich wichtige)
    * hier wird zwischen Shared-memory und Distributed-memory unterschieden, mit guter Erklärung
~

### Inter-process Communication

~LitNote
* [@But14]
  * shared-memory: inter-process comm. through memory (faster)
  * distributed memory: each own local memory, inter-process comm. through network (slow, latency, all network errors)
    * hier passen die "Fallaties of distributed systems" gut rein! siehe [@RGO06]
~

## Concurrency Models and Distributed Systems Similarities

## Other Approaches and Concurrency Primitives



The Microservice Architecture Style
===================================



## Service-oriented Systems

## Key Concepts

## Architecture Properties

### Geographically Distributed Code: Concurrency Beyond Multiple Cores

~LitNote
* seet [@But14] was "geographically distributed code" bedeutet (im zusammenhang eines concurrency models); MSA haben dies wieder einmal inherent
~

### Resilience

## Architectural Elements

### Communication Channel ()

mostly HTTP

### Database per Service

### API Gateway: Request Broker and Curcuit Breaker

#### Case Study: Hysterix and Akka

## Quality Issues

### Software Quality Attributes

#### Performance

##### Case Study: JSON in Service as a Performance factor (siehe [@OBr05] p.15)

## Design Concerns

### Smart endpoints and dumb pipes (geklaut von M.Fowler)

### Failure is inevitable

### Service Granularity: Size vs. Number of Services

### Satisfaction of local vs. global Quality Properties

### Polyglot Programming

## Patterns (Kapitel notwendig?)

### Event-driven architecture

## Development, Testing, Debugging and Maintenance

~ Epigraph { caption: "Filipe Fortes" }
Debugging is like being the detective in a crime movie where you're also the murderer.
~

* [@Dra17a]: microservices implement a limited amount of functionalities, which makes their code base small and inherently limits the scope of a bug.Moreover, since microservices are independent, a developer can directly test and investigate their functionalities in isolation with respect to the rest of the system

* Service Component Test http://microservices.io/patterns/testing/service-component-test.html
* Service Integration Contract Test http://microservices.io/patterns/testing/service-integration-contract-test.html


Towards a (Micro)service-Oriented Paradigm: A Look at Analogies
======================================================



## Data Abstraction

### Encapsulation

### Information Hiding

## Identity and Equality

* Identity = unique network address (may be abstracted behind gayteway proxy)
* Equality = multiple (stateless) instances of the same service executable 

## SOLID design principles

## Design by Contract and REST

~LitNote
bzgl REST:

* see [Mon16b], section 7, "RESTful services"
~

### REpresentational State Transfer 

### Pre- and Postconditions

### Invariants and History-constraints

## Substitution and Behaviour

* Ersetzbarkeit von Services (zB durch neue Version)
  * Wenn Schnittstellen gleich
  * Wenn Verhalten (nach außen) gleich/kompatibel

## Delegation: Delegation: Sharing partial implementation

~LitNote
* see [@Sny93] "Essense of Objects"
~

### Case Study: Delegation in JavaScript

## Message Passing: Avoiding Shared State

## Clients Request Services

~LitNote
In [@Sny93] steht zu den *essential concepts* von Objekten u.a. "**Clients request services from objects**". Die folgenden Unterpunkte sind gegeben:

1. Clients issue requests
2. Objects are encapsulated
3. Requests identify operations
4. Requests can identify objects

Diese 4 Punkte kann ich am konkreten Bsp eines MS durchspielen:

1. aufruft eines andere MS mittels REST call: einfach die REST URL angeben
2. Encapsulation ist trivial zu argumentieren: jeder MS eigenes Program
3. Die Operation wird identifiziert durch die REST Methode (PUT, GET, POST, DELETE) und den relativen Pfad (der hinter der Network-Addr.)
4. Die Identification wird über die URL (den Teil mit der Network-Addr) gezeigt

Punkt 2 ist etwas überflüssig, aber kann man ja argumentieren. Punkt 3 und 4 sind besser vertauscht zu zeigen
~

## Event-based View

## Flow-based View   

## Process-, Behavioural-, and Session-Types

~LitNote
* "Behavioural types are types that can describe the behaviour of services and can be used to
check that two (or more) services have compatible actions" [@Dra17a]
* "Session types are a prime example of behavioural types" [@Dra17a]
* "Session types have been successfully applied to many contexts already, ranging from parallel to distributed computing." [@Dra17a]

zu Session Types: 

* see "*Kohei Honda, Vasco Vasconcelos, and Makoto Kubo. Language primitives and type disciplines for structured communication-based programming. pages 22–138, 1998*"
* see "*Kohei Honda, Nobuko Yoshida, and Marco Carbone. Multiparty asynchronous session types. Journal of the ACM,63(1):9, 2016. Also: POPL, 2008, pages 273–284*"
~

## Choreographies

~LitNote
* "Choreographies are high-level descriptions of the communications that we want to happen in a system in contrast with the typical methodology of defining the behaviour of each service separately" [@Dra17a]
* see [@Mon13] "*Choreographic Programming*"
~



The Microservice Concurrency Model
==================================



## Immutable Messages

### Asynchronouse Dataflow with Synchronous Messages

## Message Processing and Transactional Memory

jeder REST request (der von einem DB state abhängt) wird mit STM gekennzeichnet (zB `@Transactional` in Java)

## Applicability for Concurrent Problems

## Applicability for Parallel Problems

## Resilient Code

## Geographically Distributed Code

## Distributed Computation

## Concurrent Process Types for Services



Scenario-based Experiment
=========================



## Scenario

Anforderungen an das Szenario; welche Showcases müssen demonstriert werden können:

* Update von Funktionalität ohne Änderung des Gesamtsystems
  * Deployment einer einzigen neuen MS-Programversion
  * Update durch neuen Untertyp und Deployment mittels Dependency Injection
* Synchronized access to shared data (zB die Fabrikshalle)
  * Datastore MS, der von mehrere MS gleichzeitig benutzt werden kann
  * Actor/ActiveObj/WasAuchImmer, welches die Sync to irgendeinem Datenspeicher übernimmt
* Coarse grained operations on shared "objects" (in active objects), bzw auf services allgemein
  * Kommunikation mit einem Roboter ist wohl ein einfaches Beispiel (via Object oder via Service Kommunikation)
* Kein shared state
  * Alle Actors/ActiveObbj/WasAuchImmer hat eigenen Datenspeicher
  * MS haben eigenen State (und möglicherweise sogar eigene DB)
  * Gemeinsame Datenspeicher via DataStore "pattern" (ist das irgendwie als echtes Pattern festgehalten?)
* reusing, orchestration, aggrgation
  * "every MS can be reused, orchestrated and aggregated with others"
    * reuse: mehrere instanzen des selben MS starten
    * orchestration: ?
    * aggregation: ?
  * passendes gegenstück zu concurrency model/objecten/etc?
    * reuse
    * orchestration
    * aggregation
* Bounded context
  * MS: "Related functionalities are combined into a single business capability; implemented as a service"
  * OOP: __Wie lauten die genauen definitionen, zB aus dem Buch von Meyer??__: 1) sich nur um eine Concern kümmern; 2)
* Size
  * OOP: nicht zu groß, sonst mehrere klassen; für maintainability; OOP generell für extendibility
* Technology heterogeneity
  * in MSA können unterschiedliche MS in unterschiedlichen programmiersprachen geschrieben werden: wäre interessant für implementierung, einen service nicht in Java (zB Scala, Clojure, Ruby, irgendwas anderes) zu schreiben; idealerweise einen der nicht aufwändig ist!
  * nicht machbar in OOP etc


~TODO
Hier beschreibe ich kurz die "Angabe" zu meinen Implementierungen. Es soll durch eine Geschichte motiviert werden
~

In order to base our implementations on a realistic scenario, we motivate the generel setting the implementations could actually be put to their use in a short summary:

~ {font-style: italic; width: 40%; margin: 2ex;}
A long time ago in a galaxy far, far away....

The Republic is crumbling under attacks by the ruthless Sith Lord, Count Dooku. His Separatist Droid Army is produced automatically inside Smart Factories somewhere in the Outer Rim. All production steps are performed by autonomouse droids. This highly concurrent system will lead to the ultimate victory over the Jedi....
~

In this scenario, we simulate the production processes of such a *smart factory*. A variaty of coordination problems therefore have to be handled. The following actors (here, we mean the "droid" actors, not actors as in the actor model) are involved:

* customers (separatist leaders ordering battle-droids)
* management droids
* logistic droids
* assembly droids
* quality-assurance droids
* delivery droids

The following poducts (battle droid models) can be produced inside the smart factory:

~TODO
droids siehe: http://starwars.wikia.com/wiki/Separatist_Droid_Army
~

* B1 battle droid
* B2 super battle droid
* Droideka
* Super tactical droid


We created two prototypical impelementations simulating the descripated *smart factory*. One implementation is written in Erlang using its actor model. The other implementation is written with a microservice architecture, in [**Java ?**] / [**Go ?**]

## Prototype using Standard Models of Concurrency

### Case Study: Why do Java Programmers like MSA?

## Prototype based on a Micorservice Architecture

## Findings



Discussion
==========



## Comparision of Attributes/Features/etc

## Comparison of the MSA-Concurrency-Model with the others

## Why Developers adopt MSA

## Problems of Developers with Concurrency Models

### Case Study: Why Do Scala Developers Mix the Actor Model with other Concurrency Models?

## Do Sufficiently Concurrent Programming Languages need MSA?

### Jolie

~LitNote
* Jolie "natively" supports decorator pattern
  * see https://www.reddit.com/r/programming/comments/5hrxh5/jolie_natively_supports_decorator_pattern_maybe/
  * see http://fmontesi.github.io/2016/11/12/service-decorators.html
~

### Distributed Erlang

#### Scalability and Reliability

### Plattform and Middleware-based Approaches

#### Virtual Machines

~ LitNote
* see [@Xu16] zu CAOPLE and VMs
~

#### XVSM/MozartSpaces



Outlook
=======



~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

In this thesis, we discussed the new microservices style and quite old principles of concurrent and distributed programming as if they were two competing approaches, and one will eventually emerge victorios. In this chapter, we want to argue that instead of a rivalry, both approaches should instead be combined to define a new style of programming. 
One the one hand, we analyzed microservices for their core concepts and found that their natural characteristics implied a high form of isolation. Combined with an asynchronouse communication mechanism, they become highly decoupled and the resulting architecture enjoys the principles of Actor based concurrency combined with the feature of distribution and mobility that agent based systems defined long ago. Yet programming a microservice architecture results in a significant overhead in terms of complexity, maintainability, etc. 
On the other hand, we discussed the classic concurrency models of actors, and found that if it gets extended by additional concepts, such as it is done in existing implementations today, the resulting artifacts yield similar benefits as the microservice approach to. For these implementations are integrated into many mainstream programming languages, they are naturally available to developers to use without increasing complexity and related software development concerns as microservices architectures do. It seems programming concurrency is still unnatural or at least not loved by programmers. The microservice apporach seems to let them better think and plan the separation of concerns inside their software architecture in a divide an conquer way that concurrency primitives of programming languages do.

On this observaton we want to motivate that it seems to be a good idea to integrate the concepts of the service as a principle component into programming languages (like objects) is a good approach. In fact, this is done in some projects already. As the most promising one, we see Jolie. This approach allows developers to write microservice styled programm architectures in a single codebase, while in principle they write software with and actor-based concurrency and distribution approach as we discussed in this thesis.

**Und dann noch weiteren blabla, aber das ist doch schon mal ein guter Ansatz das anzugehen, und den Outlook mit diesem Thema doch drinnen zu haben!**   

* "Programming Services as a new Paradigm"
  * Hier die Vision und die Gründe/Vorteile von einem neuen Paradigma beschreiben
  * Bsp der Datenbank-Services: 
    * Jeder MS sollte seine eigene DB haben. Kann man genau so mit zB Actors oder auch Threads handhaben. Aber beim Deployment gibt es hier Unterschiede. Beim starten eines neuen MS (= Program/Single-Executable-Artefact) ist es leicht auch eine neue DB zu starten (weil auch Programm). Über einen Mechanismus/Tool welches auf dieser konzeptionellen Ebene arbeitet (Programme im OS zu starten, zB Docker) lässt sich dies heute leicht automatisieren. Ein Thread (oder Actor/Active Obj/etc.) steht konzeptionell auf einer anderen Ebene. Es ist ein Konstrukt innerhalb des übergeordnetten Programms. Dh wenn ein neuer Thread erstellt wird ist dies in der Programmiersprache (oder Library/Framework) vorgesehen, aber die DB muss irgendwie extra über eine Interaktion mit dem unterliegenden OS (noch schwieriger in der Cloud, weil nicht umbedingt ein OS sichtbar/ansprechbar ist) gestartet werden. Java zB abstrahiert ja mit der JVM das OS so gut es geht weg (Plattformunabhängigkeit). Natürlich kann man mit dem System schon reden, aber es ist konzeptionell nicht vorgesehen dies als Standardmechanismus ständig zu verwenden. Die Datenbank muss anschließend auch noch irgendwie initialisiert werden, was zB wiederum das Laden eins Init-Scripts erforderlich macht. Dh das Deployment des Threads und das der Datenbank stehen auf konzeptionell unterschiedlichen Ebenen, ihr gemeinsames Deployment ist nicht vorgesehen und somit umständlich/schwierig. Bei MS ist dies konzeptionell auf die selbe Ebene gehoben. 
* in [@Dra17a] wir im Kapitel "Tomorrow" ein weiter Blick in zukünftige Möglichkeiten gegeben:
  * connecting behavioural types and choreographies to well-known logical models
  * a logical reconstruc- tion of behavioural types in classical linear logic that supports parametric polymorphism [83];
  * type theories for integrating higher-order process models with functional computation [79];
  * initial ideas for algorithms for extracting choreographies from separate service programs [18];
  * a logical characterisation of choreography-based behavioural types [19]; 
  * explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13];
  * formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems;
  * these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics;
  

Conclusion
==========

[BIB]

<!-- TODO glossar, nomenclature, index -->

