[INCLUDE=style/marticle]

<!--
Title        : A crack in the monolith
Subtitle     : Do suffciently concurrent programming languages need microservice architectures?
-->
<!--Title        : Concurrent Programming Languages and Microservice Architectures-->
Title        : Concurrent Programming
               and the Microservice Architecture Style
Author       : Maximilian Irro
Email        : max@irro.at
Copyright    : Maximilian Irro, 2017
Title Footer : 2017
<!-- TODO delete with new layout -->
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : style/keynat.bst
Cite All     : False

Package      : mathptmx

<!--  Blockquotes for chapter headers -->
Package      : epigraph
Tex Header   : 
  \epigraphsize{\small\itshape}
  \setlength\epigraphwidth{8cm}
  \setlength\epigraphrule{0pt}
Epigraph {
  replace:"~ Begin TexOnly&nl;\
           ~ Begin TexRaw&nl;\
             \epigraph{&source;}{--- &caption;}&nl;\
           ~ End TexRaw&nl;\
           ~ End TexOnly&nl;\
           ~ Begin HtmlOnly&nl;\
            <blockquote>&nl;\
              <p>&source;</p>&nl;\
              <footer style='float:right;'>— &caption;</footer>&nl;\
            </blockquote>&nl;\
           ~ End HtmlOnly"
}
.epigraph { max-width:50%; margin-left: auto; margin-right: 0; }
.epigraph-footer { float:right; }
<!-- # # # # # # # # # # # # # # # # # # # # # # -->

.LitNote { 
  background-color: LightGray;
  padding: 1ex;
}
.Mind {
  background-color: #cbffcb;
  before="[";
  after="]"
}
.Todo { 
  background-color: Aqua; 
  padding: 1ex;
}

<!-- TODO brauch ich das hier?
@if html {
  Name Contents   : \/

  Section Depth : 1
  Css           : webpaginated.css
  Script*       : webpaginated.js
}
-->
@if not html {
  Name Contents   : Inhaltsverzeichnis
}
@if not (tex) {
  Bib Search Url: scholar.google.at
}

CSS Header      :
  @import url(https://fonts.googleapis.com/css?family=Crimson+Text);
  body.madoko {
    font-family: "Crimson Text", serif;
  }
  .madoko .math-rendering {
    color: black;
  }
  hr.figureline.madoko {
    display: none;
  }
  .toc a, .toc a:visited { 
    color: #0000EE;  
  }

[TITLE]

<!--
~ HtmlOnly
A PDF Version of this thesis is available at [max.irro.at/pub/thesis/dipl.pdf](http://max.irro.at/pub/thesis/dipl.pdf)
~
-->

[TOC]


<!-- TODO hier müssen sachen wie titleseite, frontmatter etc eingefügt werden -->





# Danksagung { -; toc:clear; }

TODO

<!--
* Meinen Eltern, die mich in meinem Studium immer unterstützt haben, obwohl ich sie viel zu selten anrufe.
-->

# Abstract { -; toc:clear; }

# Kurzfassung { -; toc:clear; }

# Preface

In 2016, I was reading a thread on HackerNews, and one of the comments cought my eye: 

*Any ideomatic Erlang program is by design a microservices architecture* (link hier als fußnote)

This made me wonder: *Is it really?* And if so, thus would imply that MSA are unnecessary, or that the underlying concurrency model Erlang uses (a concept which we will discuss in this thesis) would be much supreme compared to the models I am used to use.

Having myself a bit of a crush on the Microservice Architecture Style, this did not let go of my grey cells, and I was thinking in the back of my brain that this should be analysed in detail. Having the masters thesis on my Todo list anyway, I was wondering how I cold make this my topic.


~ TexOnly
[TOC]
[TOC=figures]
[TOC=tables]
~



Introduction
============



~ Epigraph { caption: "Lewis Carroll, Alice in Wonderland"}
Begin at the beginning," the King said gravely, and go on till you come to the end: then stop.
~

## Motivation

## Scope of this Thesis

## Methodology used

* the assumptions/theses/laws/etc on MSA presented in chapter "MSA" were identified through thorough literature research

## Road Map



Programming Paradigms
=====================



## Imperative, Structured and Procedual Programming


## Object-oriented Programming

* Data Abstraction and Modularity

### History of Objects: Simula and Smalltalk

## Functional Programming


## Event-Driven and Flow-Driven Programming

## Logic and Constraint Programming

## Role-based Programming

## Other Programming Paradigms



Models of Concurrent Computation
================================



## Basic Concepts in Concurrency

### Execution Order and Nondeterminism

* see chapter 14 in "Concepts in Programming Languages" by Mitchell

## Threads, Locks and Shared State

### Case Study: the Java Concurrency Model

## Actors and Active Objects

### Case Study: the Scala Concurrency Model

## Software Transactional Memory

### Case Study: the Clojure Concurrency Model

## Event-driven Concurrency

### Case Study: the JavaScript/node.js Concurrency Model

## Parallel Architecture

~LitNote
* siehe [@But14] zu den 4 Teilen:
  * Bit-Level Parallelism
  * Instruction-Level Parallelism
  * Data Parallelism
  * Task_level Parallelism (das ist das für mich wichtige)
    * hier wird zwischen Shared-memory und Distributed-memory unterschieden, mit guter Erklärung
~

### Inter-process Communication

~LitNote
* [@But14]
  * shared-memory: inter-process comm. through memory (faster)
  * distributed memory: each own local memory, inter-process comm. through network (slow, latency, all network errors)
    * hier passen die "Fallaties of distributed systems" gut rein! siehe [@RGO06]
~

## Concurrency Models and Distributed Systems Similarities

## Other Approaches and Concurrency Primitives



The Microservice Architecture Style
===================================



## Service-oriented Systems

## Key Concepts

## Architecture Properties

### Geographically Distributed Code: Concurrency Beyond Multiple Cores

~LitNote
* seet [@But14] was "geographically distributed code" bedeutet (im zusammenhang eines concurrency models); MSA haben dies wieder einmal inherent
~

### Resilience

## Architectural Elements

### Communication Channel ()

mostly HTTP

### Database per Service

### API Gateway: Request Broker and Curcuit Breaker

#### Case Study: Hysterix and Akka

## Quality Issues

### Software Quality Attributes

#### Performance

##### Case Study: JSON in Service as a Performance factor (siehe [@OBM05] p.15)

## Design Concerns

### Smart endpoints and dumb pipes (geklaut von M.Fowler)

### Failure is inevitable

### Service Granularity: Size vs. Number of Services

### Satisfaction of local vs. global Quality Properties

### Polyglot Programming

## Patterns (Kapitel notwendig?)

### Event-driven architecture

## Development, Debugging and Maintenance

~ Epigraph { caption: "Filipe Fortes" }
Debugging is like being the detective in a crime movie where you're also the murderer.
~

* [DGL17]: microservices implement a limited amount of functionalities, which makes their code base small and inherently limits the scope of a bug.Moreover, since microservices are independent, a developer can directly test and investigate their functionalities in isolation with respect to the rest of the system



Towards a (Micro)service-Oriented Paradigm: A Look at Analogies
======================================================



## Data Abstraction

### Encapsulation

### Information Hiding

## Identity and Equality

* Identity = unique network address (may be abstracted behind gayteway proxy)
* Equality = multiple (stateless) instances of the same service executable 

## SOLID design principles

## Design by Contract and REST

~LitNote
bzgl REST:

* see [Mon16b], section 7, "RESTful services"
~

### REpresentational State Transfer 

### Pre- and Postconditions

### Invariants and History-constraints

## Substitution and Behaviour

* Ersetzbarkeit von Services (zB durch neue Version)
  * Wenn Schnittstellen gleich
  * Wenn Verhalten (nach außen) gleich/kompatibel

## Delegation: Delegation: Sharing partial implementation

~LitNote
* see [@Sny93] "Essense of Objects"
~

### Case Study: Delegation in JavaScript

## Message Passing: Avoiding Shared State

## Clients Request Services

~LitNote
In [@Sny93] steht zu den *essential concepts* von Objekten u.a. "**Clients request services from objects**". Die folgenden Unterpunkte sind gegeben:

1. Clients issue requests
2. Objects are encapsulated
3. Requests identify operations
4. Requests can identify objects

Diese 4 Punkte kann ich am konkreten Bsp eines MS durchspielen:

1. aufruft eines andere MS mittels REST call: einfach die REST URL angeben
2. Encapsulation ist trivial zu argumentieren: jeder MS eigenes Program
3. Die Operation wird identifiziert durch die REST Methode (PUT, GET, POST, DELETE) und den relativen Pfad (der hinter der Network-Addr.)
4. Die Identification wird über die URL (den Teil mit der Network-Addr) gezeigt

Punkt 2 ist etwas überflüssig, aber kann man ja argumentieren. Punkt 3 und 4 sind besser vertauscht zu zeigen
~

## Event-based View

## Flow-based View   

## Process-, Behavioural-, and Session-Types

~LitNote
* "Behavioural types are types that can describe the behaviour of services and can be used to
check that two (or more) services have compatible actions" [@Dra17a]
* "Session types are a prime example of behavioural types" [@Dra17a]
* "Session types have been successfully applied to many contexts already, ranging from parallel to distributed computing." [@Dra17a]

zu Session Types: 

* see "*Kohei Honda, Vasco Vasconcelos, and Makoto Kubo. Language primitives and type disciplines for structured communication-based programming. pages 22–138, 1998*"
* see "*Kohei Honda, Nobuko Yoshida, and Marco Carbone. Multiparty asynchronous session types. Journal of the ACM,63(1):9, 2016. Also: POPL, 2008, pages 273–284*"
~

## Choreographies

~LitNote
* "Choreographies are high-level descriptions of the communications that we want to happen in a system in contrast with the typical methodology of defining the behaviour of each service separately" [@Dra17a]
* see [@Mon13] "*Choreographic Programming*"
~



The Microservice Concurrency Model
==================================



## Immutable Messages

### Asynchronouse Dataflow with Synchronous Messages

## Message Processing and Transactional Memory

jeder REST request (der von einem DB state abhängt) wird mit STM gekennzeichnet (zB `@Transactional` in Java)

## Applicability for Concurrent Problems

## Applicability for Parallel Problems

## Resilient Code

## Geographically Distributed Code

## Distributed Computation

## Concurrent Process Types for Services



Scenario-based Experiment
=========================



## Scenario

Anforderungen an das Szenario; welche Showcases müssen demonstriert werden können:

* Update von Funktionalität ohne Änderung des Gesamtsystems
  * Deployment einer einzigen neuen MS-Programversion
  * Update durch neuen Untertyp und Deployment mittels Dependency Injection
* Synchronized access to shared data (zB die Fabrikshalle)
  * Datastore MS, der von mehrere MS gleichzeitig benutzt werden kann
  * Actor/ActiveObj/WasAuchImmer, welches die Sync to irgendeinem Datenspeicher übernimmt
* Coarse grained operations on shared "objects" (in active objects), bzw auf services allgemein
  * Kommunikation mit einem Roboter ist wohl ein einfaches Beispiel (via Object oder via Service Kommunikation)
* Kein shared state
  * Alle Actors/ActiveObbj/WasAuchImmer hat eigenen Datenspeicher
  * MS haben eigenen State (und möglicherweise sogar eigene DB)
  * Gemeinsame Datenspeicher via DataStore "pattern" (ist das irgendwie als echtes Pattern festgehalten?)
* reusing, orchestration, aggrgation
  * "every MS can be reused, orchestrated and aggregated with others"
    * reuse: mehrere instanzen des selben MS starten
    * orchestration: ?
    * aggregation: ?
  * passendes gegenstück zu concurrency model/objecten/etc?
    * reuse
    * orchestration
    * aggregation
* Bounded context
  * MS: "Related functionalities are combined into a single business capability; implemented as a service"
  * OOP: __Wie lauten die genauen definitionen, zB aus dem Buch von Meyer??__: 1) sich nur um eine Concern kümmern; 2)
* Size
  * OOP: nicht zu groß, sonst mehrere klassen; für maintainability; OOP generell für extendibility
* Technology heterogeneity
  * in MSA können unterschiedliche MS in unterschiedlichen programmiersprachen geschrieben werden: wäre interessant für implementierung, einen service nicht in Java (zB Scala, Clojure, Ruby, irgendwas anderes) zu schreiben; idealerweise einen der nicht aufwändig ist!
  * nicht machbar in OOP etc


~TODO
Hier beschreibe ich kurz die "Angabe" zu meinen Implementierungen. Es soll durch eine Geschichte motiviert werden
~

In order to base our implementations on a realistic scenario, we motivate the generel setting the implementations could actually be put to their use in a short summary:

~ {font-style: italic; width: 40%; margin: 2ex;}
A long time ago in a galaxy far, far away....

The Republic is crumbling under attacks by the ruthless Sith Lord, Count Dooku. His Separatist Droid Army is produced automatically inside Smart Factories somewhere in the Outer Rim. All production steps are performed by autonomouse droids. This highly concurrent system will lead to the ultimate victory over the Jedi....
~

In this scenario, we simulate the production processes of such a *smart factory*. A variaty of coordination problems therefore have to be handled. The following actors (here, we mean the "droid" actors, not actors as in the actor model) are involved:

* customers (separatist leaders ordering battle-droids)
* management droids
* logistic droids
* assembly droids
* quality-assurance droids
* delivery droids

The following poducts (battle droid models) can be produced inside the smart factory:

~TODO
droids siehe: http://starwars.wikia.com/wiki/Separatist_Droid_Army
~

* B1 battle droid
* B2 super battle droid
* Droideka
* Super tactical droid


We created two prototypical impelementations simulating the descripated *smart factory*. One implementation is written in Erlang using its actor model. The other implementation is written with a microservice architecture, in [**Java ?**] / [**Go ?**]

## Prototype using Standard Models of Concurrency

### Case Study: Why do Java Programmers like MSA?

## Prototype based on a Micorservice Architecture

## Findings



Discussion
==========



## Comparision of Attributes/Features/etc

## Comparison of the MSA-Concurrency-Model with the others

## Why Developers adopt MSA

## Problems of Developers with Concurrency Models

### Case Study: Why Do Scala Developers Mix the Actor Model with other Concurrency Models?

## Do Sufficiently Concurrent Programming Languages need MSA?

### Jolie

~LitNote
* Jolie "natively" supports decorator pattern
  * see https://www.reddit.com/r/programming/comments/5hrxh5/jolie_natively_supports_decorator_pattern_maybe/
  * see http://fmontesi.github.io/2016/11/12/service-decorators.html
~

### Distributed Erlang

#### Scalability and Reliability

### Plattform and Middleware-based Approaches

#### XVSM/MozartSpaces



Outlook
=======



~ Epigraph { caption: "Niels Bohr" }
Predicition is very difficult, especially about the future.
~

* "Programming Services as a new Paradigm"
  * Hier die Vision und die Gründe/Vorteile von einem neuen Paradigma beschreiben
  * Bsp der Datenbank-Services: 
    * Jeder MS sollte seine eigene DB haben. Kann man genau so mit zB Actors oder auch Threads handhaben. Aber beim Deployment gibt es hier Unterschiede. Beim starten eines neuen MS (= Program/Single-Executable-Artefact) ist es leicht auch eine neue DB zu starten (weil auch Programm). Über einen Mechanismus/Tool welches auf dieser konzeptionellen Ebene arbeitet (Programme im OS zu starten, zB Docker) lässt sich dies heute leicht automatisieren. Ein Thread (oder Actor/Active Obj/etc.) steht konzeptionell auf einer anderen Ebene. Es ist ein Konstrukt innerhalb des übergeordnetten Programms. Dh wenn ein neuer Thread erstellt wird ist dies in der Programmiersprache (oder Library/Framework) vorgesehen, aber die DB muss irgendwie extra über eine Interaktion mit dem unterliegenden OS (noch schwieriger in der Cloud, weil nicht umbedingt ein OS sichtbar/ansprechbar ist) gestartet werden. Java zB abstrahiert ja mit der JVM das OS so gut es geht weg (Plattformunabhängigkeit). Natürlich kann man mit dem System schon reden, aber es ist konzeptionell nicht vorgesehen dies als Standardmechanismus ständig zu verwenden. Die Datenbank muss anschließend auch noch irgendwie initialisiert werden, was zB wiederum das Laden eins Init-Scripts erforderlich macht. Dh das Deployment des Threads und das der Datenbank stehen auf konzeptionell unterschiedlichen Ebenen, ihr gemeinsames Deployment ist nicht vorgesehen und somit umständlich/schwierig. Bei MS ist dies konzeptionell auf die selbe Ebene gehoben. 
* in [Dra17a] wir im Kapitel "Tomorrow" ein weiter Blick in zukünftige Möglichkeiten gegeben:
  * connecting behavioural types and choreographies to well-known logical models
  * a logical reconstruc- tion of behavioural types in classical linear logic that supports parametric polymorphism [83];
  * type theories for integrating higher-order process models with functional computation [79];
  * initial ideas for algorithms for extracting choreographies from separate service programs [18];
  * a logical characterisation of choreography-based behavioural types [19]; 
  * explanations of how interactions among multiple services (multiparty sessions) are related to well-known techniques for logical reasoning [16,13];
  * formal methods based on well-known techniques seem to be a promising starting point for tackling the issue of writing correct microservice systems;
  * these patterns will benefit from the rich set of features that formal languages and process models have to offer, such as expressive type theories and logics;
  

Conclusion
==========

[BIB]

<!-- TODO glossar, nomenclature, index -->

