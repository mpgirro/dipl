@inproceedings{AAE16,
  title        = {{A Systematic Mapping Study in Microservice Architecture}},
  author       = {Alshuqayran, Nuha and Ali, Nour and Evans, Roger},
  booktitle    = {Service-Oriented Computing and Applications (SOCA), 2016 IEEE 9th International Conference on},
  pages        = {44--51},
  year         = {2016},
  organization = {IEEE},
  annote       = {}
}

* no consenus has emerged on a single model of concurrency
* discussion on paradigm shift in [Pratt 83]
* "Pratt's Process Model" satisfies several properties desirable in any model of concurrent
  computation
* (Pratts?) model does not assume the existance of global states
* laws of parallel processing formulated in [Hewit and Baker 77]
* Foundational Issues (p.3-4 genauer erklärt)
  - Shared Resources
  - Dynamic Reconfiguration
  Inherent Parallelism
* Actor = computational agent which caries out its actions in response to accepting a communication
* Actions are:
  - Send communication to itself or to other actors
  - Create more actors (gibt es einen MSA mechanismus der das erlaubt? Cloud management frameworks
    nicht von MS direkt angesprochen)
  - Specify the replacement behaviour
* The buffering of communication has the consequence that actor languages support recursion.
  In languages relying on synchronous communication, any recursive procedure immediately leads to deadlock (!)
* Two important obersavtions need to be made about replacement. First, replacement implements
  local state chance while preserving referential transparency of the identifiers used in a program
* [...] computation of a replacement actor is an action which may be carried out concurrently with
  other actions performaed by an actor, the replacement process is intrinsically concurrent
* In actor-based architectures, the only constraints on the speed of execution stem from the
  logical dependencies in the computation and the limitations imposed by the hardware resources
* [...] this has the implicastio that message-passing can be used to spawn concurrency: An Actor,
  in response to a communciation, may send several communications to other actors
* A "configuration" (p.7) is a instantaneous snapshot og an actor system from some viewpoint. Each
  configuration has teh following parts:
  - local state function
  - set of unprocessed tasks
  - subset of the population, called "receptionist" actors
  - set of external actors
* Open Systems (p.16)
  It is reasonable to expect that large-scale parallel systems will be composed of independently developed and maintained modules. Such systems will be open-ended and continually undergoing change [Hewitt and de Jong 85]
* Characteristics of Open Systems
  - Continuous Availability
  - Modularity
  - Extensibility
* "Definition: Composition. Let c1 || c2 represent the concurrent composition..." (p.19)
* Actor languages uniformly use message-passing to spawn concurrency and are inherently parallel
* The problem of shared resources with changing local state is dealt with by providing an
  object-oriented environment without the sequential bottle-neck caused by assignment commands
* An actor language also provides a suitable basis for large-scale parallelism. Besides the
  ability to distribute the work required in the course of a computation, actor systems can be composed simply by passing messages between them. The internal workings of an actor system are not available to any other system

@inproceedings{AH85,
  title        = {{Concurrent Programming Using Actors: Exploiting Large-Scale Parallelism}},
  author       = {Agha, Gul and Hewitt, Carl},
  booktitle    = {Foundations of Software Technology and Theoretical Computer Science},
  pages        = {19--41},
  year         = {1985},
  organization = {Springer},
  annote       = {}
}

* p.126: Concurrency abstracts away some of the details in an execution, allowing us to concentrate on conceptual issues without having to be concerned with a particular order of execution which may result from the quirks of a given system. -- Highlighted 19 May 2017
* p.126: Objects can be defined as entities which encapsula.te data and operations into a single computational unit.  -- Highlighted 19 May 2017
* p.126: hree common patterns of parallelism in problems have been found in practice (For example, see [8, 131). First, pipeline concurrency involves the enumeration of potential solutions and the concurrent testing of these solutions as they are enumerated. Second, divide and conquer concurrency involves the concurrent elaboration of different subproblems and the joining of (some or all) of their solutions in order to obtain a solution to the overall problem. In divide and conquer concurrency, there is no interaction between the procedures solving the subproblems.  -- Highlighted 19 May 2017
* The term Actor was introduced by Carl Hewitt at MIT in the early 1970s
* p.127: Divide-and-conquer concurrency algorithms can often be expressed as functions.  -- Highlighted 19 May 2017
* p.128: n cooperative problem solving concurrency, intermediate results arestored in objects and shared by pass-ing messages between objects. -- Highlighted 19 May 2017
* p.128: Another example of coopera-tive problem solving is blackboardsystems which allow collaborationbetween agents through a sharedwork space. -- Highlighted 19 May 2017
* p.128: Actors are self-contained, interactive, independent componentsof a computing system that communicate by asynchronous message passing.  -- Highlighted 19 May 2017
* p.128: Each time an actor processes a communication, it also computes its behavior in response to the next communication it may process.  -- Highlighted 19 May 2017
* p.128: In other cases, the behavior may change. The change in the behavior may represent a simple change of state variables, such as change in the balance of an account, or it may represent changes in the operations (methods) which are carried out in response to messages. -- Highlighted 19 May 2017
* p.128: Concurrent computations can be visualized in terms of event diagrams (see Figure 5). These diagrams were developed to model the behavior of actor systems. -- Highlighted 19 May 2017
* p.130: A customer can be sent a reply message when a request is completed, or a complaint message if it is not possible to successfully complete the reqluest. -- Highlighted 19 May 2017
* p.132: Although actors take a functionalview of an object’s internal behavior at any given point in time, actors can represent shared history-sensitive ob-jects.  -- Highlighted 19 May 2017
* p.132: We call such a merge afair merge. Afair merge is complete because itmerges message:; from every senderand may not ignore any sender inde-finitely and it is indeterminate be-cause no particular order is specifiedfor messages sent to the same objectby different objects.  -- Highlighted 19 May 2017
* Using a semantics of fair merge, one can reason about the eventual behavior of a concurrent program; reasoning about eventual properties of a concurrent system is analogous to reasoning about fixed points in a recursion in sequential programming.
* Inherent Concurrency
*
@article{Agh90,
  title     = {{Concurrent Object-Oriented Programming}},
  author    = {Agha, Gul},
  journal   = {Communications of the ACM},
  volume    = {33},
  number    = {9},
  pages     = {125--141},
  year      = {1990},
  publisher = {ACM},
  annote    = {}
}

@article{Arm93,
  title     = {{Concurrent programming in ERLANG}},
  author    = {Armstrong, Joe and Virding, Robert and Wikstr{\"o}m, Claes and Williams, Mike},
  year      = {1993},
  publisher = {Citeseer},
  annote    = {}
}

* [...] Alan Snyder of Hewlett Packard wrote an influential survey paper “The Essence of Objects”
* In Snyder’s view, the essential concepts were as follows:
  - An object embodies an abstraction.
  - Objects provide services.
  - Clients issue requests for those services.
  - Objects are encapsulated.
  - Requests identify operations.
  - Requests can identify objects.
  - New objects can be created.
  - The same operation on distinct objects can have different implementations and observably different behaviour.
  - Objects can be classified in terms of their services (interface hierarchy).
  - Objects can share implementations.
    – Objects can share a common implementation (multiple instances).
    – Objects can share partial implementations (implementation inheritance or delegation).
* Snyder does mention “Active Objects” as an “associated concept,” that is, an idea “associated with the notion of objects, but not essential to it.” The idea that classes can serve as modules does not appear at all.
* Dan Ingalls’ sweeping 1981 Byte article “Design Principles behind Smalltalk” [27]
* In 2002, Dahl wrote [14]:
  The most important new concept of Simula 67 is surely the idea of data structures with associated operators . . . called objects. There is an important difference, except in trivial cases, between
  - the inside view of an object, understood in terms of local variables, possibly initialising operations establishing an
invariant, and implemented procedures operating on the variables maintaining the invariant, and
  - the outside view, as presented by the remotely accessible procedures, including some generating mechanism, dealing
with more “abstract” entities.
* Simula’s “quasi-parallelism” was a sweet-spot in 1961: it allowed programmers to think about concurrency while ignoring synchronisation. Because another task could execute only when explicitly resumed, programmers could be confident that their data would not change “out from under them” at unexpected times
* Hewitt’s Actor model [37] built on this idea, as did Emerald [16], in which every object could potentially contain a process. Other languages, like Erlang, have made the process the main focus of the language rather than the object [38].
@article{Bla13,
  title     = {{Object-oriented programming: Some history, and challenges for the next fifty years}},
  author    = {Black, Andrew P},
  journal   = {Information and Computation},
  volume    = {231},
  pages     = {3--20},
  year      = {2013},
  publisher = {Elsevier},
  annote    = {}
}

@inproceedings{BY87,
  title        = {{Inheritance and synchronization in concurrent OOP}},
  author       = {Briot, Jean-Pierre and Yonezawa, Akinori},
  booktitle    = {European Conference on Object-Oriented Programming},
  pages        = {32--40},
  year         = {1987},
  organization = {Springer}
}

@article{CLG17,
 title   = {{Evaluating Scalable Distributed Erlang for Scalability and Reliability}},
 author  = {Natalia Chechina and Huiqing Li and Amir Ghaffari and Simon Thompson and Phil Trinder},
 journal = {Journal of Parallel and Distributed Computing},
 volume  = {90-91},
 number  = {Natalia Chechina, Kenneth MacKenzie, Simon Thompson, Phil Trinder, Olivier Boudeville, Viktoria Fordos, Csaba Hoch, Amir Ghaffari, Mario Moro Hernandez},
 year    = {2017},
 doi     = {http://dx.doi.org/10.1109/TPDS.2017.2654246},
 url     = {http://ieeexplore.ieee.org/document/7820204/},
 annote  = {}
}


* "Before presenting the current state-of-the-art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later"

@article{DGL16,
  title   = {{Microservices: yesterday, today, and tomorrow}},
  author  = {Dragoni, Nicola and Giallorenzo, Saverio and Lafuente, Alberto Lluch and Mazzara, Manuel and Montesi, Fabrizio and Mustafin, Ruslan and Safina, Larisa},
  journal = {arXiv preprint arXiv:1606.04036},
  year    = {2016},
  annote  = {}
}

@article{DLL17,
  title   = {{Microservices: How To Make Your Application Scale}},
  author  = {Dragoni, Nicola and Lanese, Ivan and Larsen, Stephan Thordal and Mazzara, Manuel and Mustafin, Ruslan and Safina, Larisa},
  journal = {arXiv preprint arXiv:1702.07149},
  year    = {2017},
  annote  = {}
}

@masterthesis{Erb12,
  title    = {{Concurrent Programming for Scalable Web Architectures}},
  author   = {Benjamin Erb},
  school   = {Institute of Distributed Systems, Ulm University},
  year     = {2012},
  type     = {Diploma Thesis},
  keywords = {web, scalability, architecture, concurrency},
  month    = {April},
  number   = {VS-D01-2012},
  url      = {http://www.benjamin-erb.de/thesis},
  annote   = {}
}


* We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call. (This is a different concept to that of a service object in many OO programs [3].

  - 3: Many object-oriented designers, including ourselves, use the term service object in the Domain-Driven Design sense for an object that carries out a significant process that isn't tied to an entity. This is a different concept to how we're using "service" in this article. Sadly the term service has both meanings and we have to live with the polyseme.

@misc{FL17,
  title        = {Microservices},
  author       = {Fowler, Martin and Lewis, James},
  year         = {2014 (accessed April 2, 2017)},
  howpublished = "\url{http://martinfowler.com/articles/microservices.html}",
  annote       = {}
}

@inproceedings{Fra17,
  author    = {Paolo Di Francesco},
  title     = {{Architecting Microservices}},
  booktitle = {2017 {IEEE} International Conference on Software Architecture Workshops,
               {ICSA} Workshops 2017, Gothenburg, Sweden, April 5-7, 2017},
  pages     = {224--229},
  year      = {2017},
  crossref  = {DBLP:conf/icsa/2017w},
  url       = {https://doi.org/10.1109/ICSAW.2017.65},
  doi       = {10.1109/ICSAW.2017.65},
  timestamp = {Tue, 27 Jun 2017 14:39:26 +0200},
  biburl    = {http://dblp.org/rec/bib/conf/icsa/Francesco17},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}


* p.68: Combining the agent concept and the object paradigm leads to the notion of agent-oriented program-ming -- Highlighted 21 May 2017
* p.68: The concept of an active object—integrating an object and activity (namely a thread or process)—provides some degree of autonomy in that it does not rely on external resources for activation -- Highlighted 21 May 2017
* p.68: Carl Hewitt introduced the active-object (or actor) concept to describe a set of entities that cooperate and communicate through message passing. This concept brings the benefits of object orientation (for example, modularity and encapsulation) to distributed environments and provides object-oriented languages with some of the characteristics of open systems -- Highlighted 21 May 2017
* p.69: Active objects are monolithic and have procedural behavior. -- Highlighted 21 May 2017
* p.69: An agent is not monolithic. -- Highlighted 21 May 2017
* p.70: It can have several behaviors: communication, perception, deliberation, and so forth -- Highlighted 21 May 2017
* p.70: An agent has a goal; it does not simply act in response to messages from other agents -- Highlighted 21 May 2017
*
@article{GB99,
  title     = {{From Active Objects to Autonomous Agents}},
  author    = {Guessoum, Zahia and Briot, J-P},
  journal   = {IEEE concurrency},
  volume    = {7},
  number    = {3},
  pages     = {68--76},
  year      = {1999},
  publisher = {IEEE},
  annote    = {}
}

* based on the observation that programming objects can be naturally interpreted as processes.
* that communicate by executing remote methods
* Programming objects can be thought of as processes
* the above program differs from the standard C++ only in the extension of the operator new.
* new allocates objects on remote machines, using the address of the remote machine specified inside parentheses.
* The construction of a new object on a remote machine cre- ates a new process on that machine.
* The introduction of processes, accessible by remote pointers, creates an object-oriented framework for parallel program- ming. Processes exchange information by executing meth- ods on remote objects rather than by passing messages.
* Having defined processes as programming objects, it is now straightforward to derive new processes using previously de- fined processes. We illustrate process inheritance by extend- ing the example of the previous section.
* In this paper we have shown that programming objects have a natural interpretation as processes
@article{Giv14,
  title   = {{Object-Oriented Parallel Programming}},
  author  = {Givelberg, Edward},
  journal = {arXiv preprint arXiv:1404.4666},
  year    = {2014},
  annote  = {}
}

@inproceedings{HB16,
  author    = {Sara Hassan and
               Rami Bahsoon},
  title     = {{Microservices and Their Design Trade-Offs: {A} Self-Adaptive Roadmap}},
  booktitle = {{IEEE} International Conference on Services Computing, {SCC} 2016,
               San Francisco, CA, USA, June 27 - July 2, 2016},
  pages     = {813--818},
  year      = {2016},
  crossref  = {DBLP:conf/IEEEscc/2016},
  url       = {https://doi.org/10.1109/SCC.2016.113},
  doi       = {10.1109/SCC.2016.113},
  biburl    = {http://dblp.org/rec/bib/conf/IEEEscc/HassanB16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@article{Kil16,
  title     = {{The Hidden Dividends of Microservices}},
  author    = {Killalea, Tom},
  journal   = {Communications of the ACM},
  volume    = {59},
  number    = {8},
  pages     = {42--45},
  year      = {2016},
  publisher = {ACM},
  annote    = {}
}

* The ActiveObject pattern decouples method execution from method invocation in order to simplify synchronized access to a shared resource bymethods invoked in different threads of control
* To illustrate the Active Object pattern, consider the design of a connection-oriented Gateway. A Gateway decouples cooperating components in a distributed system and allows them to interact without having direct dependencies among each other
* This pattern enables a method to execute in a different thread than the one that invoked the method originally. In contrast, passive objects execute in the same thread as the object that called a method on the passiv object.
* The active object Gateway design resolves the following forces:
  * Simplify flow control
  * Simplifyconcurrent programming
  * Take advantage of parallelism
* Use the Active Object pattern when
  * The design and implementation of a concurrent program can be simplified
  * Multiple threads of control require synchronized access to shared data
  * The order of method execution can differ from the order of method invocation
  * The operations on a shared object are relatively coarse-grained
* The Active Object pattern offers the following benefit
  * Enhance application concurrency while reducing synchronization complexity
  * Leverage parallelism available from the hardware and software platform
* The Active Object pattern has the following drawbacks
  * It potentially increases context switching, data movement, and synchronization overhead
  * It may be difficult to debug programs containing active objects due to the concurrency and non-determinism of the Scheduler
@article{LS95,
  title     = {{Active Object--an Object Behavioral Pattern for Concurrent Programming}},
  author    = {Lavender, R Greg and Schmidt, Douglas C},
  year      = {1995},
  publisher = {Citeseer},
  annote    = {}
}

@article{McK17,
  title   = {{Is Parallel Programming Hard, And, If So, What Can You Do About It? (v2017.01.02a)}},
  author  = {Paul E. McKenney},
  journal = {arXiv preprint arXiv:1701.00854},
  url     = {http://arxiv.org/abs/1701.00854},
  year    = {2017},
  annote  = {}
}

@book{Mey97,
  title     = {{Object-oriented Software Construction (2nd Ed.)}},
  author    = {Meyer, Bertrand},
  year      = {1997},
  isbn      = {0-13-629155-4},
  publisher = {Prentice-Hall, Inc.},
  address   = {Upper Saddle River, NJ, USA},
  annote    = {}
}

@incollection{MGZ14,
  title     = {{Service-Oriented Programming with Jolie}},
  author    = {Montesi, Fabrizio and Guidi, Claudio and Zavattaro, Gianluigi},
  booktitle = {Web Services Foundations},
  pages     = {81--107},
  year      = {2014},
  publisher = {Springer},
  annote    = {}
}

* Object-oriented technologies are prominent in software development
* A notable example is the Eiffel programming language [9], incorporating solid principles of OOP within a programming framework coordinated by the idea of design- by-contract, which aims at correctness-by-construction.
* Component-wise each build- ing block is built as a microservice [11] embedding busi- ness capabilities in isolation. Every microservice can be reused, orchestrated, and aggregated with others [10]
* The microservices architecture [4] is built on very simple principles:
  - Bounded Context. First introduced in [5], this con- cept captures one of the key properties of microservice architecture: focus on business capabilities. Related functionalities are combined into a single business ca- pability which is then implemented as a service.
  - Size; benefits in terms of service maintainability and extendability; Idiomatic use of microservices architecture suggests that if a service is too large, it should be refined into two or more services, thus pre-serving granularity andmaintaining focus on providing only a single business capability.
  - Independency: concepts encourages loose cou- pling and high cohesion by stating that each service Independency. This concepts encourages loose cou- pling and high cohesion by stating that each service in microservice architectures is operationally indepen-dent from others, and the only form of communication between services is through their published interfaces.
* Even though it is likely to conduct to a paradigm shift and a dramatic change in perception, it does not build on vacuum, and instead relates to well-established paradigms such as OO and SOA.
* [...] focusing on the evolutionary aspects more than the revolu- tionary ones.
@article{MMSL16,
  title   = {{Towards Microservices and Beyond: An incoming Paradigm Shift in Distributed Computing}},
  author  = {Mazzara, Manuel and Mustafin, Ruslan and Safina, Larisa and Lanese, Ivan},
  journal = {arXiv preprint arXiv:1610.01778},
  year    = {2016},
  annote  = {}
}

@masterthesis{Mon10,
  title  = {{JOLIE: a Service-oriented Programming Language}},
  author = {Montesi, Fabrizio},
  year   = {2010},
  annote = {}
}

@phdthesis{Mon14,
  title     = {Choreographic programming},
  author    = {Montesi, Fabrizio},
  year      = {2014},
  publisher = {InstituttetThe Department, Software and SystemsSoftware \& Systems, Programming, Logic and Semantics},
  annote    = {}
}

* p.1:  Jolie, a language -- Highlighted 19 May 2017
* p.1: inspired by Service-Oriented Architecture (SOA). The key difference between the two approaches lies in granularity. -- Highlighted 19 May 2017
* p.1: a single executable artifact, called a monolith -- Highlighted 19 May 2017
* p.1: Components can be deployed separate, -- Highlighted 19 May 2017
* p.1: New versions of components can be gradually introduced in a system -- Highlighted 19 May 2017
* p.1: Components can be more specialised -- Highlighted 19 May 2017
* p.1: Scaling a microservice architecture does not imply a duplication of all its components -- Highlighted 19 May 2017
* p.1: Interactions among microservices happen via message passing, which introduces the possibilities of communication failures and timeouts among components. -- Highlighted 19 May 2017
* p.1: Services may become overloaded, because of too many concurrent client requests or resources being kept busy while waiting for replies from other services. This may easily trigger disastrous cascading failures. -- Highlighted 19 May 2017
* p.1: Microservices can use different technologies, enabling specialisation to specific clients and tasks. -- Highlighted 19 May 2017
* p.2: We also demonstrate how the solutions that carry novelty in the setting of microservices can be prototyped using constructs developed for service composition in Jolie [26], a native microservice programming language [20]. -- Highlighted 19 May 2017
* p.2: Failure in an MSA is inevitable, and should be embraced with precaution rather than ignored. -- Highlighted 19 May 2017
* p.2: The motto here is to fail fast: when a service becomes unresponsive, its invokers should stop waiting for it, assume the worst, and start dealing with the fact that the failing service may be unavailable -- Highlighted 19 May 2017
* p.2: One of the most famous implementations of circuit breakers is provided by the Hystrix library [30] -- Highlighted 19 May 2017
* p.2: Here, we make the (novel) observation that it makes sense to deploy a circuit breaker also in other places than just inside of clients -- Highlighted 19 May 2017
* p.5: In practice, the location of a microservice may not be statically known at design time. -- Highlighted 19 May 2017
* p.5: A service registry is a service that can be used by other components to retrieve binding information about other components -- Highlighted 19 May 2017
* p.6: An MSA may need to serve different kinds of clients and user interfaces, such as those found in web browsers and various smart devices  -- Highlighted 19 May 2017
* p.6: depending on the quality of its current network connection, a device may want to use an API that is more or less network intensive -- Highlighted 19 May 2017
* p.6: It is a single entry point that provides access to many APIs -- Highlighted 19 May 2017
* p.6: Since an API Gateway is an entry point for the MSA, it is natural to equip it with, e.g., service discovery, load balancing, monitoring, and security. -- Highlighted 19 May 2017
* p.6: Since an API Gateway is an entry point for the MSA, it is natural to equip it with, e.g., service discovery, load balancing, monitoring, and security.Its position in the system is also ideal for adopting the proxy circuit breaker pattern, by equipping the API Gateway with circuit breakers for clients and/or services -- Highlighted 19 May 2017
* p.7: However, MSAs are much more involved than other distributed applications where services are implemented as monoliths, because all internal components are subjects to potential communication failures and overloads -- Highlighted 19 May 2017
* p.7: Circuit breakers have first been popularised in [35], where their role is discussed in the context of availability (resilience) for enterprise systems -- Highlighted 19 May 2017
* p.7: Akka [22] provides a circuit breaker implementation that supports basic configuration parameters, such as call timeout, failure threshold and reset threshold. Hystrix [30] is much more flexible and is currently one of the reference solutions: -- Highlighted 19 May 2017
@article{MW16,
  title   = {{Circuit Breakers, Discovery, and API Gateways in Microservices}},
  author  = {Montesi, Fabrizio and Weber, Janine},
  journal = {arXiv preprint arXiv:1609.05830},
  year    = {2016},
  annote  = {}
}

@techreport{OBM05,
     title       = {{Quality Attributes and Service-Oriented Architectures}},
     author      = {O'Brien, Liam and Len Bass, Len and Merson, Paulo F.},
     year        = {2005},
     institution = {Carnegie Mellon University, Software Engineering Institute},
     month       = {09},
     url         = {http://repository.cmu.edu/cgi/viewcontent.cgi?article=1440&context=sei},
}

* The Orc programming language [15, 22] enables a concur- rency-first style of programming, in which programmers start with a concurrent program, instead of adding concurrency only when it is required.
* For instance, in pure active object systems concurrency can only exist between ob- jects so a new object must be introduced to add concurrency even if that object will be adversely coupled to other objects.
* OrcO objects are designed to be orthogonal to concurrency, allowing the concurrent structure and the object structure of a program to evolve independently.
* Orc is pervasively concurrent, because it replaces conventional sequential control structures with concurrency combinators.
* object boundaries are not used to structure concurrency and con- currency within objects is the same as concurrency among objects.
* One example of a superposed computation is logging in a web server. For each request, the server instantiates a Handler and calls its handle method
* ProActive and Asynchronous Sequential Processes provide transparent futures
* Emerald [4, 5], like OrcO, enables concurrency both be- tween and within objects. Like many active object languages, all concurrency in Emerald is provided by a single sequential process attached to each object.
* The parallel actor monitor is allowed to dispatch messages to execute concurrently with other messages in the same actor.
* Oz [35] provides concur- rent object-oriented programming in a constraint logic pro- gramming language. All variables in Oz—including fields— are logic variables and assignment is bidirectional unification.
@inproceedings{PKTC16,
  title        = {{OrcO: A Concurrency-First Approach to Objects}},
  author       = {Peters, Arthur Michener and Kitchin, David and Thywissen, John A and Cook, William R},
  booktitle    = {Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  pages        = {548--567},
  year         = {2016},
  organization = {ACM},
  annote       = {}
}

TODO fragen ob ich da ein PDF bekomme

@Book{Pun00,
  title     = {{Concurrent Object-Oriented Programming with Process Types}},
  author    = {Franz Puntigam},
  publisher = {{Der Andere Verlag}},
  year      = 2000,
  address   = {Osnabr{\"u}ck, Germany},
  annote    = {}
}

* Chapter 1: "Rule of Composition: Design programs to be connected with other programs; siehe http://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2877684

@book{Ray03,
  title     = {{The Art of Unix Programming}},
  author    = {Raymond, Eric S},
  year      = {2003},
  publisher = {Addison-Wesley Professional},
  annote    = {}
}


* New Objects can be created : vgl mit µS, hier können auch neue Services erzeugt werden, um zu skalieren (wenn entsprechend implementiert, daher im allgemeinen schwerer!)

* Active Objects "can initiate computation spontaneously, without being requested to do so by a client, AO is a concurrent process" --> in etwa so wie µS

* Objects can share implementations : wenn mehrere µS von der selben Codebase gestartet werden, tun sie das auch, haben eigenen State, aber "identical state format"

* Objects can share partial implementation : inheritence eher schwierig, aber delegation in µS ganz normal, so auch bei Objekten

* Dynamic Binding : nur eine Idee, aber kann man da einen Vergleich zu API Gateways ziehen, die zur Laufzeit den tatsächlichen Service an den weitergereicht wird (oder das dann selber entsprechende Antwort bei nicht existenz produziert) ziehen?

@article{Sny93,
  title     = {{The Essence of Objects: Concepts and Terms}},
  author    = {Snyder, Alan},
  journal   = {IEEE software},
  volume    = {10},
  number    = {1},
  pages     = {31--42},
  year      = {1993},
  publisher = {IEEE},
  annote    = {}
}

@article{SRH17,
  author    = {Dharmendra Shadija and
               Mo Rezai and
               Richard Hill},
  title     = {{Microservices: Granularity vs. Performance}},
  journal   = {CoRR},
  volume    = {abs/1709.09242},
  year      = {2017},
  url       = {http://arxiv.org/abs/1709.09242},
  archivePrefix = {arXiv},
  eprint    = {1709.09242},
  timestamp = {Thu, 05 Oct 2017 09:42:59 +0200},
  biburl    = {http://dblp.org/rec/bib/journals/corr/abs-1709-09242},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@misc{SSRB00,
  title     = {{Pattern-Oriented Software Architecture: Patterns for Concurrent and Networked Objects}},
  author    = {Schmidt, Douglas C and Stal, Michael and Rohnert, Hans and Buschmann, Frank},
  year      = {2000},
  publisher = {New York, NY: Wiley \& Sons},
  annote    = {}
}

* p.1: It’s not an exaggeration to say that writing correct multithreaded programs is beyond many programmers’ technical abilities. -- Highlighted 18 May 2017
* p.1: One of the primary reasons concurrency is so hard is that popular imperative programming languages such as Java and C++ essentially require state to be shared among threads. -- Highlighted 18 May 2017
* p.1: Programmers writing multithreaded applica  tions in languages like Java and C++ spend much   of their time determining what state is shared   among threads and how best to protect its integri  ty within the running application. Finding all the   shared state isn’t always easy.  -- Highlighted 18 May 2017
* p.1: Assuming the pro  grammer can even find it, he or she must then pos  sess the skills, experience, and patience necessary   to determine the best way to serialize access to it -- Highlighted 18 May 2017
* p.1: If locking is too coarse-grained, the application tends toward single-threading -- Highlighted 18 May 2017
* p.1: Such applications make poor use of multicore CPUs and tend to be slow. If locking is too fine-grained, on the other hand, the chances for deadlock increase greatly as different threads are increasingly likely to obtain locks in different orders -- Highlighted 18 May 2017
* p.1:  Idioms, patterns, and frameworks can help out partially, but they introduce restrictions and trade-offs of their own. -- Highlighted 18 May 2017
* p.1: One way to avoid the problems with shared state is to simply avoid it, but that’s impractical in a language like C++ or Java. Doing so requires a combination of libraries or frameworks such as those based on actor models and message passing -- Highlighted 18 May 2017
* p.1: A better way to avoid shared state is to switch to a programming language specifically designed to do exactly that. Erlang is one such language. -- Highlighted 18 May 2017
* p.2: They required their language to help them build highly concurrent, fault-tolerant, highly available, and distributed services that supported live upgrades and ran with virtually zero downtime. -- Highlighted 18 May 2017
* p.2: In fact, it’s so hard that even if you’ve done it before, you can still very easily get it wrong. Consequently, when building a new system, most developers tend to focus first on the nonreplicated, nonreliable version, seriously considering the really hard failover and load-balancing parts only after they get that working. -- Highlighted 18 May 2017
* p.2: Erlang is a functional language that wholly embraces the “shared nothing” concept -- Highlighted 18 May 2017
* p.2: Because Erlang variables are immutable, they don’t need concurrency protection -- Highlighted 18 May 2017
* p.2: Avoiding shared variables allows for higher degrees of program parallelization, assuming threads aren’t too heavyweight. Erlang “processes,” which are essentially user-space threads rather than Unix processes or kernel threads, communicate only via message passing -- Highlighted 18 May 2017
* p.4: Locks, condition variables, and other traditional multithreading constructs simply aren't necessary in any of this code. -- Highlighted 18 May 2017
@article{Vin07,
  title     = {{Concurrency with Erlang}},
  author    = {Vinoski, Steve},
  journal   = {IEEE Internet Computing},
  volume    = {11},
  number    = {5},
  year      = {2007},
  publisher = {IEEE},
  annote    = {}
}


* Parallelism is ubiquitous in our problem domains.
* by using various metaphors found in such systems
* Each object in our computation model has its own (autonomous) processing power and it my have its local persistent memory,thecontentsofwhichmpcesentitsstate.Anobjectis always in one of three modes: dormant, active, or waiting. An object is initially dormant. It becomes active when it receives a message that satisfies one of the specified patterm and constraints.
* When an active object completes the sequence of actions that are performed in response to an accepted message, if no subsequent messages have arrived, it becomes dormant again. An object in the active mode sometimes needs to stop its current activity in order to wait for a message with specified patm'ns to arrive. In such a case, an active object changes into the waiting mode. An object in the waiting mode becomes active again when it receives a n~quired message.
* Thus message passing takes place in a point-to-point (object-to-object)fashion.No message can be broadcast.
* [Assumption for Preservation of Transmission Ordering]When two messages are sent to an object T by the same object O, the temporal ordering of the two message transmissions (according to O's clock) must be preserved in the temporal ordering of the two message arrivals (according to T's clock).
* This assumption was not made in the Actor model of computa-tion. Without this, however, it is difficult to model even simple things as objects.
@inproceedings{Yon86a,
  title        = {{Object-oriented concurrent programming ABCL/1}},
  author       = {Yonezawa, Akinori and Briot, Jean-Pierre and Shibayama, Etsuya},
  booktitle    = {ACM SIGPLAN Notices},
  volume       = {21},
  numbe        = {11},
  pages        = {258--268},
  year         = {1986},
  organization = {ACM},
  annote       = {}
}

* Carl and his group member were interested in
  –finding a universal model for concurrent computation, and
  –the abstraction and simulation of activities for almost all entities which interact with each other and are able to move around in physical spaces.
* The entire research group was convinced that the basic entities in the model should be process- or procedure-like things that mutually interact with message passing. Message passing is required to be asynchronous in the sense that an entity can send a message to another entity anytime, even when the destination entity is not ready or able to receive the message.
* However, these notions of objects did not deal with message transmissions which take place among objects. Of course, the interactions among objects were called message passing, but they were merely meant to be dynamically dispatched method calls (or procedure calls). A more restricted formal cal-culus of modeling message passing objects was proposed by Robin Milner [7].
* In our approach, the domain to be modeled/designed/implemented is represented as a collection of concurrent objects, and the interaction of the domain components is represented as concurrent message passing among such concurrent objects.
* an intuitive characterization of concurrent objects (COs) below. Each CO
  – has a globally unique identity/name,
  – may have a protected, yet updatable local memory,
  – has a set of procedures that manipulates the memory,
  – receives a message that activates one of the procedures,
  – has a single FIFO queue for arrived messages, and
  – has autonomous thread(s) of control.
@incollection{Yon14,
  title     = {My Early Education and Concurrent Objects},
  author    = {Yonezawa, Akinori},
  booktitle = {Concurrent Objects and Beyond},
  pages     = {1--17},
  year      = {2014},
  publisher = {Springer},
  annote    = {In this Festschrift, he is telling the interresting story about his education.
               Some characters appear that are well known for their concurrency research as well.
               In Part 2 he is giving some explinations about his understanding of Concurrent
               Objects, and how it differes from the understanding of others.}
}

TODO: das PDF organisieren (schwer zu kriegen!)

@article{YT86,
  title     = {{Object-Oriented Concurrent Programming}},
  author    = {Yonezawa, Akinori and Tokoro, Mario},
  year      = {1986},
  publisher = {The MIT Press, Cambridge, MA},
  annote    = {}
}