@book{Aba96,
  author    = {Mart{\'{\i}}n Abadi and
               Luca Cardelli},
  title     = {{A Theory of Objects}},
  series    = {Monographs in Computer Science},
  publisher = {Springer},
  year      = {1996},
  url       = {https://doi.org/10.1007/978-1-4419-8598-9},
  doi       = {10.1007/978-1-4419-8598-9},
  isbn      = {978-0-387-94775-4}
}

@inproceedings{Agh85,
  author    = {Gul Agha and
               Carl Hewitt},
  title     = {{Concurrent Programming Using Actors: Exploiting Large-Scale Parallelism}},
  booktitle = {Foundations of Software Technology and Theoretical Computer Science,
               Fifth Conference, New Delhi, India, December 16-18, 1985, Proceedings},
  pages     = {19--41},
  year      = {1985},
  url       = {https://doi.org/10.1007/3-540-16042-6_2},
  doi       = {10.1007/3-540-16042-6_2}
}

@article{Agh90,
  author    = {Gul Agha},
  title     = {{Concurrent Object-Oriented Programming}},
  journal   = {Commun. {ACM}},
  volume    = {33},
  number    = {9},
  pages     = {125--141},
  year      = {1990},
  url       = {http://doi.acm.org/10.1145/83880.84528},
  doi       = {10.1145/83880.84528}
}

@phdthesis{Ahm14,
  author    = {Salman Azeem Ahmad},
  title     = {{Programming Language Design for Service-Oriented Systems}},
  school    = {Massachusetts Institute of Technology, Cambridge, MA, {USA}},
  year      = {2014},
  url       = {http://hdl.handle.net/1721.1/92961}
}

@inproceedings{Als16,
  author    = {Nuha Alshuqayran and
               Nour Ali and
               Roger Evans},
  title     = {{A Systematic Mapping Study in Microservice Architecture}},
  booktitle = {9th {IEEE} International Conference on Service-Oriented Computing
               and Applications, {SOCA} 2016, Macau, China, November 4-6, 2016},
  pages     = {44--51},
  year      = {2016},
  url       = {https://doi.org/10.1109/SOCA.2016.15},
  doi       = {10.1109/SOCA.2016.15}
}

@article{Anc16,
  author    = {Davide Ancona and
               Viviana Bono and
               Mario Bravetti and
               Joana Campos and
               Giuseppe Castagna and
               Pierre{-}Malo Deni{\'{e}}lou and
               Simon J. Gay and
               Nils Gesbert and
               Elena Giachino and
               Raymond Hu and
               Einar Broch Johnsen and
               Francisco Martins and
               Viviana Mascardi and
               Fabrizio Montesi and
               Rumyana Neykova and
               Nicholas Ng and
               Luca Padovani and
               Vasco T. Vasconcelos and
               Nobuko Yoshida},
  title     = {{Behavioral Types in Programming Languages}},
  journal   = {Foundations and Trends in Programming Languages},
  volume    = {3},
  number    = {2-3},
  pages     = {95--230},
  year      = {2016},
  url       = {https://doi.org/10.1561/2500000031},
  doi       = {10.1561/2500000031}
}


TODO: noch keine literaturnotizen vorhanden!
@book{Arm93,
  author    = {Joe Armstrong and
               Robert Virding and
               Mike Williams},
  title     = {{Concurrent programming in ERLANG}},
  publisher = {Prentice Hall},
  year      = {1993},
  isbn      = {978-0-13-285792-5}
}

@article{Bla13,
  author    = {Andrew P. Black},
  title     = {{Object-oriented programming: Some history, and challenges for the
               next fifty years}},
  journal   = {Inf. Comput.},
  volume    = {231},
  pages     = {3--20},
  year      = {2013},
  url       = {https://doi.org/10.1016/j.ic.2013.08.002},
  doi       = {10.1016/j.ic.2013.08.002}
}

@inproceedings{Bri87,
  author    = {Jean{-}Pierre Briot and
               Akinori Yonezawa},
  title     = {{Inheritance and Synchronization in Concurrent OOP}},
  booktitle = {ECOOP'87 European Conference on Object-Oriented Programming, Paris,
               France, June 15-17, 1987, Proceedings},
  pages     = {32--40},
  year      = {1987},
  url       = {https://doi.org/10.1007/3-540-47891-4_4},
  doi       = {10.1007/3-540-47891-4_4}
}

@book{But14,
  title     = {{Seven Concurrency Models in Seven Weeks: When Threads Unravel}},
  author    = {Paul Butcher},
  year      = {2014},
  publisher = {Pragmatic Bookshelf},
  isbn      = {978-1-93778-565-9}
}

@article{Che17,
  author    = {Natalia Chechina and
               Kenneth MacKenzie and
               Simon J. Thompson and
               Phil Trinder and
               Olivier Boudeville and
               Viktoria Ford{\'{o}}s and
               Csaba Hoch and
               Amir Ghaffari and
               Mario Moro Hernandez},
  title     = {{Evaluating Scalable Distributed Erlang for Scalability and Reliability}},
  journal   = {{IEEE} Trans. Parallel Distrib. Syst.},
  volume    = {28},
  number    = {8},
  pages     = {2244--2257},
  year      = {2017},
  url       = {https://doi.org/10.1109/TPDS.2017.2654246},
  doi       = {10.1109/TPDS.2017.2654246}
}


TODO: da jetzt offiziell publiziert, das kürzel von DGL16 zu DGL17 umbenennen
@incollection{Dra17a,
  author    = {Nicola Dragoni and
               Saverio Giallorenzo and
               Alberto Lluch{-}Lafuente and
               Manuel Mazzara and
               Fabrizio Montesi and
               Ruslan Mustafin and
               Larisa Safina},
  title     = {{Microservices: yesterday, today, and tomorrow}},
  booktitle = {Present and Ulterior Software Engineering.},
  pages     = {195--216},
  year      = {2017},
  url       = {https://doi.org/10.1007/978-3-319-67425-4_12},
  doi       = {10.1007/978-3-319-67425-4_12}
}

@article{Dra17b,
  author    = {Nicola Dragoni and
               Ivan Lanese and
               Stephan Thordal Larsen and
               Manuel Mazzara and
               Ruslan Mustafin and
               Larisa Safina},
  title     = {{Microservices: How To Make Your Application Scale}},
  journal   = {CoRR},
  volume    = {abs/1702.07149},
  year      = {2017},
  url       = {http://arxiv.org/abs/1702.07149},
  archivePrefix = {arXiv},
  eprint    = {1702.07149}
}

@masterthesis{Erb12,
  title    = {{Concurrent Programming for Scalable Web Architectures}},
  author   = {Benjamin Erb},
  school   = {Institute of Distributed Systems, Ulm University},
  year     = {2012},
  type     = {Diploma Thesis},
  keywords = {web, scalability, architecture, concurrency},
  month    = {April},
  number   = {VS-D01-2012},
  url      = {http://www.benjamin-erb.de/thesis},
  annote   = {}
}

@misc{Fow14,
  title        = {Microservices},
  author       = {Fowler, Martin and Lewis, James},
  year         = {2014 (accessed April 2, 2017)},
  howpublished = "\url{http://martinfowler.com/articles/microservices.html}",
  annote       = {}
}

@inproceedings{Fra17,
  author    = {Paolo Di Francesco},
  title     = {{Architecting Microservices}},
  booktitle = {2017 {IEEE} International Conference on Software Architecture Workshops,
               {ICSA} Workshops 2017, Gothenburg, Sweden, April 5-7, 2017},
  pages     = {224--229},
  year      = {2017},
  url       = {https://doi.org/10.1109/ICSAW.2017.65},
  doi       = {10.1109/ICSAW.2017.65}
}

@article{Gho12,
  author    = {Debasish Ghosh and
               Justin Sheehy and
               Kresten Krab Thorup and
               Steve Vinoski},
  title     = {Programming language impact on the development of distributed systems},
  journal   = {J. Internet Services and Applications},
  volume    = {3},
  number    = {1},
  pages     = {23--30},
  year      = {2012},
  url       = {https://doi.org/10.1007/s13174-011-0042-y},
  doi       = {10.1007/s13174-011-0042-y}
}

* based on the observation that programming objects can be naturally interpreted as processes.
* that communicate by executing remote methods
* Programming objects can be thought of as processes
* the above program differs from the standard C++ only in the extension of the operator new.
* new allocates objects on remote machines, using the address of the remote machine specified inside parentheses.
* The construction of a new object on a remote machine cre- ates a new process on that machine.
* The introduction of processes, accessible by remote pointers, creates an object-oriented framework for parallel program- ming. Processes exchange information by executing meth- ods on remote objects rather than by passing messages.
* Having defined processes as programming objects, it is now straightforward to derive new processes using previously de- fined processes. We illustrate process inheritance by extend- ing the example of the previous section.
* In this paper we have shown that programming objects have a natural interpretation as processes
@article{Giv14,
  author    = {Edward Givelberg},
  title     = {{Object-Oriented Parallel Programming}},
  journal   = {CoRR},
  volume    = {abs/1404.4666},
  year      = {2014},
  url       = {http://arxiv.org/abs/1404.4666},
  archivePrefix = {arXiv},
  eprint    = {1404.4666}
}

* p.68: Combining the agent concept and the object paradigm leads to the notion of agent-oriented program-ming -- Highlighted 21 May 2017
* p.68: The concept of an active object—integrating an object and activity (namely a thread or process)—provides some degree of autonomy in that it does not rely on external resources for activation -- Highlighted 21 May 2017
* p.68: Carl Hewitt introduced the active-object (or actor) concept to describe a set of entities that cooperate and communicate through message passing. This concept brings the benefits of object orientation (for example, modularity and encapsulation) to distributed environments and provides object-oriented languages with some of the characteristics of open systems -- Highlighted 21 May 2017
* p.69: Active objects are monolithic and have procedural behavior. -- Highlighted 21 May 2017
* p.69: An agent is not monolithic. -- Highlighted 21 May 2017
* p.70: It can have several behaviors: communication, perception, deliberation, and so forth -- Highlighted 21 May 2017
* p.70: An agent has a goal; it does not simply act in response to messages from other agents -- Highlighted 21 May 2017
@article{Gue99,
  author    = {Zahia Guessoum and
               Jean{-}Pierre Briot},
  title     = {{From Active Objects to Autonomous Agents}},
  journal   = {{IEEE} Concurrency},
  volume    = {7},
  number    = {3},
  pages     = {68--76},
  year      = {1999},
  url       = {https://doi.org/10.1109/4434.788781},
  doi       = {10.1109/4434.788781}
}

@inproceedings{Has16,
  author    = {Sara Hassan and
               Rami Bahsoon},
  title     = {{Microservices and Their Design Trade-Offs: {A} Self-Adaptive Roadmap}},
  booktitle = {{IEEE} International Conference on Services Computing, {SCC} 2016,
               San Francisco, CA, USA, June 27 - July 2, 2016},
  pages     = {813--818},
  year      = {2016},
  url       = {https://doi.org/10.1109/SCC.2016.113},
  doi       = {10.1109/SCC.2016.113}
}

@article{Kil16,
  author    = {Tom Killalea},
  title     = {{The Hidden Dividends of Microservices}},
  journal   = {Commun. {ACM}},
  volume    = {59},
  number    = {8},
  pages     = {42--45},
  year      = {2016},
  url       = {http://doi.acm.org/10.1145/2948985},
  doi       = {10.1145/2948985}
}

* The ActiveObject pattern decouples method execution from method invocation in order to simplify synchronized access to a shared resource bymethods invoked in different threads of control
* To illustrate the Active Object pattern, consider the design of a connection-oriented Gateway. A Gateway decouples cooperating components in a distributed system and allows them to interact without having direct dependencies among each other
* This pattern enables a method to execute in a different thread than the one that invoked the method originally. In contrast, passive objects execute in the same thread as the object that called a method on the passiv object.
* The active object Gateway design resolves the following forces:
  * Simplify flow control
  * Simplifyconcurrent programming
  * Take advantage of parallelism
* Use the Active Object pattern when
  * The design and implementation of a concurrent program can be simplified
  * Multiple threads of control require synchronized access to shared data
  * The order of method execution can differ from the order of method invocation
  * The operations on a shared object are relatively coarse-grained
* The Active Object pattern offers the following benefit
  * Enhance application concurrency while reducing synchronization complexity
  * Leverage parallelism available from the hardware and software platform
* The Active Object pattern has the following drawbacks
  * It potentially increases context switching, data movement, and synchronization overhead
  * It may be difficult to debug programs containing active objects due to the concurrency and non-determinism of the Scheduler
@article{Lav95,
    author  = {R. Greg Lavender and Douglas C. Schmidt},
    title   = {{Active Object -- An Object Behavioral Pattern for Concurrent Programming}},
    year    = {1995},
    publisher = {Citeseer}
}

* Object-oriented technologies are prominent in software development
* A notable example is the Eiffel programming language [9], incorporating solid principles of OOP within a programming framework coordinated by the idea of design- by-contract, which aims at correctness-by-construction.
* Component-wise each build- ing block is built as a microservice [11] embedding busi- ness capabilities in isolation. Every microservice can be reused, orchestrated, and aggregated with others [10]
* The microservices architecture [4] is built on very simple principles:
  - Bounded Context. First introduced in [5], this con- cept captures one of the key properties of microservice architecture: focus on business capabilities. Related functionalities are combined into a single business ca- pability which is then implemented as a service.
  - Size; benefits in terms of service maintainability and extendability; Idiomatic use of microservices architecture suggests that if a service is too large, it should be refined into two or more services, thus pre-serving granularity andmaintaining focus on providing only a single business capability.
  - Independency: concepts encourages loose cou- pling and high cohesion by stating that each service Independency. This concepts encourages loose cou- pling and high cohesion by stating that each service in microservice architectures is operationally indepen-dent from others, and the only form of communication between services is through their published interfaces.
* Even though it is likely to conduct to a paradigm shift and a dramatic change in perception, it does not build on vacuum, and instead relates to well-established paradigms such as OO and SOA.
* [...] focusing on the evolutionary aspects more than the revolu- tionary ones.
@article{Maz16,
  author    = {Manuel Mazzara and
               Ruslan Mustafin and
               Larisa Safina and
               Ivan Lanese},
  title     = {{Towards Microservices and Beyond: An incoming Paradigm Shift in Distributed
               Computing}},
  journal   = {CoRR},
  volume    = {abs/1610.01778},
  year      = {2016},
  url       = {http://arxiv.org/abs/1610.01778},
  archivePrefix = {arXiv},
  eprint    = {1610.01778}
}

@article{McK17,
  author    = {Paul E. McKenney},
  title     = {{Is Parallel Programming Hard, And, If So, What Can You Do About It?
               (v2017.01.02a)}},
  journal   = {CoRR},
  volume    = {abs/1701.00854},
  year      = {2017},
  url       = {http://arxiv.org/abs/1701.00854},
  archivePrefix = {arXiv},
  eprint    = {1701.00854}
}

@book{Mey97,
  author    = {Bertrand Meyer},
  title     = {{Object-Oriented Software Construction, 2nd Edition}},
  publisher = {Prentice-Hall},
  year      = {1997},
  isbn      = {0-13-629155-4}
}

@masterthesis{Mon10,
  author = {Fabrizio Montesi},
  title  = {{JOLIE: a Service-oriented Programming Language}},
  school = {University of Bologna},
  year   = {2010},
  note    = {\url{http://www.fabriziomontesi.com/files/m10.pdf}}
}

@phdthesis{Mon13,
  author    = {Fabrizio Montesi},
  title     = {{Choreographic Programming}},
  school    = {IT University of Copenhagen},
  type      = {Ph.{D}. Thesis},
  year      = {2013},
  note      = {\url{http://www.fabriziomontesi.com/files/choreographic_programming.pdf}}
}

@incollection{Mon14,
  author    = {Fabrizio Montesi and
               Claudio Guidi and
               Gianluigi Zavattaro},
  title     = {{Service-Oriented Programming with Jolie}},
  booktitle = {Web Services Foundations},
  pages     = {81--107},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-1-4614-7518-7_4},
  doi       = {10.1007/978-1-4614-7518-7_4}
}

* p.1:  Jolie, a language -- Highlighted 19 May 2017
* p.1: inspired by Service-Oriented Architecture (SOA). The key difference between the two approaches lies in granularity. -- Highlighted 19 May 2017
* p.1: a single executable artifact, called a monolith -- Highlighted 19 May 2017
* p.1: Components can be deployed separate, -- Highlighted 19 May 2017
* p.1: New versions of components can be gradually introduced in a system -- Highlighted 19 May 2017
* p.1: Components can be more specialised -- Highlighted 19 May 2017
* p.1: Scaling a microservice architecture does not imply a duplication of all its components -- Highlighted 19 May 2017
* p.1: Interactions among microservices happen via message passing, which introduces the possibilities of communication failures and timeouts among components. -- Highlighted 19 May 2017
* p.1: Services may become overloaded, because of too many concurrent client requests or resources being kept busy while waiting for replies from other services. This may easily trigger disastrous cascading failures. -- Highlighted 19 May 2017
* p.1: Microservices can use different technologies, enabling specialisation to specific clients and tasks. -- Highlighted 19 May 2017
* p.2: We also demonstrate how the solutions that carry novelty in the setting of microservices can be prototyped using constructs developed for service composition in Jolie [26], a native microservice programming language [20]. -- Highlighted 19 May 2017
* p.2: Failure in an MSA is inevitable, and should be embraced with precaution rather than ignored. -- Highlighted 19 May 2017
* p.2: The motto here is to fail fast: when a service becomes unresponsive, its invokers should stop waiting for it, assume the worst, and start dealing with the fact that the failing service may be unavailable -- Highlighted 19 May 2017
* p.2: One of the most famous implementations of circuit breakers is provided by the Hystrix library [30] -- Highlighted 19 May 2017
* p.2: Here, we make the (novel) observation that it makes sense to deploy a circuit breaker also in other places than just inside of clients -- Highlighted 19 May 2017
* p.5: In practice, the location of a microservice may not be statically known at design time. -- Highlighted 19 May 2017
* p.5: A service registry is a service that can be used by other components to retrieve binding information about other components -- Highlighted 19 May 2017
* p.6: An MSA may need to serve different kinds of clients and user interfaces, such as those found in web browsers and various smart devices  -- Highlighted 19 May 2017
* p.6: depending on the quality of its current network connection, a device may want to use an API that is more or less network intensive -- Highlighted 19 May 2017
* p.6: It is a single entry point that provides access to many APIs -- Highlighted 19 May 2017
* p.6: Since an API Gateway is an entry point for the MSA, it is natural to equip it with, e.g., service discovery, load balancing, monitoring, and security. -- Highlighted 19 May 2017
* p.6: Since an API Gateway is an entry point for the MSA, it is natural to equip it with, e.g., service discovery, load balancing, monitoring, and security.Its position in the system is also ideal for adopting the proxy circuit breaker pattern, by equipping the API Gateway with circuit breakers for clients and/or services -- Highlighted 19 May 2017
* p.7: However, MSAs are much more involved than other distributed applications where services are implemented as monoliths, because all internal components are subjects to potential communication failures and overloads -- Highlighted 19 May 2017
* p.7: Circuit breakers have first been popularised in [35], where their role is discussed in the context of availability (resilience) for enterprise systems -- Highlighted 19 May 2017
* p.7: Akka [22] provides a circuit breaker implementation that supports basic configuration parameters, such as call timeout, failure threshold and reset threshold. Hystrix [30] is much more flexible and is currently one of the reference solutions: -- Highlighted 19 May 2017
@article{Mon16a,
  author    = {Fabrizio Montesi and
               Janine Weber},
  title     = {{Circuit Breakers, Discovery, and API Gateways in Microservices}},
  journal   = {CoRR},
  volume    = {abs/1609.05830},
  year      = {2016},
  url       = {http://arxiv.org/abs/1609.05830},
  archivePrefix = {arXiv},
  eprint    = {1609.05830}
}

@article{Mon16b,
  author    = {Fabrizio Montesi},
  title     = {{Process-aware web programming with Jolie}},
  journal   = {Sci. Comput. Program.},
  volume    = {130},
  pages     = {69--96},
  year      = {2016},
  url       = {https://doi.org/10.1016/j.scico.2016.05.002},
  doi       = {10.1016/j.scico.2016.05.002}
}

@inproceedings{Mon17,
  author    = {Fabrizio Montesi and
               Dan Sebastian Thrane},
  title     = {{Packaging Microservices}},
  booktitle = {Distributed Applications and Interoperable Systems - 17th {IFIP} {WG}
               6.1 International Conference, {DAIS} 2017, Held as Part of the 12th
               International Federated Conference on Distributed Computing Techniques,
               DisCoTec 2017, Neuch{\^{a}}tel, Switzerland, June 19-22, 2017, Proceedings},
  pages     = {131--137},
  year      = {2017},
  url       = {https://doi.org/10.1007/978-3-319-59665-5_9},
  doi       = {10.1007/978-3-319-59665-5_9}
}

@book{New15,
  author    = {Sam Newman},
  title     = {{Building Microservices: Designing Fine-Grained Systems, 1st Edition}},
  publisher = {O'Reilly},
  year      = {2015},
  isbn      = {978-1491950357}
}

@techreport{OBr05,
  title       = {{Quality Attributes and Service-Oriented Architectures}},
  author      = {Liam O'Brien and 
                 Len Bass and 
                 Paulo F. Merson},
  year        = {2005},
  institution = {Carnegie Mellon University, Software Engineering Institute},
  month       = {09},
  url         = {http://repository.cmu.edu/cgi/viewcontent.cgi?article=1440&context=sei}
}

@article{Par72,
  author    = {David Lorge Parnas},
  title     = {{On the Criteria To Be Used in Decomposing Systems into Modules}},
  journal   = {Commun. {ACM}},
  volume    = {15},
  number    = {12},
  pages     = {1053--1058},
  year      = {1972},
  url       = {http://doi.acm.org/10.1145/361598.361623},
  doi       = {10.1145/361598.361623}
}

* The Orc programming language [15, 22] enables a concur- rency-first style of programming, in which programmers start with a concurrent program, instead of adding concurrency only when it is required.
* For instance, in pure active object systems concurrency can only exist between ob- jects so a new object must be introduced to add concurrency even if that object will be adversely coupled to other objects.
* OrcO objects are designed to be orthogonal to concurrency, allowing the concurrent structure and the object structure of a program to evolve independently.
* Orc is pervasively concurrent, because it replaces conventional sequential control structures with concurrency combinators.
* object boundaries are not used to structure concurrency and con- currency within objects is the same as concurrency among objects.
* One example of a superposed computation is logging in a web server. For each request, the server instantiates a Handler and calls its handle method
* ProActive and Asynchronous Sequential Processes provide transparent futures
* Emerald [4, 5], like OrcO, enables concurrency both be- tween and within objects. Like many active object languages, all concurrency in Emerald is provided by a single sequential process attached to each object.
* The parallel actor monitor is allowed to dispatch messages to execute concurrently with other messages in the same actor.
* Oz [35] provides concur- rent object-oriented programming in a constraint logic pro- gramming language. All variables in Oz—including fields— are logic variables and assignment is bidirectional unification.
@inproceedings{Pet16,
  author    = {Arthur Michener Peters and
               David Kitchin and
               John A. Thywissen and
               William R. Cook},
  title     = {{OrcO: A Concurrency-First Approach to Objects}},
  booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} International Conference on
               Object-Oriented Programming, Systems, Languages, and Applications,
               {OOPSLA} 2016, part of {SPLASH} 2016, Amsterdam, The Netherlands,
               October 30 - November 4, 2016},
  pages     = {548--567},
  year      = {2016},
  url       = {http://doi.acm.org/10.1145/2983990.2984022},
  doi       = {10.1145/2983990.2984022}
}

TODO fragen ob ich da ein PDF bekomme

@Book{Pun00,
  title     = {{Concurrent Object-Oriented Programming with Process Types}},
  author    = {Franz Puntigam},
  publisher = {{Der Andere Verlag}},
  year      = 2000,
  address   = {Osnabr{\"u}ck, Germany},
  annote    = {}
}

* Chapter 1: "Rule of Composition: Design programs to be connected with other programs; siehe http://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html#id2877684

@book{Ray03,
  title     = {{The Art of UNIX Programming}},
  author    = {Raymond, Eric S},
  year      = {2003},
  publisher = {Addison-Wesley Professional},
  isbn      = {978-0131429017},
  annote    = {}
}

@techreport{RGO06,
  title       = {{Fallacies of Distributed Computing Explained}},
  author      = {Arnon Rotem-Gal-Oz and
                 James Gosling and
                 L. Peter Deutsch},
  year        = {2006},
  institution = {Sun Microsystems},
  url         = {http://www.rgoarchitects.com/Files/fallacies.pdf}
}

@article{Sha17a,
  author    = {Dharmendra Shadija and
               Mo Rezai and
               Richard Hill},
  title     = {{Microservices: Granularity vs. Performance}},
  journal   = {CoRR},
  volume    = {abs/1709.09242},
  year      = {2017},
  url       = {http://arxiv.org/abs/1709.09242},
  archivePrefix = {arXiv},
  eprint    = {1709.09242}
}

@article{Sha17b,
  author    = {Dharmendra Shadija and
               Mo Rezai and
               Richard Hill},
  title     = {{Towards an Understanding of Microservices}},
  journal   = {CoRR},
  volume    = {abs/1709.06912},
  year      = {2017},
  url       = {http://arxiv.org/abs/1709.06912},
  archivePrefix = {arXiv},
  eprint    = {1709.06912}
}

* New Objects can be created : vgl mit µS, hier können auch neue Services erzeugt werden, um zu skalieren (wenn entsprechend implementiert, daher im allgemeinen schwerer!)

* Active Objects "can initiate computation spontaneously, without being requested to do so by a client, AO is a concurrent process" --> in etwa so wie µS

* Objects can share implementations : wenn mehrere µS von der selben Codebase gestartet werden, tun sie das auch, haben eigenen State, aber "identical state format"

* Objects can share partial implementation : inheritence eher schwierig, aber delegation in µS ganz normal, so auch bei Objekten

* Dynamic Binding : nur eine Idee, aber kann man da einen Vergleich zu API Gateways ziehen, die zur Laufzeit den tatsächlichen Service an den weitergereicht wird (oder das dann selber entsprechende Antwort bei nicht existenz produziert) ziehen?
@article{Sny93,
  author    = {Alan Snyder},
  title     = {{The Essence of Objects: Concepts and Terms}},
  journal   = {{IEEE} Software},
  volume    = {10},
  number    = {1},
  pages     = {31--42},
  year      = {1993},
  url       = {https://doi.org/10.1109/52.207219},
  doi       = {10.1109/52.207219}
}

@misc{SSRB00,
  title     = {{Pattern-Oriented Software Architecture: Patterns for Concurrent and Networked Objects}},
  author    = {Schmidt, Douglas C and Stal, Michael and Rohnert, Hans and Buschmann, Frank},
  year      = {2000},
  publisher = {New York, NY: Wiley \& Sons},
  annote    = {}
}

* p.1: It’s not an exaggeration to say that writing correct multithreaded programs is beyond many programmers’ technical abilities. -- Highlighted 18 May 2017
* p.1: One of the primary reasons concurrency is so hard is that popular imperative programming languages such as Java and C++ essentially require state to be shared among threads. -- Highlighted 18 May 2017
* p.1: Programmers writing multithreaded applica  tions in languages like Java and C++ spend much   of their time determining what state is shared   among threads and how best to protect its integri  ty within the running application. Finding all the   shared state isn’t always easy.  -- Highlighted 18 May 2017
* p.1: Assuming the pro  grammer can even find it, he or she must then pos  sess the skills, experience, and patience necessary   to determine the best way to serialize access to it -- Highlighted 18 May 2017
* p.1: If locking is too coarse-grained, the application tends toward single-threading -- Highlighted 18 May 2017
* p.1: Such applications make poor use of multicore CPUs and tend to be slow. If locking is too fine-grained, on the other hand, the chances for deadlock increase greatly as different threads are increasingly likely to obtain locks in different orders -- Highlighted 18 May 2017
* p.1:  Idioms, patterns, and frameworks can help out partially, but they introduce restrictions and trade-offs of their own. -- Highlighted 18 May 2017
* p.1: One way to avoid the problems with shared state is to simply avoid it, but that’s impractical in a language like C++ or Java. Doing so requires a combination of libraries or frameworks such as those based on actor models and message passing -- Highlighted 18 May 2017
* p.1: A better way to avoid shared state is to switch to a programming language specifically designed to do exactly that. Erlang is one such language. -- Highlighted 18 May 2017
* p.2: They required their language to help them build highly concurrent, fault-tolerant, highly available, and distributed services that supported live upgrades and ran with virtually zero downtime. -- Highlighted 18 May 2017
* p.2: In fact, it’s so hard that even if you’ve done it before, you can still very easily get it wrong. Consequently, when building a new system, most developers tend to focus first on the nonreplicated, nonreliable version, seriously considering the really hard failover and load-balancing parts only after they get that working. -- Highlighted 18 May 2017
* p.2: Erlang is a functional language that wholly embraces the “shared nothing” concept -- Highlighted 18 May 2017
* p.2: Because Erlang variables are immutable, they don’t need concurrency protection -- Highlighted 18 May 2017
* p.2: Avoiding shared variables allows for higher degrees of program parallelization, assuming threads aren’t too heavyweight. Erlang “processes,” which are essentially user-space threads rather than Unix processes or kernel threads, communicate only via message passing -- Highlighted 18 May 2017
* p.4: Locks, condition variables, and other traditional multithreading constructs simply aren't necessary in any of this code. -- Highlighted 18 May 2017
@article{Vin07,
  author    = {Steve Vinoski},
  title     = {{Concurrency with Erlang}},
  journal   = {{IEEE} Internet Computing},
  volume    = {11},
  number    = {5},
  pages     = {90--93},
  year      = {2007},
  url       = {https://doi.org/10.1109/MIC.2007.104},
  doi       = {10.1109/MIC.2007.104}
}

@inproceedings{Xia16,
  author    = {Zhongxiang Xiao and
               Inji Wijegunaratne and
               Xinjian Qiang},
  title     = {{Reflections on SOA and Microservices}},
  booktitle = {4th International Conference on Enterprise Systems, {ES} 2016, Melbourne,
               Australia, November 2-3, 2016},
  pages     = {60--67},
  year      = {2016},
  url       = {https://doi.org/10.1109/ES.2016.14},
  doi       = {10.1109/ES.2016.14}
}


* Parallelism is ubiquitous in our problem domains.
* by using various metaphors found in such systems
* Each object in our computation model has its own (autonomous) processing power and it my have its local persistent memory,thecontentsofwhichmpcesentitsstate.Anobjectis always in one of three modes: dormant, active, or waiting. An object is initially dormant. It becomes active when it receives a message that satisfies one of the specified patterm and constraints.
* When an active object completes the sequence of actions that are performed in response to an accepted message, if no subsequent messages have arrived, it becomes dormant again. An object in the active mode sometimes needs to stop its current activity in order to wait for a message with specified patm'ns to arrive. In such a case, an active object changes into the waiting mode. An object in the waiting mode becomes active again when it receives a n~quired message.
* Thus message passing takes place in a point-to-point (object-to-object)fashion.No message can be broadcast.
* [Assumption for Preservation of Transmission Ordering]When two messages are sent to an object T by the same object O, the temporal ordering of the two message transmissions (according to O's clock) must be preserved in the temporal ordering of the two message arrivals (according to T's clock).
* This assumption was not made in the Actor model of computa-tion. Without this, however, it is difficult to model even simple things as objects.
@inproceedings{Yon86,
  author    = {Akinori Yonezawa and
               Jean{-}Pierre Briot and
               Etsuya Shibayama},
  title     = {{Object-oriented concurrent programming ABCL/1}},
  booktitle = {Conference on Object-Oriented Programming Systems, Languages, and
               Applications (OOPSLA'86), Portland, Oregon, Proceedings.},
  pages     = {258--268},
  year      = {1986},
  url       = {http://doi.acm.org/10.1145/28697.28722},
  doi       = {10.1145/28697.28722}
}

* Carl and his group member were interested in
  –finding a universal model for concurrent computation, and
  –the abstraction and simulation of activities for almost all entities which interact with each other and are able to move around in physical spaces.
* The entire research group was convinced that the basic entities in the model should be process- or procedure-like things that mutually interact with message passing. Message passing is required to be asynchronous in the sense that an entity can send a message to another entity anytime, even when the destination entity is not ready or able to receive the message.
* However, these notions of objects did not deal with message transmissions which take place among objects. Of course, the interactions among objects were called message passing, but they were merely meant to be dynamically dispatched method calls (or procedure calls). A more restricted formal cal-culus of modeling message passing objects was proposed by Robin Milner [7].
* In our approach, the domain to be modeled/designed/implemented is represented as a collection of concurrent objects, and the interaction of the domain components is represented as concurrent message passing among such concurrent objects.
* an intuitive characterization of concurrent objects (COs) below. Each CO
  – has a globally unique identity/name,
  – may have a protected, yet updatable local memory,
  – has a set of procedures that manipulates the memory,
  – receives a message that activates one of the procedures,
  – has a single FIFO queue for arrived messages, and
  – has autonomous thread(s) of control.
@inproceedings{Yon14,
  author    = {Akinori Yonezawa},
  title     = {{My Early Education and Concurrent Objects}},
  booktitle = {Concurrent Objects and Beyond - Papers dedicated to Akinori Yonezawa
               on the Occasion of His 65th Birthday},
  pages     = {1--17},
  year      = {2014},
  url       = {https://doi.org/10.1007/978-3-662-44471-9_1},
  doi       = {10.1007/978-3-662-44471-9_1},
  annote    = {In this Festschrift, he is telling the interresting story about his education.
               Some characters appear that are well known for their concurrency research as well.
               In Part 2 he is giving some explinations about his understanding of Concurrent
               Objects, and how it differes from the understanding of others.}
}

TODO: das PDF organisieren (schwer zu kriegen!)

@article{YT86,
  title     = {{Object-Oriented Concurrent Programming}},
  author    = {Yonezawa, Akinori and Tokoro, Mario},
  year      = {1986},
  publisher = {The MIT Press, Cambridge, MA},
  annote    = {}
}