[INCLUDE=style/template]


Title        : A crack in the monolith
Subtitle     : Do sufficiently concurrent programming &br; languages need microservice architectures?
Title Note   : DRAFT, &date; (version 1.0)
Author       : Maximilian Irro
Email        : maximilian.irro@tuwien.ac.at

<!--Title Footer : April 2017-->

Toc depth    : 1
Bibliography : proposal
Bib style    : alpha
Logo         : False
Draft        : True

.LitNote { background-color: yellow }

@if not draft {
  LitNote { display: none }
}

[TITLE]

[TOC]

# Motivation & Problem Statement { #sec-motivation }

In 2014, a new software architectures style called *microservice architecture* (MSA) emerged
for designing software applications as distributed systems of loosley coupled,
independently deployable, single purpose services [@FL17]. Instead of developing
monolythic applications, the application logic is split up into a suite of small parts, each implemented as a dedicated program designed to provide a single task of the business logic. Theses programs posing as the applications components are called *microservices*.

The microservice architecture style is open for any programming language or paradigm [@DLL17]. Because the microservices are communication on a network level by sending messages (e.g. REST, sockets, etc.), the services themselfs may be written in different programming languages. As long as they expose the interface required by the architecture, they are useable components.

Interesting enough, this architecture style shares some similarities with long established programming paradigms. Some examples are:

* If we use the definition given in [@DGL16] "*A microservice is a cohesive, independent process interacting via messages*", we can spot commonalities with object-oriented design principles: objects should be loosely coupled (= independent) and highly cohesive [**Quelle!**]. 
* A fundamental concept of objects is "*Clients request services from objects*". In MSA, clients request services from other microservices. Using the Smalltalk terminology, communication between objects happens by sending *messages* (object method call) between them [@Sny93]. RESTful microservices send HTTP messages.
* Simula 67 introduced the concept of objects being data structs with associated operators. Additionally, two different views were introduced: the *inside view* of an object - its local variables, procedures on these variables, initialising operations etc. - and its *outside view*, more abstract entities representing the remoteley accessible state and procedures [@Bla13]. A microservice too has an internal view (the programs internal architecture, state, etc.) and an outside view, the network interface it exposes (e.g REST APIs and data in JSON format), consisting of more abstract entities in general.
* In the functional programming paradigm, programs are written by combining functions, the so-called *function composition* [**Quelle!**]. In microservice archiectures, as with service-oriented architectures (SOA) in generall, functionallity is build by composing services [**Quelle!**].

Many more conceptional resemblances can be pointed out. To get a basic ground to work upon, we therefore ask the first research question:

> **RQ1**: Which commonalities are microservice architectures sharing with various programming paradigms?

Not only can we draw connections to well-established programming paradigms. Each microservice is a dedicated program (and therefore a system process) itself, and each service is a component in the application architecture, so it is easy to argue that in an MSA the components are inherently concurrent. This also leads to some resemblences with concurrency models, e.g.:

* In the *actor model*, an actor is a "*self-contained, interactive, independent component of a computing system that communicates by asynchronous message passing*" [@Agh90]. While in an MSA the communication can also be synchronous, this definition of an actor has a striking resemblance with the definition for a microservice by [@DGL16] we have already introduced. Actors have a no-shared-state and immutable message philosophy, also properties of any SOA.
* The *active object pattern* allows a call of an objects method to be executed in a different thread, enabling concurrent method execution of the same object. This is achieved by using proxy objects on which the public methods of the active objects are called [@LS95]. In a microservice architecture, each service can be scaled horizontally by instantiating it multiple times. When using an API gateway to manage requests to microservices, it acts like the active object proxy, dispatching the request to a currently free service. 

We see, microservice architectures do not only have commonalities with programming principles, but also with models for concurrent programming. Therefore a close look at the concurrency aspects of this architecture style is in order. Building on the knowledge of the previous questions, we ask

> **RQ2**: Which concurrency and distributed programming concepts are especially convenient for the commonalities identified in RQ1?

And finally, after we have analysed the conceptual commonalities and related concurrency concepts, it is of interest why microservice architectures are on the rise in the first place. We have to subsequently ask the question:

> **RQ3**: Do sufficiently concurrent programming languages need microservice architectures?

~ Begin LitNote
**blablabla über microservices**

However, it is surpising that this architectural style was adopted by developers
quickly and with gread **begeisterung**. It seems that splitting up a -
presumingly easier to understand - monolythic applications into a - presumingly
harder to understand - distributed system made up of many loosley coupled and
highly cohesive (micro)applications makes it in fact either easier for the
developers to understand or solves many pressing issues when in comes to dealing
with the many requirements big applications have to serve today.

If we take a closer look at common characteristics of microservice
architectures, we will find that they look suprisingly similar to some object
oriented design principles:

~ Begin Columns
~~ Column
**OO design principles**:

* "*good OO design should be loosely coupled and highly cohesive*"
~~
~~ Column { padding-left: 4ex; }
**microservice archtiectures**:

* "*aim to be as decoupled and as cohesive as possible*"
~~
~ End Columns

~ End LitNote

---

# Expected Results { #expected-results }

The author expects that this work will result in an answer to the main research
question of "*No: sufficiently concurrent programming languages do not need
microservice architectures*". Many of the design principles are already
established in other programming language principles, first of all object
oriented design. For all of them, concurrency models have been developed and are
widely available for developers to use.  Therefore, in many of todays concurrent
programming languages, microservice architectures are only used because the
languages concurrency models and primitives make it harder for developers to
design, implement, debug and maintain - therefore ultimately *understand* - the
software architectures that serve the same design goals as the corresponding
microservice architecture does.

However, the author also expects that the only argument remaining in favour of
microservice architectures will be that todays concurrent by design programming
languages do not (yet) provide solutions for an independently deploying of their
concurrent components, e.g. the actors in the actor model. A microservice
architecture has this property inherently. Each service (= concurrent
architecture component) is its own sophisticated program and therefore at least
a system process on the same machine. This makes it possible to achieve high
scalability simply through distributing the microservices to multiple machines.

An expected conclusion of this work will therefore be, that microservice
architectures will *not* be classified as a symptom to a problem that should
have been already solved on a programming language level (as the thesis title
might imply), but that they are merely a solution to the need for high
scalability. On the other hand, many of the software applications being
developed today using microservices are consequently a side effect, for
developers grasp for easier to understand concurrency in their architectures.
Micorservices inherently force them to plan the *separation of concernces* (and
related principles we know from object oriented design) in more detail than
programming languages usually do, resulting in an easier to understand
concurrency model in their application architectures.

# Methodology and Approach { #sec-methodology }

The methodology used to answer the given research questions outlined in section [#sec-motivation] comprises the following steps:

1. In a first round of literature review, information on both programming principles as well as microservice architectures has to be gathered.
2. Based on the information base aquired in step 1, conncetions have to be drawn between programming concepts and microservice architectures in order to identify communalities and answer RQ1.
3. In the second round of literature review, information on concurrent and distributed programming concepts has to be gathered and evaluated for its applicability to the shared concepts identified in step 2 and in order to answer RQ2.
4. Two programming languages need to be identified. Both should have sufficiently enough concurrency construct. For one of the languages, the MSA style should be a common choice of architecture, despite the languages concurrent nature. For the other, at least one available concurrency approach should have a high accordance to the properties identified in RQ2.
5. Based on the knowledge aquired through RQ1 and RQ2, a prototypical scenario has to be identified, which is suited to be implemented using a microservice architecture.
6. In both languages chosen in step 4, the identified scenario from step 5 should be implemented: 
  * The implementation using the language where microservices are a common architecture style should also have a MSA. The application itself will therefore consist of multiple executable programs. Any mciroservice frameworks or libraries may be used.
  * The other implementation should use only the concurrency models available to the language, either as native constructs or via frameworks/libraries. The applications should therefore exist as a single executable artifact.
7. Based on the prototypes developed in step 6, an answer to RQ3 should be argued.

The language choices of step 5 should depend on the knowledge aquired prior. However, both languages should have ecosystem properties promoting a comparison and evaluation also towards scalability, for this is a key feature of MSA. 

For example, we propose the *Go* language for its *Goroutines* and *Channels* concurrency, and the *Erlang* language for its actor based concurrency and natural resemblance to a microservice architecture. Both languages have cheap concurrency primitives with small footprints.

On the other hand, it is also possible to select *Java* for its high utilization in microservice applications, the high availability of practically any concurrency model through libraries and the good support for MSA via frameworks, and *Scala* for its *Akka* powered and Erlang inspired actor model. Both being JVM languages, their memory footprints are inherently high. 

# State of the Art { #sec-sota }

In a recent systemantic mapping study of research literature [@AAE16], is was found that microservices architectural style research is yet at a very early stage, for the style was born from industrial needs, and academia has not yet full caught up.

In section [#problem-statement] we have given two examples for concurrency constructs resembling MSA very much. However, there the concurrent constructs were "locked" inside their  

Little has been written about the commonalities between microservices and object oriented paradigms, though some have mentioned that such exist [mehrere reference hier einfügen].

No work so war **[behandeln, bearbeiten]** the relation between those commonalities and the **[auswirkungen, einfluss]** on concurrency models

The two examples given here describe concurrency constructs where the concurrent components are "locked" inside their encapsulating program. 

If the microservice processes are also distributed accross multiple physical machines, the architecture becomes parallel. 

~ TODO
MSA evolution out of SOA, instead of revolution [@MMSL16]
~

~ TODO
MS shares many concepts from programming paradigm, especially object-oriented
~

~ TODO
OO has many concurrency models, some quite similar to the inherent concurrency of MS
~

A prominent representative of the actor model, the Erlang programming language, is currently experiencing a second spring both in industrial use and in academic attention. In contrast to most programming languages, an Erlang program has the main focus on the processes, rather than objects [@Bla13]. Its was designed for key challenges like high concurrency and availability, fault-tolerance and live-upgrades [@Vin07], similar to the needs that lead to the microservice architecture style [@DGL16; @DLL17]. Therefore, an idiomatic Erlang program has remarkable similarities with a microservice architecture. Additionally, with *Distributed Erlang*, the processes can be deployed across multiple Erlang VMs on difference host machines, incorporating even more properties of MSA [@CMT17].

While Erlang has no focus on objects, other object-oriented approaches to concurrency interprete objects as processes, and therefore as concurrent and potentially parallel entities. In [@Giv14] this idea is introduced into the `new` keyword of C++, also illustrating that other object-oriented concepts like inheritance can be built ontop this approach.

The *OrcO* programming language also as a *concurrency-first* approach to objects. Unlike active objects however, OrcOs objects to not 

~ TODO
service oriented programming und JOLIE language
~

~ TODO
hochaktuelles thema, 2016 und bereits 2017 viele papers
~


# Relevance to the Curricula { #sec-relevance }

Both the mircoservice as well as the programming language and concurrency model
aspect of this proposal correlates well with the authors curricula *Software
Engineering & Internet Computing* and subsequently the courses he took.
Microservices were the sole content of *VU Distributed Systems Engineering*,
while the courses from the *Distributed Systems* module and others with a
software engineering focus dicussed additional topics around concepts concerning
microservice architectures.

On the other hand, the many courses of the *Computersprachen und Programmierung*
module provided deep insight in the programming paradigms needed in order to
make the intended connections of this work between microservices architectures
and concurrent programming paradigms.

Additionally, in the authors seminar works he already dicussed related topics
(multicore programming in JVM languages, as well as cloud management frameworks -
often used to manage microservice applications), providing valuable precognition
for this work.

Finally, a complete list of all relevant courses, from the authors bachelors
curricula and the master curricula, is given in alphabetical order:

* VU Advanced Internet Computing
* PR Advanced Software Engineering
* VO Advanced Software Engineering
* VU Distributed Systems Engineering
* VU Distributed Systems Technologies
* VU Effiziente Programme
* VL Einführung in das Programmieren
* VU Fortgeschrittene funktionale Programmierung
* VU Fortgeschrittene objektorientierte Programmierung
* VU Funktionale Programmierung
* UE Network Engineering
* VO Network Engineering
* VU Objektorientierte Modellierung
* VU Objektorientierte Programmiertechniken
* VU Programmiersprachen
* SE Seminar aus Programmiersprachen
* SE Seminar in Distributed Systems
* PR Software Engineering und Projektmanagement
* VO Software Engineering und Projektmanagement
* VO Typsysteme
* VU Verteiltes Programmieren mit Space Based Computing Middleware
* UE Verteilte Systeme
* VO Verteilte Systeme

[BIB]
