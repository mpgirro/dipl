[INCLUDE=style/template]


Title        : Master Thesis Proposal
Subtitle     : Do sufficiently concurrent programming &br; languages need microservice architectures?
Title Note   : DRAFT, &date; (version 1.0)
Author       : Maximilian Irro
Email        : maximilian.irro@tuwien.ac.at

<!--Title Footer : April 2017-->

Toc depth    : 1
Bibliography : proposal
Bib style    : alpha
Logo         : False
Draft        : True

.LitNote { background-color: yellow }

@if not draft {
  LitNote { display: none }
}

[TITLE]

[TOC]

# Problem Statement { #problem-statement }

In 2014, a new architectures style called *microservice architecture* emerged
for designing software applications as distributed systems of loosley coupled,
independently deployable, single purpose services [@FL17]. Instead of developing
monolythic applications, developers choose to break up the application logic
into a suite of small parts, each implemented as a dedicated program designed to
provide a single task of the business logic. Theses programs are called
*microservices*.

The microservice architecture style is open for any programming language or paradigm.

Interesting enough, the architecture style itself also *shares* some similarities with some programming paradigms. For example, if we use *Definition 2* given in [@DGL16] "*A microservice is a cohesive, independent process interacting via messages*"

~ TODO
Argumentation bzgl Gemeinsamkeiten mit OO design principles (für RQ1)
~

> **RQ1**: Which commonalities are microservice architectures sharing with object oriented design principles?

~ TODO
Erklären das gesamte funktionalität aus service composition besteht, daher gemeinsamkeiten mit funkprog suchen (für RQ2)
~

> **RQ2**: Which commonalities are microservice architectures sharing with functional programming principles?

~ TODO
motivieren das microservices ja eigene prozesse sind, daher unabhänig und somit concurrent+parallel laufen. damit RQ3 motivieren
~

~ TODO
schreiben dass MS eigene data stores haben, somit auch data access parallelisiert wird. ist das ein sache bei dem traditionelle concurrency auch nicht ausreicht?
~

~ TODO
ist paralleles handling von connections auch eine sache die mit MS besser gemacht werden kann? (was steht denn in der web service concurrency DA nochmal dazu?)
~


~ Begin LitNote
**blablabla über microservices**

However, it is surpising that this architectural style was adopted by developers
quickly and with gread **begeisterung**. It seems that splitting up a -
presumingly easier to understand - monolythic applications into a - presumingly
harder to understand - distributed system made up of many loosley coupled and
highly cohesive (micro)applications makes it in fact either easier for the
developers to understand or solves many pressing issues when in comes to dealing
with the many requirements big applications have to serve today.

If we take a closer look at common characteristics of microservice
architectures, we will find that they look suprisingly similar to some object
oriented design principles:

~ Begin Columns
~~ Column
**OO design principles**:

* "*good OO design should be loosely coupled and highly cohesive*"
~~
~~ Column { padding-left: 4ex; }
**microservice archtiectures**:

* "*aim to be as decoupled and as cohesive as possible*"
~~
~ End Columns

**RQ**: What are the commonalities of object oriented design principles and microservice architectures?

This rises the question of why already programmers feel the need to design their
software applications in the form of micrsoservices, when the object oriented
models as well as many sphisticated concurrency constructs of todays established
programming languages have been around for decades.

**RQ**: Do sufficiently concurrent languages need microservice architectures?

~ End LitNote

> **RQ3**: Which concurrency and distributed programming concepts are especially convenient for the commonalities identified in RQ1 and RQ2?

And finally, after we know about the commonalities and their concurrency concepts, we have to subsequently ask the question:

> **RQ4**: Do sufficiently concurrent programming languages need microservice architectures?

To be able to give a scientifically sound answer to RQ4, a definition for "sufficient concurrency" will have to be developed. 

# Expected Results { #expected-results }

The author expects that this work will result in an answer to the main research
question of "*No: sufficiently concurrent programming languages do not need
microservice architectures*". Many of the design principles are already
established in other programming language principles, first of all object
oriented design. For all of them, concurrency models have been developed and are
widely available for developers to use.  Therefore, in many of todays concurrent
programming languages, microservice architectures are only used because the
languages concurrency models and primitives make it harder for developers to
design, implement, debug and maintain - therefore ultimately *understand* - the
software architectures that serve the same design goals as the corresponding
microservice architecture does.

However, the author also expects that the only argument remaining in favour of
microservice architectures will be that todays concurrent by design programming
languages do not (yet) provide solutions for an independently deploying of their
concurrent components, e.g. the actors in the actor model. A microservice
architecture has this property inherently. Each service (= concurrent
architecture component) is its own sophisticated program and therefore at least
a system process on the same machine. This makes it possible to achieve high
scalability simply through distributing the microservices to multiple machines.

An expected conclusion of this work will therefore be, that microservice
architectures will *not* be classified as a symptom to a problem that should
have been already solved on a programming language level (as the thesis title
might imply), but that they are merely a solution to the need for high
scalability. On the other hand, many of the software applications being
developed today using microservices are consequently a side effect, for
developers grasp for easier to understand concurrency in their architectures.
Micorservices inherently force them to plan the *separation of concernces* (and
related principles we know from object oriented design) in more detail than
programming languages usually do, resulting in an easier to understand
concurrency model in their application architectures.

# Methodology and Approach { #methodology }

~ LitNote
* Literature Review
* Proof of Concept Implementation => **TODO** wovon?!
~

# State of the Art { #state-of-the-art }




In a recent systemantic mapping study of research literature [@AAE16], is was found that microservices architectural style research is yet at a very early stage, for the style was born from industrial needs, and academia has not yet full caught up.


Little has been written about the commonalities between microservices and object oriented paradigms, though some have mentioned that such exist [mehrere reference hier einfügen].

~ TODO
hochaktuelles thema, 2016 und bereits 2017 viele papers
~

~ TODO
service oriented programming und JOLIE language
~

~ LitNote
* Service-oriented programming with JOLIE [@MGZ14]
* Microservices: yesterday, today, and tomorrow [@DGL16]
* Towards Microservices and Beyond - An incoming Paradigm Shift in Distributed Computing [@MMSL16]
* Is Parallel Programming Hard, And, If So, What Can You Do About It? [@McK17]
* A Systematic Mapping Study in Microservice Architecture [@AAE16]
* Microservices [@FL17]
* The essence of objects: Concepts and terms [@Sny93]
~


# Relevance to the Curricula { #relevance }

Both the mircoservice as well as the programming language and concurrency model
aspect of this proposal correlates well with the authors curricula *Software
Engineering & Internet Computing* and subsequently the courses he took.
Microservices were the sole content of *VU Distributed Systems Engineering*,
while the courses from the *Distributed Systems* module and others with a
software engineering focus dicussed additional topics around concepts concerning
microservice architectures.

On the other hand, the many courses of the *Computersprachen und Programmierung*
module provided deep insight in the programming paradigms needed in order to
make the intended connections of this work between microservices architectures
and concurrent programming paradigms.

Additionally, in the authors seminar works he already dicussed related topics
(multicore programming in JVM languages, as well as cloud management frameworks -
often used to manage microservice applications), providing valuable precognition
for this work.

Finally, a complete list of all relevant courses, from the authors bachelors
curricula and the master curricula, is given in alphabetical order:

* VU Advanced Internet Computing
* PR Advanced Software Engineering
* VO Advanced Software Engineering
* VU Distributed Systems Engineering
* VU Distributed Systems Technologies
* VU Effiziente Programme
* VL Einführung in das Programmieren
* VU Fortgeschrittene funktionale Programmierung
* VU Fortgeschrittene objektorientierte Programmierung
* VU Funktionale Programmierung
* UE Network Engineering
* VO Network Engineering
* VU Objektorientierte Modellierung
* VU Objektorientierte Programmiertechniken
* VU Programmiersprachen
* SE Seminar aus Programmiersprachen
* SE Seminar in Distributed Systems
* PR Software Engineering und Projektmanagement
* VO Software Engineering und Projektmanagement
* VO Typsysteme
* VU Verteiltes Programmieren mit Space Based Computing Middleware
* UE Verteilte Systeme
* VO Verteilte Systeme

[BIB]
