[INCLUDE=style/template]


Title        : Master Thesis Proposal
Subtitle     : Do sufficiently concurrent programming &br; languages need microservice architectures?
Title Note   : DRAFT, &date; (version 1.0)
Author       : Maximilian Irro
Email        : maximilian.irro@tuwien.ac.at

<!--Title Footer : April 2017-->

Toc depth    : 1
Bibliography : proposal
Bib style    : alpha
Logo         : False
Draft        : True

.LitNote { background-color: yellow }

@if not draft {
  LitNote { display: none }
}

[TITLE]

[TOC]

# Problem Statement { #problem-statement }

In 2014, a new software architectures style called *microservice architecture* (MSA) emerged
for designing software applications as distributed systems of loosley coupled,
independently deployable, single purpose services [@FL17]. Instead of developing
monolythic applications, the application logic is split up into a suite of small parts, each implemented as a dedicated program designed to provide a single task of the business logic. Theses programs posing as the applications components are called *microservices*.

The microservice architecture style is open for any programming language or paradigm. Because the microservices are communication on a network level by sending messages (e.g. REST, sockets, etc.), the services themselfs may be written in different programming languages. As long as they expose the interface required by the architecture, they are useable components.

Interesting enough, this architecture style shares some similarities with long established programming paradigms. Some examples are:

* If we use the definition given in [@DGL16] "*A microservice is a cohesive, independent process interacting via messages*", we can spot commonalities with object-oriented design principles: objects should be loosely coupled (= independent) and highly cohesive [**Quelle!**]. 
* A fundamental concept of objects is "*Clients request services from objects*". In MSA, clients request services from other microservices. Using the Smalltalk terminology, communication between objects happens by sending *messages* (object method call) between them [@Sny93]. RESTful microservices send HTTP messages.
* Simula 67 introduced the concept of objects being data structs with associated operators. Additionally, two different views were introduced: the *inside view* of an object - its local variables, procedures on these variables, initialising operations etc. - and its *outside view*, more abstract entities representing the remoteley accessible state and procedures [@Bla13]. A microservice too has an internal view (the programs internal architecture, state, etc.) and an outside view, the network interface it exposes (e.g REST APIs and data in JSON format), consisting of more abstract entities in general.
* In the functional programming paradigm, programs are written by combining functions, the so-called *function composition* [**Quelle!**]. In microservice archiectures, as with service-oriented architectures (SOA) in generall, functionallity is build by composing services [**Quelle!**].

Many more conceptional resemblances can be pointed out. To get a basic ground to work upon, we therefore ask the first research question:

> **RQ1**: Which commonalities are microservice architectures sharing with various programming paradigms?

Not only can we draw connections to well-established programming paradigms. Each microservice is a dedicated program (and therefore a system process) itself, and each service is a component in the application architecture, so it is easy to argue that in an MSA the components are inherently concurrent. This also leads to some resemblences with concurrency models, e.g.:

* In the *actor model*, an actor is a "*self-contained, interactive, independent component of a computing system that communicates by asynchronous message passing*" [@Agh90]. While in an MSA the communication can also be synchronous, this definition of an actor has a striking resemblance with the definition for a microservice by [@DGL16] we have already introduced.
* The *active object pattern* allows a call of an objects method to be executed in a different thread, enabling concurrent method execution of the same object. This is achieved by using proxy objects on which the public methods of the active objects are called [@LS95]. In a microservice architecture, each service can be scaled horizontally by instantiating it multiple times. When using an API gateway to manage requests to microservices, it acts like the active object proxy, dispatching the request to a currently free service. 

We see, microservice architectures do not only have commonalities with programming principles, but also with models for concurrent programming. Therefore a close look at the concurrency aspects of this architecture style is in order. Building on the knowledge of the previous questions, we ask

> **RQ2**: Which concurrency and distributed programming concepts are especially convenient for the commonalities identified in RQ1?

And finally, after we have analysed the conceptual commonalities and related concurrency concepts, it is of interest why microservice architectures are on the rise in the first place. We have to subsequently ask the question:

> **RQ3**: Do sufficiently concurrent programming languages need microservice architectures?

~ Begin LitNote
**blablabla über microservices**

However, it is surpising that this architectural style was adopted by developers
quickly and with gread **begeisterung**. It seems that splitting up a -
presumingly easier to understand - monolythic applications into a - presumingly
harder to understand - distributed system made up of many loosley coupled and
highly cohesive (micro)applications makes it in fact either easier for the
developers to understand or solves many pressing issues when in comes to dealing
with the many requirements big applications have to serve today.

If we take a closer look at common characteristics of microservice
architectures, we will find that they look suprisingly similar to some object
oriented design principles:

~ Begin Columns
~~ Column
**OO design principles**:

* "*good OO design should be loosely coupled and highly cohesive*"
~~
~~ Column { padding-left: 4ex; }
**microservice archtiectures**:

* "*aim to be as decoupled and as cohesive as possible*"
~~
~ End Columns

~ End LitNote

---

# Expected Results { #expected-results }

The author expects that this work will result in an answer to the main research
question of "*No: sufficiently concurrent programming languages do not need
microservice architectures*". Many of the design principles are already
established in other programming language principles, first of all object
oriented design. For all of them, concurrency models have been developed and are
widely available for developers to use.  Therefore, in many of todays concurrent
programming languages, microservice architectures are only used because the
languages concurrency models and primitives make it harder for developers to
design, implement, debug and maintain - therefore ultimately *understand* - the
software architectures that serve the same design goals as the corresponding
microservice architecture does.

However, the author also expects that the only argument remaining in favour of
microservice architectures will be that todays concurrent by design programming
languages do not (yet) provide solutions for an independently deploying of their
concurrent components, e.g. the actors in the actor model. A microservice
architecture has this property inherently. Each service (= concurrent
architecture component) is its own sophisticated program and therefore at least
a system process on the same machine. This makes it possible to achieve high
scalability simply through distributing the microservices to multiple machines.

An expected conclusion of this work will therefore be, that microservice
architectures will *not* be classified as a symptom to a problem that should
have been already solved on a programming language level (as the thesis title
might imply), but that they are merely a solution to the need for high
scalability. On the other hand, many of the software applications being
developed today using microservices are consequently a side effect, for
developers grasp for easier to understand concurrency in their architectures.
Micorservices inherently force them to plan the *separation of concernces* (and
related principles we know from object oriented design) in more detail than
programming languages usually do, resulting in an easier to understand
concurrency model in their application architectures.

# Methodology and Approach { #methodology }

~ LitNote
* Literature Review
* Proof of Concept Implementation => **TODO** wovon?!
~

# State of the Art { #state-of-the-art }




In a recent systemantic mapping study of research literature [@AAE16], is was found that microservices architectural style research is yet at a very early stage, for the style was born from industrial needs, and academia has not yet full caught up.

In section [#problem-statement] we have given two examples for concurrency constructs resembling MSA very much. However, there the concurrent constructs were "locked" inside their  

Little has been written about the commonalities between microservices and object oriented paradigms, though some have mentioned that such exist [mehrere reference hier einfügen].

No work so war **[behandeln, bearbeiten]** the relation between those commonalities and the **[auswirkungen, einfluss]** on concurrency models

The two examples given here describe concurrency constructs where the concurrent components are "locked" inside their encapsulating program. 

If the microservice processes are also distributed accross multiple physical machines, the architecture becomes parallel. 

* evolution out of SOA, instead of revolution [@MMSL16]

~ TODO
hochaktuelles thema, 2016 und bereits 2017 viele papers
~

~ TODO
service oriented programming und JOLIE language
~



# Relevance to the Curricula { #relevance }

Both the mircoservice as well as the programming language and concurrency model
aspect of this proposal correlates well with the authors curricula *Software
Engineering & Internet Computing* and subsequently the courses he took.
Microservices were the sole content of *VU Distributed Systems Engineering*,
while the courses from the *Distributed Systems* module and others with a
software engineering focus dicussed additional topics around concepts concerning
microservice architectures.

On the other hand, the many courses of the *Computersprachen und Programmierung*
module provided deep insight in the programming paradigms needed in order to
make the intended connections of this work between microservices architectures
and concurrent programming paradigms.

Additionally, in the authors seminar works he already dicussed related topics
(multicore programming in JVM languages, as well as cloud management frameworks -
often used to manage microservice applications), providing valuable precognition
for this work.

Finally, a complete list of all relevant courses, from the authors bachelors
curricula and the master curricula, is given in alphabetical order:

* VU Advanced Internet Computing
* PR Advanced Software Engineering
* VO Advanced Software Engineering
* VU Distributed Systems Engineering
* VU Distributed Systems Technologies
* VU Effiziente Programme
* VL Einführung in das Programmieren
* VU Fortgeschrittene funktionale Programmierung
* VU Fortgeschrittene objektorientierte Programmierung
* VU Funktionale Programmierung
* UE Network Engineering
* VO Network Engineering
* VU Objektorientierte Modellierung
* VU Objektorientierte Programmiertechniken
* VU Programmiersprachen
* SE Seminar aus Programmiersprachen
* SE Seminar in Distributed Systems
* PR Software Engineering und Projektmanagement
* VO Software Engineering und Projektmanagement
* VO Typsysteme
* VU Verteiltes Programmieren mit Space Based Computing Middleware
* UE Verteilte Systeme
* VO Verteilte Systeme

[BIB]
