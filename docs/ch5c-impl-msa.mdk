
## Microservice-based Implementation {#ch-microservice-impl}



~ Epigraph { caption: "Ian Robinson"}
Be of the web, not behind the web.
~


This section covers the strategies applied by programming with the microservice model with respect to a specific technology stack to implement the concurrent system outlined in Section [#ch-scenario]. The focus will be on the linguistic support provided by the technology stack. Efficiency considerations will be part of Chapter [#ch-evaluation].

### Service Technology Stack


Service-oriented programming languages seem to be a good choice for a microservice architecture. Though some languages are theoretically matured, from a practical point SOC languages are as of yet still at an early, prototypical stage. Jolie for example still misses an ecosystem and tool support we are looking for compared to Akka. Therefore, we refrained from using Jolie to implement Echo. 

Instead, we compose microservices using a more traditional technology stack. Java serves as the programming language. Services are based on the *Spring* [@PivotalSpring] framework collection, most notably its *Spring Boot* module for application fundamentals. Additionally, the *Spring Cloud* module collection has proven very effective for microservice development in industrial applications [@Car17]. 

Spring is based around the concept of *inversion of control* (IoC). There, programmers can focus on implementing so-called *concerns* of arbitrary nature regarding the application. The actual execution logic of the concerns, i.e.\ the scheduling on a thread-pool, is left to the IoC container. This approach is usually referred to as *dependency injection* [@Wal07]. Conceptually, IoC has a certain resemblance to the execution of actors by an actor runtime [@Hal06].

As we did with the actor implementation, in subsequent sections we will pay attention to the linguistic support provided by the framework regarding the expression of service requirements.


~ todo
mehr?
~


### Internal Service Concurrency


~ todo
Hier muss ich für den neuen Text was zitieren!
~

The microservice model paradigm does not dictate restrictions on internal service structure. A service is free to apply concurrency internally, and to utilize every concurrency mechanism it sees fit (including actors). 

Echo's services are based on the Spring framework and utilize the concurrent programming structure that is provided through Spring's IoC container. Spring services receive requests (we discuss the communication mechanism in Section [#sec-ms-communication-mechanisms] below) as method calls to objects of `@Component` annotated classes. Each of these method calls is therefore wrapped into a `Runnable`{language:java} and appended to a task queue. A `TaskExecutor`{language:java} constantly processes the task queue. `Executor`{language:java} is the Java concept name for a thread-pool. Each task is therefore eventually executed on an allocated thread of the thread-pool. We've already demonstrated how arbitratry method calls are easily wrapped as a `Runnable task`{language:java} in the Java concurrency case study of Chapter [#ch-concurrency]. [REF für den absatz!]{.red}. This kind of method execution scheduling has resemblance to the event-based semantics of actor systems [@Hal06]. 

Since microservices are concurrent internally, we must mind shared internal resources. We must either ensure resources are immutable like with we have to for message in Akka, or synchronize the access to a resource. Spring uses software transactions for synchronization.   

Spring provides linguistic support in a *declarative programming* style for many strategies and mechanisms [@Wal07]. This is particularly interesting since the declarative style is not intrinsic to Java's imperative programming concept. However, the language allows us to introduce declarative programming through *annotations*, so that the Spring framework then applies appropriate behavior. In contrast to annotation processors, where annotations are read by the compiler to influence the compilation process (e.g.\ to generate class implementations), Spring uses *reflection* at runtime. We leverage the declarative style for synchronization by defining software transactions on method calls using the `@Transactional` annotation. Spring also extends the STM to database transactions transparently [@Wal07].

While Spring enqueues each request into a concurrent task queue automatically, we as programmers also want to use this technique to achieve higher concurrency inside a microservice. The `@Async` annotation allows us to declare methods as asynchronously dispatchable. When calling an `@Async` annotated method, Spring wraps the call into a `Runnable`{language:java} and enqueue the resulting task into the task queue. Since the method will execute at an unknown point in time for the caller, we cannot expect a result value directly. An `@Async` method is therefore `void`{language:java} in general. Alternatively, we can return a result wrapped in a `Future`{language:java}. We've seen this idea for active objects already, with their future type methods. The future allows us to return an intermediate result and provides an interface to check whether the actual result is yet available. The author has experience that Spring's default `AsyncTaskExecutor`{language:java} does not handle exceptions and subsequently does not log their occurence either. We've found this factor troubling for development. Echo therefore uses a custom `ExceptionHandlingAsyncTaskExecutor`{language:java} to fix this flaw.

Although Spring's declarative programming style for concurrency is very powerful, we've found some limitations. The `@Async` and `@Transactional` annotations only show effect on `public`{language:java} methods. Additionally, self-invocation of an `@Async` method won't spawn a new asynchronous task, but instead execute within the same task in a synchronous fashion.

~ todo
__Ich brauche so dringend Literatur für dieses Kapitel!__
~

~ todo
Wenn ich oben was zu den `akka.dispatch.Future` schreibe, dann hier vielleicht der Hinweis das das "normale" Futures sind.
~


<!-- TODO delete?
## (Data Coupling)

[DIESES UNTERKAPITEL EINFACH WEGLASSEN?]{.red}

~LitNote
No direct referencing via REST, async messages same temporal decoupling as with Actors; dadurch das nachrichten idR durch praktisch jeden kommunikationskanal immer serialisiert werden (weil immer der process-scope verlassen wird) sind die nachrichten immer immutable, da es kein pass by reference gibt (anders als bei Akka zB)
~    

From the strict notion of isolation the Microservice paradigm provides follows a high form of cohesion. It is generally agreed upon that cohesion and coupling are contrary. By implications, high cohesion leads to lower coupling [zitieren, da gibts mehrere stellen bei den OOP sachen irgendwo]{.mind}. 

The abstinence from mutable shared memory and the emphasise on open, well defined communication protocols adds to the loosening of coupling. Any open protocol offers good technological heterogenity, as we discussed in section [#sec-technological-heterogeneity]. This requires data to be transmitted in a serialized form, that is readyable by all endpoints [citation needed]{.mind}.

REST-based communication is a good example. Data is transmitted using HTTP, therefore basically plain text. To formalize (de-)serialization, usually an open format is used ontop, e.g.\ XML, JSON or YAML [citation needed]{.mind}.

Message passing through MOMs is also...

The combination of no shared memory and well-defined serialized data exchange frees Microservice Architectures from the risk of accidentially sharing references to state that introduces the risk of 

~Todo
Im Prinzip verhindert das auch alle formen von Aliasing, was am Franz gefällt, und ich kann darüber auch bei Actors vll etwas schreiben? Nur brauche ich dazu eine Literaturquelle
~   
-->


### Isolation and Persistence


Each microservice is by definition instantiated as a system level process. The isolation of services is founded on the strict memory boundaries enforced by the operating system. By convention, services refrain from implementing shared memory sections among them. We therefore never require synchronization among the components. The principle must be extended to the persistence of state.

Persisting information can be implemented in many different strategies. Database systems are one well established approach. If we share a database between several microservices, every service gets access to all other component's persistent state. Database sharing pose a simple way to skip isolation mechanisms and bypass the service interfaces, thus breaking the encapsulation principle. Therefore, one convention of the microservice principles is that each service owns its databases exclusively [@Dra17a]. Sharing a persistence mechanism conceptionally relates to sharing state, which introduces an implicit form of shared state communication [@Cou05].

As a consequence, we must provide each component with a very own database if we require persistence. Every CatalogStore instance is deployed with a dedicated PostgreSQL database system, and every IndexStore is accessing a separate Lucene reverse index datastructure. 

Persistance is a form of IO and as such a potential performance limiting factor. Hence, Database management systems usually support concurrent access to the database . As with actors, concurrent connections increase throughput significantly. The *Spring Data* module offers a good interface as well as a transparent abstraction to interact with the database in a concurrent way [@Wal07]. 

~ Figure { #fig-persistence-microservice; caption: "Microservice maintaining several connections to an exclusive database"; width:45%; float:left; margin-right: 1ex; }
![img-persistence-microservice]
~

[img-persistence-microservice]: graphics/persistence-microservice.[svg,png] "Image about microservice persistence" { width: 85%; vertical-align:middle; padding-bottom:1em; }


Since Spring executes all requests concurrently inside a `Runnable`{language:java} task on a thread-pool, concurrent database interactions are implicitely available. Every thread of the pool can interact with the database at the same time. The transactional memory of Spring extends to database transactions. We can observe that programmers do not have to pay additional concern or apply additional strategies to leverage efficient persistency through database concurrency. Hence, we expect a microservice to have several database connections in place at the same time (Figure [img-persistence-microservice]). 


### Communication Mechanisms {#sec-ms-communication-mechanisms}


~ todo
Hinweis das Daten IMMER (bei REST wie AMQP) in JSON serialisiert werden -> keine Datentyp inkompatibilität probleme
~


[hab ich diesen blabla nicht schon bei der theory]{.red}

Communication in microservice architectures happens via inter-process communication mechanisms. Various kinds of interfaces are possible. While communication for actors happens in a uniform way, microservices are in general faced with more challenges. The freedom in the design of services does not dictate a specific communication interface. The only restriction regarding interaction is omitting shared memory between services. Solely relying on message passing mechanism makes services cohesive and loosely coupled.

We've found scholars to give REST (__Re__presentational __S__tate __T__ransfer) as the prime (and often sole) example of valid communication channels throughout the literature. However, the author has experienced it to be practical only in certain situations. As REST builds upon synchronous HTTP, it is a good solution for synchronous requirements. Echo facilitates REST for search inquiries through the Web application (`G` &rightleftarrows; `S` &rightleftarrows; `I`), as well as metadata retrieval from the CatalogStore (`G` &rightleftarrows; `D`).

As even Fowler & Lewis [@Fow14] in their original microservice definition point out, other mechanism are applicable as well, as long as they are lightweight and do not apply logic of their own. The index aggregation information flow that is building and refreshing the Stores is more predestined for an asynchronous workflow, since no immediate reaction has to occur as a result to accepted message. Therefore, we desire a message queue-like mechanism. JMS (__J__ava __M__essage __S__ervice) [@Cou05] is a prominent example among JVM technologies. However, JMS is also limited *to* the JVM, which contradicts the open and well-defined interface principle of microservices. 

We require a technology heterogenous message queue standard. AMQP (__A__dvanced __M__essage __Q__ueue __P__rotocol) [@AMQP] is an open specification for asynchronous messaging. While JMS only defined the interfaces, AMQP also defines the message format. These definitions have the advantage that different implementations are possible and we can interchange them freely. Various AMQP compatible technologies, so-called *providers*, do exist. Echo builds upon *RabbitMQ* [@PivotalRabbitMQ], a messaging system that has proven to integrate well in MSAs [@Dra17c]. Message queues conceptually introduce new components into the architecture:

* Message Queues (Q)
  : are distributed point-to-point communication channels offering message delivery from a sender to a qualified receiver (possibly unknown to the sender) decoupled in time and space (asynchronous) [@Cou05]. 

<!--
~ Figure { #fig-ms-channels; caption: "Microservice communication channels"; width:50%; float:left; margin-right: 1ex; }
![img-ms-channels]
~

[img-ms-channels]: graphics/ms-channels.[pdf,svg,png] "Image about Microservice communication channels" { width: 85%; vertical-align:middle; padding-bottom:1em; }
-->

The queue becomes an intermediate for all asynchronous messages. Senders push messages to the queue, and receivers subsequently pull those messages from the queue.

~ Figure { #fig-message-queue; caption: "Message queue"; width:45%; float:left; margin-right: 1ex; }
![img-message-queue]
~

[img-message-queue]: graphics/message-queue.[svg,png] "Image about a message queue" { width: 80%; vertical-align:middle; padding-bottom:1em; }

[Example]{.example-title}: We do not send a message directly from a Web Crawler to a Parser (`W` &rarr; `P`), where the active component is only `W`. Instead, Figure [#fig-message-queue] shows how the Crawler pushes a message `W` &rarr; `Q`. At some later point and idle Parser pulls this message `P` &larr; `Q`. The message travels asynchronously. The actively communicating components are `W` and `P`. The queue is merely invoked by other components and performs routing logic internally. The queue also decouples the sender `W` from the actual receiver `P`, i.e.\ `W` does not know which concrete `P` will receive and process the message.

In general, a service can have several different interfaces, based on heterogenous technologies. As a result, this allows the service to provide the *same* functionality on *different* interfaces. In fact, the messages that Echo's services are consuming from the AMQP queue can also be sent to the services directly via HTTP. All services offer respective REST interfaces. The additional option to invoke service functionality turned out especially useful for testing and debugging purposes. This suggests that it is valuable to maintain different interfaces for production as well as maintenance operations. 


#### Programming Abstractions {#src-ms-programming-abstractions}


We've already seen that Spring provides a declarative programming style through annotations. The implementation of an annotation's behavior uses relection. The benefit of reflection is that we can still apply deployment configuration without the need to recompile, which is especially useful for communication configuration. The downside is additional runtime overhead and the lack of static compatibility checking. 

For example, a Searcher queries an IndexStore using synchronous REST communication (`S` &rightleftarrows; `I`). We use the Spring binding for *Feign* [@OpenFeign], a library dedicated to annotation-based decorations for Java interfaces. Clients can consume RESTful endpoints using a dynamic interface implementation. We express the example in `S` by:

```{language:java}
@FeignClient(name = "index")
public interface IndexClient {
    @GetMapping("/query")
    List<Result> query(@RequestParam("q") String q);
}
```

Calling the `query`{language:java} method on a dynamically generated implementation instance for `IndexClient`{language:java} dispatches the REST call in a blocking fashion. The method only returns once the result was received from the Index. Mapping the HTTP body content of the response to domain objects is done transparently, provided that appropriate XML or JSON serializers are configured with the IoC container. As a result, every domain object can be used for the method result type. The IndexStore is able to receive the request by declaring an appropriate REST-endpoint using a similar annotation driven implementation approach: 

```{language:java}
@RestController
public class IndexResource {
    @GetMapping("/query")
    public List<Result> query(@RequestParam("q") String q) {
        // query index for phrase q
    }
}
```

This approach models a remote procedure call between the two components. Calling `query("TU Wien")`{language:java} of an `IndexClient`{language:java} in `I` is received by `IndexResource`{language:java} in `S` as a call to its `query(String)`{language:java} method with argument `"TU Wien"`{language:java}. The method invocation on the client-side is given through the service's programmer. On the server-side, the method is called by the service's inversion of control container when a respective request on the transparently exposed REST interface is registered.

We can express message queue interaction in a similar fashion through annotations dedicated to AMQP insertion and consumption. While the above REST example declares a synchronous API, the AMQP annotations declare asynchronous APIs, hence an interface method call on the client-side will return before the message has been received and processed on the server-side.

<!--
### Circuit Breaker


~LitNote
* Circuit Breaker/Hysterix for synch. communication, MQ for save decoupling in time 
* [@Mon16a] "Circuit Breakers, Discovery, and API Gateways in Microservices"
    * "Akka provides a circuit breaker implementation that supports basic configuration parameters, such as call time- out, failure threshold and reset threshold"
    * "Hystrix is much more flexible and is currently one of the reference so- lutions: it supports rolling statistics, fallback mechanisms, resource control, and control over the states and transitions of circuit breakers"
* [@Car17] "Spring Microservices in Action"
* [@NetflixHysterix]
* [@Fow14, p.12] "Microservices: a definition of this new architectural term"
  * "Synchronous calls considered harmful: ...."
~

~ todo
Circuit breaker sind die am öftesten in der Literatur beschriebene Fault tolerance / Resilience Methode for Microservices. Daher dient eine kurze Illustration an dieser Stelle als Grundlage für die spätere Evaluierung im Vergleich zur Actor fault tolerance. Vor allem bietet Spring auch eine gute linguistische Abstraktionen an, welche auf dem REST Beispiel von oben aufbaut und dieses erweitert.
~

~ todo
Bsp bzgl. Hysterix welches das Feign Bsp oben erweitert
~
-->


#### Service Discovery


Message queues decouple the sender from the receiver. Therefore, the sender neither requires nor knows the address of the actual receiver. For direct communication like REST however, we require the actual address of a recipient. Yet in certain deployment scenarios this information is not statically available. We can apply the concept of *service discovery* known from SOA [@Cou05] to bridge this lack of static information. The so-called *registry* is a dedicated service component providing binding information about other services. 

We merely predefine the connection to the registry statically and are obligated to ensure the availability of the connection at runtime. Microservices then need to register with the registry service, in order to be discoverable by others [@Mon16a]. This dedicated service is introducing a new component into the architecture:

* Discovery Registry (D)
  : are centralized services and provide address information for dynamic connections. Services need to register with the registry service providing a designation and their address. Clients are then able to lookup the current address of registered services for a given designation.

The `name` argument of the `@FeignClient` annotation in the REST example given before relates to the designation we use to register the IndexStore unit. The advantage of Feign is that it automatically integrates with discovery mechanisms. Examples for service registry technologies are *Consul* [@HashicorpConsul], a standalone registry service solution, and *Eureka* [@NetflixEureka], a module of Spring Cloud to add registry capabilities to custom applications. Echo supports Consul, but uses a dedicated service based on Eureka by default. The author of this thesis found Consul to be very resource consuming in comparison. 
<!--
Eureka, on the other hand, tends to require extensive time for initial discovery and shows this behavior also rarely on refreshes. In the call chain `G` &rarr; `S` &rarr; `I` we've experienced that the circuit breaker can trigger before the discovery has finished. We can increase the timeout of the circuit breaker, but this reduces the breaker's fail-fast intention.
-->

~ Figure { #fig-service-discovery; caption: "Service discovery calls"; width:50%; float:left; margin-right: 1ex; }
![img-service-discovery]
~

[img-service-discovery]: graphics/discovery-1.png "Image about service discovery" { width: 70%; vertical-align:middle; padding-bottom:1em; }

Using discovery mechanisms can impacts the response times of services. It can become necessary to lookup an address before a service can make a request, e.g.\ when performing a search query. Additional RPCs for registry lookups are then required up to the amount of involved services.

[Example]{.example-title}: Figure [#fig-service-discovery] shows the order of interactions in the worst case for search requests in our scenario. When all location information is outdated, then `G` must first lookup `I` with `G` &rightleftarrows; `D` (1) before it can do `G` &rarr; `S` (2). Susequently, `S` must lookup `I` with `S` &rightleftarrows; `D` (3) before it can send `S` &rarr; `I` (4). This dampens the liveness of the request flow for our search results (`G` &rightleftarrows; `S` &rightleftarrows; `I`). We also need to ensure that the information in the registry is correct and up to date. *Health checks* are a common feature of discovery services to determine if their registrees are actually up and alive [@Dra17c]. 

In contrast, message queues have the major benefit that a sender is able to dispatch a message to the queue without having to know the address of a receiver. This circumstance provides a high degree of decoupling as well as a notion of location transparency of sender and receiver. Therefore, no service discovery technology is required when we utilize message queue channels if the queue address is known statically. Otherwise, we can also use the discovery mechanism to retrieve the queue's address dynamically. 


#### Load Balancing {#sec-ms-load-balancing}


The idea of distributing work (*load*) between several instances of the same task unit is called *load balancing* (LB). The goal is to optimally utilize the resources of all instances and prevent that a single unit is overloaded. Load balancing maximizes throughput and minimizes response time of the overall system [@Ben90].

There are two directions towards load balancing. A central supervising entity distributing the work between receiving services is balancing load *server-side*. A service distributung the work among known receivers itself is doing *client-side* balancing [@Cou05]. 

Echo's microservices use the Spring Cloud module *Ribbon* [@NetflixRibbon] for client-side load balancing. The main reason for preferring Eureka over Consul for service discovery is that Ribbon is able to integrate with Eureka. A Ribbon client does not dispatch a message directly to an address obtained from the registry, but instead provide a static name that recipients have used to register with the discovery service. Ribbon can then balance individual requests directly on the client-side across server instances, as it cooperates with Eureka to maintain a set of valid instances of the respective static name [@Car17]. This name is in fact the `name` argument to the `@FeignClient` annotation of the declarative REST interface, since Ribbon is transparently integrating into Feign upon respective configuration.

In contrast, server-side load balancing requires a dedicated balancing service for recipient selection. *Zuul* [@NetflixZuul] is another Spring Cloud module for creating balancing server services. The approach requires us to add a new balancing component to the system architecture:

* Load Balancer (L)
  : [TODO]{.red} are centralized services dedicated to distribute messages between a set of equal instances...

~ todo
noch einen schönen Abschluss(ab)satz
~

~ Figure { #fig-client-side-load-balancing; caption: "Client-side load balancing: The client (S) directly maintains a list of recipients (I) directly from the discovery service (D)"; width:45%; float:left; margin-right: 1ex; }
![img-client-side-load-balancing]
~

[img-client-side-load-balancing]: graphics/load-balancing-client-side.[svg,png] "Image about client-side load balancing" { width: 50%; vertical-align:middle; padding-bottom:1em; }

~ Figure { #fig-server-side-load-balancing; caption: "Server-side load balancing: A separate load balancer (L) maintains a list of recipients (I) from the discovery service (D)"; width:45%; float:left; margin-right: 1ex; }
![img-server-side-load-balancing]
~

[img-server-side-load-balancing]: graphics/load-balancing-server-side.[svg,png] "Image about server-side load balancing" { width: 80%; vertical-align:middle; padding-bottom:1em; }



~ todo
PLATZHALTER
~


~ Findings
[Main findings]{.findings-title}

+ Different communication styles require different communication channels, e.g.\ REST for synchronous messages, and AMQP for asynchronous messages.
+ Microservices are free to serve the same functionality on different communication interfaces and technologies at the same time. 
+ Data is always serialized and exchanged in a technology neutral format (JSON), omitting data type compatibility issues. [TODO: steht das im Text?]{.red}
+ Centralized concerns (discovery, load balancing) require additional dedicated microservice units.
{.findings-list}
~

### Fault tolerance

Since the microservice model generally lacks a supervision concept, fault tolerance is a concern that must be handled directly by each service individually.

~ todo
Hier bisi was zu Fault tolerance schreiben. Kann ich auch ein Hysterix Bsp bringen. Damit das Kaputel nicht all zu kurz ist. Immerhin hab ich supervision auch bei Actors
~


### Deployment {#sec-ms-deployment}


~ todo
Hier soll dargelegt werden, wie Microservices eigentlich in die Welt gebracht werden, und welche Herausforderungen dies mit sich bringt.
~

~ todo
Dieses Unterkapitel ist noch sehr unvollständig.
~

~LitNote
* depending on specific need, some sort of cloud management framework (or a combination of more) is required. multiple instances easy with container technology (e.g.\ Docker), but no guarantee for singleton usage
* [@New15] "Building Microservices"
~

As was already mentioned, approaching Microservices at the moment is focused on a deployment view. It is not important *how* services are being implemented, as long as they are composed correctly. Note that this is however not the theoretical notion of *correctness* such that it could be asserted by applying proof techniques, e.g.\ by showing safety and liveness properties, or interface type compatibility, but a mere practical understanding of "executing and interlinking services such that the system works" [andere bezeichnung?]{.red}.

For Microservices, *container* technology has been shown to be a promising approach for deployment. It builds upon....

*Docker* [@Docker] is a prominent example of a container tool. It is especially convenient, since it facilitates...
