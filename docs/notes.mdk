[INCLUDE=style/marticle]

Title        : Diplomarbeitsnotizen
chead        : 

Toc depth    : 3 
Bibliography : dipl
Bib style    : alpha
Cite All     : False

CSS Header      :
  body.madoko {
    max-width: 98ex;
  }

[TITLE]

[TOC]

# Microservice Architectures

* <https://martinfowler.com/articles/microservices.html>

* keywords for microservices challenges from [@AAE16]:
  * Communication/Integration (API, REST, sockets, TCP, gateway, circuit breakers, load balancer, proxy)
  * Service discovery (API gateways, etc)
  * Performance ( QoS, performance, SLA, speed, simulation)
  * Fault-tolerance
  * Security
  * Tracing and Logging
  * Application Performance Monitoring
  * Deployment operations
* eventueller Vergleich mit Komponentenbasiertem Softwareentwurf? "Bei einem komponentenorientierten Softwareentwurf sind Softwaresysteme in möglichst unabhängig wartbare und wiederverwendbare Softwarekomponenten zu zerlegen. Diese Ziele lassen sich verfolgen, indem bei der Definition von Softwarekomponenten dem Entwurfsprinzip der maximalen Kohäsion bei gleichzeitig minimalen Abhängigkeiten gefolgt wird [Szyperski et al. 2002, S. 40; Parnas 1972]" -> http://www.enzyklopaedie-der-wirtschaftsinformatik.de/lexikon/is-management/Systementwicklung/Hauptaktivitaten-der-Systementwicklung/Softwareentwurf/Komponentenorientierter-Softwareentwurf/index.html


## Microservices: Granularity, Design, etc




## MSA: key concepts


## MSA: quality issues

## MSA: timeouts

* see "Laura Bocchi, Julien Lange, and Nobuko Yoshida. Meeting deadlines together. In CONCUR, pages 283–296, 2015"

## MSA: faults

* see "Sara Capecchi, Elena Giachino, and Nobuko Yoshida. Global escape in multiparty sessions. Mathematical Structures in Computer Science, 26(2):156–205, 2016"
* see "Marco Carbone. Session-based choreography with exceptions. Electr. Notes Theor. Comput. Sci., 241:35–55, 2009"

## MSA: dynamic binding

* important!
* see "Fabrizio Montesi and Nobuko Yoshida. Compositional choreographies. In CONCUR, pages 425–439, 2013"

## MSA: parametric behaviour

* important!
* see "Marco Carbone, Sam Lindley, Fabrizio Montesi, Carsten Schürmann, and Philip Wadler. Coherence generalises duality: A logical explanation of multiparty session types. In CONCUR, 2016. To appear"
* see "Nicolas Tabareau, Mario Südholt, and Eric Tanter. Aspectual session types. In MODULARITY, pages 193–204, 2014"

## Curcuit breakers

* laut [@Mon16]
  * have been popularised in (book) "Release it! Design and Deploy Production-Ready Software (Pragmatic Programmers). 2007"
  * Akka provides a circuit breaker implementation that supports basic configuration parameters
    * => hat somit Scala (und vll Spring Boot) ebenfalls inherent einen Curcuit Breaker eingebaut im Actor Modell?
  * Hysterix is much more flexible and currently one of the reference solutions; it supports rolling statistics, fallback mechanisms, resource control and control over the states and transitions of circuit breakers

## Service Discovery

* see [@Mon16] for example solutions/implementations/technologies 


## Security Vulnerabilities of SOA

* see *Len Bass, Paulo Merson, and Liam O’Brien. Quality attributes and service-oriented architectures. Department of Defense, Technical Report September,2005*

# SOA (general stuff)



---



---

# Concurrent Programming

## Foundational Issues of concurrent systems

* [@AH85] zu foundational issues in the design of programming languages for concurrent systems
  * shared resources: may chance their internal state while shared 
  * dynamic reconfiguration: dealw ith creation of new objects in the evolution of the system; must be a mechanism to for communicating the existance of such new objects or processes to already existing ones
    * in MSA ist genau das die kernaufgabe der gateway
  * inherent parallelism: programming model should exhibit inherent parallelism in the sense that the amount of available concurrency should be determined as mich as possible from the structure of the programs written
    * also MSA nutzt parallelism inherent, da jeder MS ein prozess, und daher die nebenläufigkeit des OS herangezogen wird (ggf mit multicore-paralllelität); bei aufteilung auf mehr maschinen, sowieso parallel
    

## Concurrent OOP



---




# Comparisons (welche Elemente lassen sich vergleichen)

## Objects vs MS programs

* "Essential concepts" of Objects in [@Sny93; @Bla13]:
  * obj. embodies an abstraction
    * MS tun das auch
  * obj. provides services
    * liegt bei MS im namen
  * clients issue requests for those services
    * MS werden angesprochen für ihre services, zB via REST
  * obj. are encapsulated
    * MS sind programme, daher encapsulated
  * requests identify operations
    * MS der zB via REST angesprochen wird, muss request die operation in der URL + PUT/GET/etc codieren
  * requests identify objects
    * Request muss irgendwie MS beschreiben, von dem angefordert wird (zumindest abstrakt via nicht-eindeutigen namen, damit dann ggf von Gateway auf einen konkreten dispatched werden kann)
  * new obj. can be created
    * neue MS anlegen, automatisch oder manuell
  * same operation of distinct objects can have different implementations and observably different behaviour
    * neue Programmversion von MS bringt natürlich neue Impl., und kann auch beobachtbar anderes Verhalten zeigen (zB zusätzliche aufrufe anderer Services, etc); muss halt immer noch die selbe erwartete Dienstleistung bringen, dann beeinfluss es das Gesamtsystem nicht, genau wie bei Untertypen
  * obj. can be classified in terms of their services (interface hierarchy __?__)
    * MS ???
  * obj. can share a common implementation (multiple instances)
    * mehrere instanzen des selben MS für horizontale skalierung, benötigt Gateway; essentielles argument für MSA!
  * obj. can share partial impl. (impl. inheritance or delegation)
    * delegation in MS ist service composition!
* [@Giv14] "Object-Oriented Parallel Programming"
  * Programmig objects can be interpreted as processes (example via new Operator in C++, creating Object on remote Machine)
  * Encapsulation, which is an important feature of object-oriented programming, clarifies relationships between objects, facilitating parallelization of method execution across distinct objects
    * MS sind encapsulated, und deren Methoden (= services) können durch dieses Wissen ebenfalls leicht parallelisiert werden

## Active Objects vs MS (inkl Gateways)

* [@LS95] definiert Active Object pattern als: "decouples method execution from method invocation in order to simplify synchronized access to a shared resource bymethods invoked in different threads of control"
  * genau dass, was auch in MSA passiert. 1) der MS an sich, denn auch hier bietet die REST schnittstelle eine Entkoppelung
  * Weiters wird in dem Artikel noch diese Erklärung gebracht: "To illustrate the Active Object pattern, consider the design of a connection-oriented Gateway. A Gateway decouples cooperating components in a distributed system and allows them to interact without having direct dependencies among each other"
    * Wieder genau MSA: connection-oriented gateway; decouples cooperating components in DS; interact without direct dependencies
  * Im Artikel werden noch konkrete Beispiele (zB Input/Output Handler etc) gebracht -> gut für mehr Text
* [@LS95] Use the Active Object pattern when
  * The design and implementation of a concurrent program can be simplified
    * Mein these ist auch, dass MSA hinsichtlich Concurrency leichter zu erdenken sind als andere Modelle
  * Multiple threads of control require synchronized access to shared data
    * Datastore-MS bieten ebenfalls einen synchronized data access (deren DB sind ja jeweils shared data)
  * The order of method execution can differ from the order of method invocation
    * Bei einem REST-based (zB Spring) MS, kann ich mich nicht darauf verlassen, dass der erste REST aufruf auch der erste ist der ausgeführt wird (je nachdem was im internen Spring Concurrency Modell zuerst dran kommt)
  * The operations on a shared object are relatively coarse-grained
    * coarse-grained ist eine gewünschte Eigenschaft von MSA
* [@LS95] The Active Object pattern offers the following benefit
  * Enhance application concurrency while reducing synchronization complexity
    * Wieder genau MS
  * Leverage parallelism available from the hardware and software platform
    * Auch wieder MS, "inherente Parallelität" wie ich das gerne nenne, wenn die Hardware Multi-core bzw Multi-Maschine
* [@LS95] The Active Object pattern has the following drawbacks
  * It potentially increases context switching, data movement, and synchronization overhead
  * It may be difficult to debug programs containing active objects due to the concurrency and non-determinism of the Scheduler 
* Neue Service-oriented Languages bauen auf der Idee von Active Objects auf (und diese Sprachen bauen ja im Prinzip MS auf Sprachebene nach). **In welchen Quellen stand das?**
* [@GB99] beschreibt aspekte von active objects:
  * Proactivity: an agent (= active object) has a goal; it does not simply act in response to messages from other agents (im gegensatz zum Actor model)
    * manche MS sind auch genau dafür da, während andere nur reaktiv sind (eine genaue unterscheidung gibts hier meines wissens nach in der literatur noch nicht)
  * Sociability: agents can interact by speaking different languages (hier ist was komisch-altes gemeint)
    * aber in MSA können die MS auch 1) in verschiedenen sprachen geschrieben sein, und 2) via verschiedene kommunikationsmodelle reden (REST, message queues, spaces, etc)
  * Adaptability: komisches zeugs


## Subtyping vs neue MS Version

* Subtyping: Ein Typ ist dann ein Untertyps eines Obertyps, wenn er überall dort verwendet werden kann, wo der Obertyp erwartet wird
* Vorteil von MSA: Es kann jederzeit eine neue Instanz (Update auf neue Programversion) eines MS gestartet werden, ohne das Gesamtsystem der MSA durcheinanderzubringen, solange sich der MS bzgl seiner Schnittstelle genau so verhält wie seine alte Version
* Update von MS <=> Subtype von Klassen/Objekten/etc
* Praktischer Vergleich: Dependency Injection
  * In Java Enterprise / Spring kann mittels XML basierter DI die verwendete Implementierung eines Interface Typs ausgetauscht werden, ohne das Gesamtsystem neu zu kompilieren, dh __Austausch (= Update) der Funktionalität__ ohne die gesamte Application zu ändern
  * Update und re-deploy eines MS, welcher die selbe Aufgabe erfüllt, wie zB

## Inheritance vs ??? (code reusing?)

* [@Giv14]
  * "Having defined processes as programming objects, it is now straighforward to derive new processes using previously defined processes"

[BIB]