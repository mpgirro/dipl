
## Actor-based Implementation {#ch-actor-impl}


<!--
~ Epigraph { caption: "Carl Hewitt"}
One actor is no actor. Actors come in systems.
~
-->

This section covers the strategies applied by programming with the actor model. We implement the backend of the concurrent system we outlined in Section [#sec-scenario]. All discussed concepts are with respect to the specific actor variant we use. The focus is on the linguistic support provided by the actor library. Efficiency considerations are part of Chapter [#ch-evaluation].

It is important to realize that although there is *the* conceptual actor model, there are numerous system implementations available through various forms of interfaces, either integrated into the programming language or as a library [@Kos16]. These systems are all based on the theoretical model, but may choose to compromise some of the semantic properties in order to increase efficiency [@Kar09]. Such considerations are relevant when evaluating linguistic support.

Echo is based on an actor variant called Akka [@LightbendAkka]. The Akka library is available for the JVM through bindings for Java and Scala but was later ported to other ecosystems such as .NET and JavaScript runtimes (through Scala.JS). The .NET variant (called *Akka.NET*) is to our knowledge not able to interweave with the original JVM version at the moment. Because our solution is solely based on the JVM, all following discussions refer to the capabilities of Akka's original variant.

Akka is theoretically based on Agha's vision of the actor model and harnesses its potential for distributed problem solving [@Kos16]. An archetype has been Erlang. Akka is designed as a toolkit collection consisting of several libraries. We can use these libraries in arbitrary combination based on our actual need of them. The actor runtime system is a lightweight execution environment based on work stealing thread-pools with local task queues which schedule the actor execution [@Hal12].

As of Scala version 2.10, Akka replaces the default actor implementation offered by Scala [@Hal12]. We therefore refer to the former as *Scala actors* in contrast to *Akka actors*. Among the reasons were the better performance, transparent actor addresses, expressing resilience as well as fault tolerance [@Tas13]. In fact, [@Reh13] found that Akka actors have up to 10 times higher message throughput and a network latency under 1ms, in contrast to the 0.2 seconds of Scala actors. 


### Striving for Isolation {#sec-actor-isolation}


While actors encapsulate state conceptually, in practice their *full isolation* must be ensured to avoid accidentially sharing state. This is essential to guarantee the safety properties, respectively prevent data races and state modifications [@Hal12;@Kan12]. Akka offers interfaces for Scala and Java. Both languages support object-orientation in an imperative programming style -- even though Scala is primarily a functional programming language. Since Akka is not directly integrated into either of these two languages, it cannot ensure isolation by itself. This restriction is true for most library-based actor systems running on execution environments supporting shared-memory multithreading like the JVM [@Kos16].

Therefore it is especially interesting how the isolated turn principle is handled with Akka, because, as was outlined in Section [#sec-actor-messaging-encapsulation], internal state of an actor must be modified exclusively from within the actor itself to preserve the model semantics.


#### Issue of Data Hiding


Akka's actor runtime provides a transparent interface for component communication which exist either within the same local scope (same JVM) or remote scope (distinct JVMs). In the first case, different notions of state have to be taken into account. Kniesel [@Kni96] defines *weak state* as the state given through an objects instance variables. *Strong state* is the combination of *local state* (the object's instance variables) and *transient state* (the state of objects referenced by instance variables). 

Actor semantics implies the need for a strict conception of encapsulation where the strong state is exclusive to the actor. No mutable local state must be exposed outside nor mutable transient state imported into the scope of the actor. Violation of this requirement leads to overlapping (shared) mutable state, which is in contrast to the message passing semantics of the model.

*Visibility* is a property of an object's variables and methods given they are part of the object's interface [@Kni96]. Visibility is a concern for encapsulation and subsequently shared mutability [@Sub11; @Goe06]. Java for example offers multiple granularities for visibility of class fields. The following code snippet illustrates the resulting problem:

``` {language:java}
public class Foo extends UntypedActor { 
    public String bar; 
    public static Props props() {
        return Props.create(Foo.class, () -> new Foo());
    }
    @Override
    public void onReceive(Object msg) { /* handle msg */ }
}
```

We extend `UntypedActor`{language:java}, the base class for classic actors which do not provide type-safety for messages. In contrast, Akka's `TypedActor`{language:java} is the base class for active objects, which do provide type-safety for messages [irgendwas REF]{.red}. We give the field `bar` in class `Foo`{language:java} *external visibility* by declaring it `public`{language:java}. The field is therefore part of every object of type `Foo`{language:java} and influences the object's encapsulation [@Kni96]. From visibility follows accessibility, such that `bar` is also accessible from outside the scope of `Foo`{language:java}. Since `bar` is not `final`{language:java}, we can also modify `bar` from outside the object's scope, which violates the exclusive state modification requirement of the actor semantics. 

All Java-based actor implementations therefore face the problem that custom-written actor classes can easily break the required model semantics. In order to cope with this problem, object-oriented implementations can offer APIs where interaction with an actor instance is not issued directly through the instances method interfaces, but instead via proxy constructs like [@Hal12]:

``` {language:java}
final ActorRef foo = system.actorOf(Foo.props());
```

We do not directly create an instance of `Foo`{language:java} using the `new`{language:java} keyword as is custom in Java. Instead, we use the actor system's factory method `actorOf` that hides the actual instantiation. The `create` method of `Props`{language:java} takes a Java 8 lambda as an actor object factory. The lambda and the `create` call are commonly wrapped in a `props` method of the actor class. Java lambdas are basically functional closures[^fn-clojure] and only allow us to access effectively `final`{language:java} fields inside the lambda's scope. This restriction prevents us from exposing mutable state to the constructor of an actor class. Of course, this is only true for the `final`{language:java} fields themselves, but not their members (cf.\ Java case study in Section [#sec-concurrency-language-level]).

[^fn-clojure]: Not to be confused with *Clojure*, a dialect of the programming language Lisp for the JVM.

The actor system only exposes a proxy object of type `ActorRef`{language:java} to the user. An `ActorRef`{language:java} instance does not have the external interface of the actor class it represents. The `ActorRef`{language:java} merely offers a variety of methods for sending messages to its actor. Messages sent through these methods are delivered by the actor system and then consumed by the actor through the `onReceive` method [@Sub11].

The use of `ActorRef`{language:java}s has the benefit that no direct contact with an actor instance object is possible. This lack of contact prevents both visibility and accessibility to any actor object fields or method calls. Additionally, `ActorRef`{language:java} proxies enable *location transparency* [@AkkaActor].


#### References and Immutability 


Preventing visibility of actor object fields and methods is not sufficient for guaranteeing the required strong state encapsulation on the JVM. The method signature of `onReceive`{language:java} indicates that messages are received with type `Object`{language:java}. Though Java has pass-by-value method parameters, variables with a non-primitive type (all besides `byte`{language:java}, `int`{language:java}, `char`{language:java}, etc.) are actually reference variables storing the address to their objects. A passed-by-value parameter is therefore a copy of the object-address [@Gos15]. By implication, each message sent between actors contains a copy of the reference to the object representing the message[^fn-java-pass-by-value]. In general, this reference can point to *one and the same* object, since Akka only serializes messages in case both counterparts are not within the same JVM [@Sub11]. In this case, given object is therefore in the scope of both the sending and the receiving actor, introducing shared state, which is in contrast to the strong state encapsulation requirement.

[^fn-java-pass-by-value]: This causes the illusion that Java has pass-by-reference parameters. It does not.

However, messages are meant to represent snapshot information of a state at a given point in time. Therefore, shared state is not a problem if it refers to immutable snapshots, such that there is no memory with read-write or write-write access by two distinct actors [@Kos16]. Then the facts cannot be modified by any of the holders. The encapsulation requirement explicitly refers to *mutable* strong state, as immutability avoids what Akka calls the *shared mutable state trap* [@AkkaJMM]. 

One option for Scala is to use `case class`{language:scala} constructs, which are immutable by default except for the transient state introduced through constructor parameters [@AkkaActor]. Java offers less syntactic support for expressing immutability. The property is neither formally defined in the *Java Language Specification* nor the *Java Memory Model* [@Gos15; @Goe06]. However, the basic requirement is to have `final`{language:java} fields only[^fn-java-immutability]. This means that the transient state through internally referenced objects must be marked `final`{language:java} too. The author of this thesis has found that libraries utilizing source-level annotation processing[^fn-immutables-lib] provide useful tools for generating immutable value objects. These use annotated `interface`{language:java} declarations to generate consistent implementations offering builders and factory methods for instantiation [@Goe06]. 

[^fn-java-immutability]: From a technical point of view, a class can have non-`final`{language:java} fields and still instantiate immutable objects. `String`{language:java} is a prominent example. However, deeper insight into the Java Memory Model is required. Goetz gives an outline of the principal approach [@Goe06, p.47].  
[^fn-immutables-lib]: Such as <https://immutables.github.io> for example.

All the restrictions discussed so far still cannot prevent all obstacles Java and Scala offer to break the actor model semantics. Nothing can hinder an actor from sending a message to another actor containing the `this`{language:java} reference of its object. `this`{language:java} within an Akka actor is the standard self-reference object pointer and therefore not equal to *self* from the theoretical actor model. Akka provides us with the `self()` method that returns an `ActorRef`{language:java} inside the actor for when we need to communicate the actor's location. But having access to the `this`{language:java} reference of another actor breaks location-transparent access to the respective actor. Additionally, Java access modifiers are on class level instead of object level. If the recipient is of the same dynamic type as the `this`{language:java} reference sender, then the recipient (after the corresponding typecast) has access to all `private`{language:java} fields of the corresponding actor object. Though this visibility feature completely bypasses the encapsulation principle, it is intended behavior of the Java language design.

We see, a library-based actor variant like Akka cannot enforce strict actor semantics by itself, if the programming language offers ways to break the semantics to the programmers. Only a programming language itself can enforce a strict notion of the actor semantics, as does for example Erlang. However, in general it is sufficient if programmers comply with coding conventions specific to the language to avoid shared state by accident [@Tas13]. Conventions come with the burden of ensuring immutables value objects or manually deep-copying messages when required. Other actor frameworks like Orleans always provide deep-copied messages automatically, which comes with a performance penalty [@Ber14].

It is worth pointing out that though the actor model is Scala's standard concurrency variant, the language was not designed to enforce strict actor semantics. Instead it accepts the perils that come with a library-based implementation. The arguments for a library are [@Hal09; @Tas13]:

* A library does not require special support by the compiler, JVM or extra syntax.
* A library can be easily extended, adapted, and even replaced. This has already happened, when the standard Scala actors have been replaced under the hood by Akka actors.
* A library can break the actor semantics *intentionally*, e.g.\ to introduce an additional concurrency abstraction, as the next section demonstrates. 


~ Findings
[Main findings]{.findings-title}

+ Programming language features can jeopardize actor state encapsulation. 
+ Library-based actor systems cannot ensure isolation by themselves.
+ Guaranteeing message immutability is the obligation of the programmer.
<!--+ Message interoperability between programming languages is challenged by data type compatibility.-->
{.findings-list}
~


### Utilizing other Concurrency Constructs


In Section [#sec-actor-concurrency-combination] motivated why we can combine the actor model with other abstractions of concurrency, as long as the actor semantics is not jeopardized. Akka offered support for several additional concurrency models, although with version 2.3 combining actors with software transactional memory into so-called *transactors* was dropped. In principle, they've been useful for coordinating computations which span over the scope of multiple actors and require consensus between all of them [@Sub11]. However, transactional memory usage has never been able to abstract distribution transparently in Akka, since STM requires shared memory which is difficult across JVMs [@Swa14]. Transactor support was removed eventually.

Besides STM, much more prominently used is the future concept. Futures allow us to define concurrent computation *inside* an actor [@AkkaFuture]. However, futures are not without perils of their own, as the following example illustrates:

```{language:scala}
var a = 0
override def receive = {
  case _ =>
    implicit val ec: ExecutionContext = context.dispatcher
    Future { a += 1 }
    a -= 1
    print(a)
}
```

First of all, Akka requires a so-called `ExecutionContext`{language:scala} in scope to run the future on [@Hal18]. The example uses the actor's `Dispatcher`{language:scala}, which represents the thread-pool on which the actor runtime executes the actor. We can also specify a separate thread-pool instead [@AkkaFuture].

Most importantly however, futures can be misused to introduce nondeterminism into the scope of an actor. The example defines some mutable state variable. Upon receiving an arbitrary message, we dispatch a `Future`{language:scala} with the task of modifying this state. Concurrently, the actor continues to process the message and attempts to also modify the very same state variable. Due to the nondeterministic nature of the underlying thread-pool, multiple orders of execution are possible, and therefore also multiple results for the output statement. This is possible because Java as well as Scala do not provide any kind of guarantee regarding the safety of data inside the scope of a `Future`{language:java} that exceeds the regular notion of safety of the respective language [@Wel05].

The isolated turn principle demands a guarantee that nothing interferes with the internal state of an actor except the actor itself, at the very least while processing a message. Yet futures have the potential to violate this constraint, thus breaking the actor semantics. Once again, Akka can neither check nor prevent this kind of concurrent modification. The programming languages visibility concepts simply allow passing mutable state into the scope of the futures. Then their safety notion permits the mutation of this state. Again, it is up to the programmer to ensure that only *immutable* state is introduced into the scope of a future [@Sub11; @AkkaJMM].

There are also less expected issues related to futures. All aggregation of remote resources by Crawlers are performed via HTTP. In principle, HTTP is a synchronous communication protocol, such that there is always a response to every request[^fn-synchronous-http]. Most APIs are therefore blocking as they abstract over remote procedure call semantics. However, some APIs allow us to handle requests asynchronously by providing a future result. The author expected to improve the throughput of the Crawler when feeds are retrieved via an asynchronous handling of HTTP requests. The basis for this assumption was that HTTP connections to remote servers pose as potential bottlenecks (unknown server response time, network latency), thus reducing the liveness of the actor. However, this approach dispatches great many `Future`{language:java}s simultaneously. Feed endpoints have a wide variation in response times and an asynchronous API allows us to start requests before the previous request has finished. All these futures stress the thread-pool of the Crawlers. We've experienced temporary starvations due to a lack of available threads in the Crawler's thread-pool. The author observed this effect with both asynchronous client APIs of the *Akka HTTP* [@AkkaHTTP] module and the *Apache HTTP Components* [@ApacheHttpComponents] library. Akka HTTP also provides a *flow*-based variant, where the concept of *backpressure* known from *stream*-based programming should limit throughput accordingly. However, the author experienced that the underlying *super connection pool flow* also introduces a limit to the amount of concurrent requests to a single host [@AkkaHTTP]. Feed publishers nowadays often choose to distribute their feeds via dedicated providers. As a result, a great amount of feeds are centralized on a small amount of host, rendering Akka's flow variant inapplicable.

[^fn-synchronous-http]: The most basic form is merely a status code, e.g.\ the famous 404. 
 
Although simple RPC-styled retrieval did limit throughput, we've found this to also be an advantage on the other hand. The limitation puts a uniform and more predictable stress on the thread-pool, avoids problems like actor starvation and maintains their overall liveness. There are however still other cases where futures can come into play. The following section continues discussing future usage in the light of communication.

~ Findings
[Main findings]{.findings-title}

+ We can combine actors with additional compatible concurrency models.
+ As with isolation, programming language features can jeopardize actor semantics when applying alternative concurrency constructs.
+ Combining futures with actors can have a negative impact on performance.
{.findings-list}
~


### Communication Abstractions {#sec-actor-communication-abstractions}


The actor model is solely built on the concept of *asynchronous* message passing. Akka provides a respective method called `tell`, with an additional alias `!`\ for Scala, on `ActorRef`{language:scala}. We can use the method to dispatch a message object to an actor. However, many real-life scenarios expect communication to be synchronous, i.e.\ to only proceed once an answer has been received and not perform any processing in-between. Echo faces this problem whenever a user is requesting information, i.e.\ search requests through the Web application (`G` &rightleftarrows; `S` &rightleftarrows; `I`), as well as metadata retrieval from the CatalogStore (`G` &rightleftarrows; `D`). Fortunately, synchronous communication can be modeled with an asynchronous information flow [@Agh97].

#### Future-based Messaging


Akka provides a primitive to introduce synchronous information flow. In addition to the asynchronous `tell [!]` command, `ActorRef`{language:scala} also offers the `ask` method, with alias `?`\ in Scala [@AkkaActor]. We can use `ask` to model request/reply-style communication [@Hal09]. An `ask`-call resembles a `tell`-call in that it dispatches the method's argument as a message to the actor behind the reference. However, `ask` offers a result value, respectively the expected result of a synchronous call wrapped in a `Future`{language:scala}. The caller of `ask` is free to either proceed its computation, or go directly into blocking until the `Future`{language:scala} is resolved. This semantics resembles the future type message passing of active objects.

~ Figure { #fig-pipeline-search-future; caption: "Example message flow of a future-based synchronous call"; width:50%; float:left; margin-right: 1ex; margin-top:1em; }
![img-pipeline-search-future]
~

[img-pipeline-search-future]: graphics/search-future.[svg,png] "Image about pipeline of a search request using futures" { height:1.3cm; vertical-align:middle; padding-bottom:1em; }

[Scenario Example]{.example-title}: A search request is the prime example for a synchronous call. Figure [#fig-pipeline-search-future] shows how a request travels from the Gateway to a Searcher and finally to an IndexStore. The results are propagated back from `I` via `S` to `G`. The results are wrapped in a `Future`{language:scala} until it is resolved. We can resolve a `Future`{language:scala} inside an actor (e.g.\ a Searcher) in a waiting fashion, which causes the actor to block. The actor cannot process other request until it receives the answer from the IndexStore. However, we need to avoid blocking if we expect Searcher to process messages in reasonable time. We want to improve throughput. To prevent unnecessary blocking, Scala provides monadic methods for the `Future`{language:scala} trait that we can use to define subsequent computation once the result becomes available. This methods can also be utilized when dispatching several synchronous messages inside actors. Scala even offers specialized syntax through the so-called *for-comprehension* [@Hal18]:

```{language:scala}
val f1: Future[Int] = actor1 ? msg1
val f2: Future[Int] = actor2 ? msg2
val f3: Future[Int] = actor3 ? msg3

val r = for {
   r1 <- f1
   r2 <- f2
   r3 <- f3
} yield (r1 + r2 + r3)
```

It is important however, that the messages are dispatched prior to the `for`{language:scala}-block's scope. Otherwise it will enforce sequential composition, if the `ask`-calls are inlined into the block scope [@AkkaFuture]. This is because for-comprehension unfolds to monadic combinator usage of `flatMap` and `map`, which are sequential by nature [@Hal18]. The example above becomes:

```{language:scala}
val r = f1.flatMap(r1 => f2.flatMap(r2 => f3.map(r3 => r1 + r2 + r3)))
```

It is clear to see that if the `ask`-calls are inlined into the `for`{language:scala}-block, then the second message only gets dispatched once the first `Future`{language:scala} is resolved. Yet if used correctly, we can harness futures to preserve the single-threaded semantics of actors and still leverage parallel computation inside an actor.

However useful, this approach has two downsides. First it is a load on resources, since every `Future`{language:scala} also stresses the actor's thread pool. Secondly, there is always the risk of accidentally passing the actor's internal mutable state into the `Future`{language:scala}'s scope, thus introducing race conditions [@Sub11]. `ask` per se is therefore not ideal in any case, but using futures with actors still has a long tradition [@Tas13]. 


#### Delegation-based Messaging


One of the basic actor primitives allows an actor to spawn new actors. We can leverage this ability to model synchronous request handling by utilizing newly created actors merely for temporary usage. The result handling is hereby relocated to a dedicated child actor, individually spawned for each request. We creating a child in Akka by:

```{language:scala}
val handler = context.actorOf(ReponseHandler.props())
index.tell(msg, handler)
```

Using `context.actorOf` instead of `system.actorOf` makes the response handler a direct descendent of the current actor. Providing the obtained `ActorRef`{language:scala} as a second argument to `tell`[^fn-2nd-tell-argument] sets the response handler as the official sender of the message. This way, we set the handler as the recipient to the response of the message. This dynamically created actor poses as a temporary component in the architecture:

* Response Handlers (H)
  : exist with the sole purpose of posing as the original sender of a simple `tell` message dispatch and eventually receive an answer in a purely asynchronous fashion, or detect a timeout. Upon message receival, they pass on the result and deconstruct. 

~ Begin Figure { #fig-pipeline-search-delegation; caption: "Example message flow of a delegation-based synchronous call"; width:50%; float:left; margin-right: 1ex; margin-top:1em; }
![img-pipeline-search-delegation]
~ End Figure

[img-pipeline-search-delegation]: graphics/search-delegation.[svg,png] "Image about pipeline of a search request using delegation" { height:3.9cm; vertical-align:middle; padding-bottom:1em; }

The actual information flow turns from the concept definition `G` &rightleftarrows; `S` &rightleftarrows; `I` into the concrete realization `G` &rarr; `S` &rarr; `I` &rarr; `H` &rarr; `G` (Figure [#fig-pipeline-search-delegation]). Altering the reply destination is a form of the *delegation* concept known from object-orientation [@Yon86]. The overall approach is sometimes referred to as *cameo pattern* and mostly used for brief and simple interactions between actors [@All13]. The cameo pattern provides an asynchronous composition style to handle synchronous communication requirements. The approach is also more implementation independent, if no handy concept like futures are offered by the actor variant.

[^fn-2nd-tell-argument]: Note that the `!`\ alias of `tell` does not allow more than one parameter.

As synchronous communication is constraint by time in general, it is important that the messages for a cameo delegation are processed swiftly. The actor model's mailbox construct however buffers all incoming messages to an actor in a strict FIFO (__F__irst __I__n __F__irst __O__ut) order. Large mailboxes with many messages queued up prevent timely message processing. Influencing the order of message reception is therefore a common property for actor systems [@Kos16]. Akka provides the concept of a `PriorityMailbox`{language:scala}, which is utilizing the pattern matching syntax of Scala to assign priority levels to messages based on their type. IndexStores and CatalogStores are facilitating priority mailboxes to process all messages involved in synchronous flows first, regardless of the current mailbox size.  


#### Modelling Timeouts


Synchronous information flow requires a mechanism to implement timeouts in order to prevent starvation. Akka supports a special timing mechanism. Actors, e.g.\ newly spawned delegation-slaves, can register to receive a timeout message after a given time period. The actor then simply needs to define an appropriate message behavior to handle the timeout message. When the expected message of the synchronous flow is received before the timeout message, the actor cancels the dispatch of the timeout message. However, if the timeout message is received prior to the response message, then the timeout occured and a respective reaction is executed [@All13; @Roe15].

It is interesting how timed messages are introduced into the actor system. Timers require some sort of concurrent thread that constantly checks the current time and performs registered trigger actions. Dedicated thread-based concurrency is somewhat opposed to the actor model and message passing in general, where each action happens as a reaction to a received message, decoupled from a notion of time. Therefore, offering solutions for timer mechanisms are a concern of many actor systems, e.g.\ also in Erlang [@Arm93] and Orleans [@Ber14].

To avoid interference of outside threads with actor states, Akka provides a special `Scheduler`{language:scala} instance that is unique for each system. Actors register a message sending operation with this `Scheduler`{language:scala} that triggers after a certain period of time:

```{language:scala}
val messenger: Cancellable = context.system.scheduler
    .scheduleOnce(5.seconds) { 
        self ! TimeoutMessage
    }
```

The provided `Cancellable`{language:scala} reference allows us to prevent the trigger from firing by calling `messenger.cancel`{language:scala}. This scheduling mechanism introduces a notion of time into the actor semantics that feels natural to the actor model [@AkkaScheduler]. In combination with the cameo pattern it is possible to implement synchronous information flow semantics including time constraints by using purely asynchronous message passing operations. 


#### Type-restricted Messages and Compatibility {#sec-type-restricted-messages-and-compatibility}


One of the basic actor primitives allows actors to send messages to other actors. However, in general this does not define restrictions on the types of messages that are sent. Messages are untyped in the theoretical actor model. The behavior of an actor decides at runtime when it processes a message whether it is able to handle the message.

The active object concept aims to provide a higher-level abstraction and provides static guarantees for message types. Active objects leverage the method signatures of the standard object model for static type checking. However, the active object model also uses the method's signature to define the method's dispatch semantics. The work of Waldo *et al.* [@Wal96] describes in detail why this abstraction can become problematic, especially in a context with transparent distribution. In short, the abstraction provided by the object model does not incorporate some effects of distribution well. Examples for such effects are latency, memory access (via pointers), partial failure and concurrency effects in general. The transparent abstraction of local and remote execution is therefore problematic with active objects. The object model must explicitely distinguish local and remote interaction to be robust and reliable. The actor model on the other hand explicitely does not distinguish between local and remote message recipients. Current developments in Akka therefore address the challenge of offering some level of type safety for messaging without using Akka's `TypedActor`{language:java}s for active objects. The APIs are summarized under the name *Akka Typed* [@AkkaTyped].

One part of Akka's strategy to harden the isolation of actors is to never expose a reference to an actual actor instance directly. Instead, all communication happens via the messaging interfaces of the `ActorRef`{language:scala} proxies (`tell`, `ask`). These interfaces take arbitrary types as messages. Akka Typed introduces a generic type parameter to the address, i.e.\ `ActorRef[U]`{language:scala}. The range of accepted messages is then limited to `U`{language:scala}-typed objects. The signatures of the messaging methods changes from `tell(msg: Any)`{language:scala} to `tell(msg: U)`{language:scala}.

It is worth pointing out that in Scala messages have the type `Any`{language:scala} in general, while the messages in Java have the type 
`Object`{language:java}. This discrepancy of the most general type is somewhat counterintuitive, since Akka offers compatible bindings for both languages. The type systems of Java and Scala however deviate. Java distinguishes between reference types with `Object`{language:java} as &top; in the type hierarchy and primitive types (`int`{language:java}, `char`{language:java}, etc.) which are not subtypes of `Object`{language:java}. Hence, primitive types cannot be used as messages. In Scala on the other hand, all variables have `Any`{language:scala} as their unified &top;. The direct descendent `AnyVal`{language:scala} is the supertype of all value types (`Int`{language:scala}, `Char`{language:scala}, etc.), while `AnyRef`{language:scala} corresponds to Java's `Object`{language:java} and is therefore also supertype to all non-value types. If an `AnyVal`{language:scala} is sent from a Scala to a Java actor, the corresponding primitive type's wrapper class (`Integer`{language:java}, `Character`{language:java}, etc.) is received and vice versa.

In any case, type-restricted actor addresses are not without drawbacks. The third basic model primitive states that actors can change their behavior. When we restrict accepted messages by an `ActorRef[U]`{language:scala} that is hiding behavior changes transparently, we must also constrain a new behavior to process messages of type `U`{language:scala} exclusively. Otherwise, the address of the actor represented by the `ActorRef[U]`{language:scala} breaks the semantics and becomes invalid [@AkkaTyped]. To ensure address and behavior compatibility at compile time, we must define type-restricted actors through a behavior function that is also restricted by a type parameter:

```{language:scala}
val behavior: Behavior[U] = 
    Actor.immutable[U] { (_, msg) =>
        // process msg
        Actor.same
    }
```

In this example, the typization `msg:U`{language:scala} is guaranteed. The `Actor.immutable`{language:scala} factory prevents the constructed behavior from holding and passing over mutable state [@AkkaTyped]. Every behavior has to specify the replacement behavior for the next message explicitly. In this example, `Actor.same`{language:scala} declares that the replacement behavior stays the same.

Though Akka Typed provides static type safe messaging, it still has its limits. For example, Akka Typed is not able to statically ensure that a behavior is in a certain state. The association of an actor's address and behavior is a fundamentally dynamic property of the actor model [@AkkaTyped]. 

We've found that compile-time message safety restrictions, apart from active objects, are a rare capability among actor systems. However, the Akka Typed library is in the current Akka version 2.5 still under active research. It is marked as "may change" and to be considered experimental.

~ Findings
[Main findings]{.findings-title}

+ Actor runtimes can provide additional abstractions for synchronous communication. These abstractions either require additional concurrency models (futures) or additional actors (delegation).
+ An explicit sense of time is contrary to the actor concept. Timing must be handled by the runtime and communicated in terms of messages.
+ The actor model intrinsically types all received messages dynamically. Hence, sending messages is usually rather weakly-typed in actor systems. We can achieve stronger typization for sending messages by type-restricting the actor addresses.
{ .findings-list }
~


### Supervision and Monitoring


In Section [#sec-actor-systems] we've pointed out that actor systems aim for higher-level constructs than the low-level basic model primitives. One example for higher-level abstractions are the different messaging styles Akka facilitates. Another important reason for providing more expressive constructs is the encapsulation of faults [@Agh90]. Being aware of the possibility of faults and handling them adequately is key especially in a distributed context [@Cou05]. Orleans for example directly reports exceptions back to the message sender [@Ber14].

The key to handling faults in Akka is its concept of *supervision*. No actor exists for itself, but is always subordinate to its supervising actor. This dependency relationship is called *supervision hierarchy*. The actor system provides a default supervisor at the top-level, which has the eventual supervision of all other actors [@AkkaSupervision].  

The hierarchical relationship is fairly simple: a supervisor delegates work to its subordinate children, but in return is bound to *monitor* them. Monitoring is the concept of getting notified of a subordinate's failures, and in turn reacting to these failures. A fault can be of arbitrary nature, i.e.\ an unhandled exception or invalid state. An actor automatically suspends itself and all its subordinates upon the occurrence of a failure. The runtime then notifies the superior, which has to provide a response to the failure [@All13;@Roe15]. 

The signaling of an occurred failure is not communicated via a "normal" actor message, but on a side channel [@AkkaSupervision]. Failure notifications are handled by a so-called *supervision strategy*. One of four possible actions can be shown by a supervision strategy:

* Action 1: Resuming the suspended child, when the fault can be safely ignored.
* Action 2: Restarting the suspended child, if its internal state is invalid.
* Action 3: Stopping the child completely by not continuing its execution.
* Action 4: Escalating the failure, hence the supervisor fails itself.
{ list-style-type:none }

A supervisor's failure notification has the sole form of an exception. No state information that puts this exception into context is offered. The reason is that state should only belong to and be processed by one actor exclusively. Assuming a failure results in the propagation of state to the supervisor, then part of the child's implementation logic leaks into its supervisor. The supervisor requires the knowledge to interpret the state in order to evaluate it in a meaningful way. However, Akka isolates the failure in the child. In case the child is gets resumed (Action 1), the cleanup falls to the child itself. The message on which the fault occurred is not re-introduced into the mailbox, to avoid fault-reoccurrence. Actions 2-4 discard the child's state in any case [@Roe15;@AkkaSupervision].


### Information Routing and Delivery Reliability


We must frequently send a message not to one actor specifically, but to distribute the message among a set of equivalent instances. Akka provides an appropriate concept called *routers*:

```{language:scala}
val router: Router = {
    val routees = Seq(searcher1, searcher2, searcher3)
    Router(RoundRobinRoutingLogic(), routees)
}
router.route(queryMsg, sender())
```

Routing to potential recipients can follow various strategies, depending on the used `RoutingLogic`{language:scala}. The `RoundRobinRoutingLogic`{language:scala} of the example redirects the message to the next routee in a cyclic order. Many alternative routing strategies are available, e.g.\ `RandomRoutingLogic`{language:scala} for a random recipient, and `BroadcastRoutingLogic`{language:scala} to distribute the message to all routees [@All13].

Conceptually, we can do the routing directly inside the sending actor by replacing the `tell(m,s)` call with `router.route(m,s)`. Alternatively, we can also employ an intermediate actor. The decision is based on the burden of managing the routees. The set of routees has to be kept up to date, since actors can fail and no message must be sent to a terminated actor. If the routees are children of the routing actor, then the router gets informed through its supervision obligation in the case of a subordinates demise. A supervision-managed set of routees is called a *pool* [@Roe15]. Since supervision is the foundation of a pool, it can be useful to use a separate component for routing, especially if actors are part of several router pools, or a parent-child relationship is otherwise logically inadequate:

* Message Routers (R)
  : distribute received messages among equally qualified potential recipients, based on a certain selection strategy, the *routing logic*. Routers are intermediate units and supervise their routees. They only forward messages to living children. 

<!--
~ Figure { #fig-message-router; caption: "Message router"; width:45%; float:left; margin-right: 1ex; }
![img-message-router]
~

[img-message-router]: graphics/message-router.[svg,png] "Image about a message router" { width: 70%; vertical-align:middle; padding-bottom:1em; }
-->

[Example]{.example-title}: When a Web Crawler needs to pass on a downloaded XML feed to an arbitrary Parser, the Crawler does not directly select the recipient. Figure [#fig-message-router] (left) shows that the actual information flow incorporates an intermediate router: `W` &rarr; `R` which then distributes it `R` &rarr; `P` for some `P` $\in \{$`P`~1~$\cdots$`P`~n~$\}$  selected on the basis of the routing logic. An appropriate logic in this particular case is `RoundRobinRoutingLogic`{language:scala}.


~ Begin Figure { #fig-message-router; caption: "Message routers (R) with different routing logics: `RoundRobinRoutingLogic`{language:scala} (left) and `BroadcastRoutingLogic`{language:scala} (right)"; width:100%; }

~ Begin Columns
~ Begin Column { width:50% }
~ Begin Center
![img-message-router-roundrobin]
~ End Center
~ End Column

~ Begin Column { width:50% }
~ Begin Center
![img-message-router-broadcast]{margin-left:4rem}
~ End Center
~ End Column
~ End Columns

~ End Figure

[img-message-router-roundrobin]: graphics/message-router-roundrobin.[svg,png] "Image about a message router (roundrobin)" { height:3.5cm; vertical-align:middle; padding-bottom:1em; }

[img-message-router-broadcast]: graphics/message-router-broadcast.[svg,png] "Image about a message router (broadcast)" { height:3.5cm; vertical-align:middle; padding-bottom:1em; }

Alternatively, routees are part of a so-called *group* when the router is not supervising the routees [@Roe15]. Akka provides the so-called *actor selection* mechanism to send a message to an address matching a certain pattern. When no supervision relationship exists, message delivery reliability becomes a special concern. Actor selection does not guarantee that a recipient conforming to the pattern exists. Therefore, a message can become a so-called *dead letter* when the runtime cannot deliver the message. 

Delivery reliability is also a general concern of sending messages to actors, besides the context of routing. The theoretical actor model guarantees that all messages are always delivered [@Agh85b]. Conceptually, this insurance is important since it implies that no actor can permanently starve [@Kar09]. In practice however, we cannot safely assume perfect delivery reliability to hold. Because we consider actors in a potentially distributed context, message delivery can be subject to a network link. Recalling Fallacy 1: *The network is reliable* warns us that we cannot trust the network the transport the data in general. As a result, neither can we assume actor message delivery. Akka therefore provides a weaker insurances regarding message delivery reliability than the theoretical actor model. Particularly, all messages are merely guaranteed to be delivered *at-most-once*. Additionally, when several actors send messages to the same recipient, there is no guarantee of a general order of the messages in the mailbox. Merely the messages of each particular sender are enqueued into the receivers mailbox in the same order as the sender dispatched the messages (FIFO order) [@AkkaMDR].

In contrast, other actor systems like Orleans provide *at-least-once* delivery by resending messages that have not been acknowledged within a certain timeframe [@Ber14]. No message is ever lost but can emerge duplicated instead. As a consequence, the application logic of actors with at-least-once delivery must cope with the fact that one and the same message can be received several times. 

~ Findings
[Main findings]{.findings-title}

* Actors exist within a hierarchical supervision structure.
* Failure is communicated along side the hierarchy while state does not leave the boundary of an actor.
* Supervision is useful for complex message routing logics.
{ .findings-list }
~


### Persistence and IO {#sec-actor-persistence}


We must employ some kind of data persistence mechanism, e.g.\ a database, in order to persist the internal states of actors. Echo's CatalogStores are a prime example. Due to the single-threaded semantics of actors, only a single interaction with the database is possible at the same time. This is inefficient, since database access is input/output and therefore a performance limiting factor in general [@Sub11]. Theoretically, the single-threaded semantics of actors makes database transactions obsolete, but the author has found that common APIs demand an active transaction in any case, e.g.\ with providers of the __J__ava __P__ersistence __A__PI (JPA).

We can overcome the single-threaded limitation by utilizing a non-blocking API for database connections. These APIs provide a `Future`{language:scala} reference to an eventual result at the cost of stressing the actor's thread-pool. With the monadic methods of `Future`{language:scala} we can then define further computation on the result once it becomes available. The price is the immanent risk of accidental data races by passing mutable state into the `Future`{language:scala}'s scope.  

~ todo
Hier schreiben das ich Delegation verwende wegen meinem Benchmark; für "gleiche Vorraussetzungen"
~

Alternatively, the author has found that the delegation principle we've discussed for synchronous message handling is also an efficient strategy. We can handle several database interactions concurrently by having as many actors communicate with the database at the same time. 

~ Figure { #fig-persistence-actor; caption: "Logical task unit composed of several actors interacting with a shared database"; width:45%; float:left; margin-right: 1ex; }
![img-persistence-actor]
~

[img-persistence-actor]: graphics/persistence-actor.[svg,png] "Image about actor persistence" { width:5cm; vertical-align:middle; padding-bottom:1em; }

[Example]{.example-title}: A CatalogStore actor has a database. Conceptually we wanted to use the database to persist the state of a single actor. If the database is managed by several actors, the state is not exclusive anymore. However, we need several actors for concurrent interaction. We see, we must intentionally weaking the encapsulation principle. Although the database conceptually belongs to the CatalogStore, the store actor delegates all database interactions to it's children (Figure [#fig-persistence-actor]). The interaction tasks are distributed between the children using a `RoundRobinRoutingLogic`{language:scala}.

[This strategie breaks with our specification that each architecture component is a concurrent task unit of the programming model.]{.red} Now, the CatalogStore component consist of several task units of the actor model, which conceptually share a single persistent state. We must not break the isolation of each actors however. Therefore, these children neither share the same database connection interface object, nor any other mutable data. We merely loosen up the restriction on encapsulating the persistent state inside one single actor. A narrow group of actors is managing the persistent state instead. All these actors must utilize the database system's transaction mechanism. We use a dedicated dispatcher for all actors involved in the logical encapsulation of the persistent state. The underlying thread-pool uses a fixed number of threads. This provides a predictable impact on performance, in contrast to Akka's default dynamically sized thread-pools. Dynamic pools add threads when demand is high, i.e.\ due to many blocking operations, and can therefore consume a lot of system resources [@All13].

~ Findings
[Main findings]{.findings-title}

+ Efficient handling of persistence and IO in general uses the same strategies as for synchronous actor communication.
+ Concurrent database interaction via delegation forces us to intentionally weaken the conceptual encapsulation of actor state.
{.findings-list}
~

<!--
## Clustering

~ todo
Hier kurz die Unterschiede und benötigten Erweiterung zwischen Actors in einem rein lokalen system (single-node) und einem verteilten Setup (distributed nodes) beschreiben. Akka hat hierfür sehr gute Konzepte, welche allerdings Verlangen auf ein paar Dinge zu achten.
~

~LitNote
* Cluster / Remoting of Akka, built in discovery system among nodes  
* Cluster Singleton required by Updater, Cluster Sharding
~

~ green
The capabilities of the Actor model to support distribution was first described by Agha [REF-diss]{.red}, and since it was introduced in many variants of Actors [REF1, REF2, REF3]{.red}. 

...Erlang auch sehr wichtig

...die Erlang deutung auch sehr viel in Akka drinnen

...wichtig das die mechanismen die lokal für actos gehen auch verteil gelten 
~
-->
